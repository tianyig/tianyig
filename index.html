<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="风过无痕">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="风过无痕">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风过无痕">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>风过无痕</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风过无痕</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">这城市华灯初上，多两个人悲剧散场</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Schedule</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>Sitemap</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>Commonweal 404</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/JavaScript/JavaScript原理-单线程下的异步/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/16/JavaScript/JavaScript原理-单线程下的异步/" class="post-title-link" itemprop="url">JavaScript原理:单线程下的异步</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-16 21:55:14" itemprop="dateCreated datePublished" datetime="2018-12-16T21:55:14+08:00">2018-12-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-04 17:28:15" itemprop="dateModified" datetime="2019-01-04T17:28:15+08:00">2019-01-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="JavaScript是单线程"><a href="#JavaScript是单线程" class="headerlink" title="JavaScript是单线程"></a>JavaScript是单线程</h3><p>简单的来说，GUI开发一般是要处理两类事件：界面布局渲染、用户交互。用户交互的过程中可能会触发耗时操作，例如请求网络、查询本地数据库等。如果代码的执行是同步顺序执行的话，就意味着所有的任务包括用户的交互操作都要排队，前一个任务结束，才能执行下一个任务，假设前一个任务次次不结束，界面就会出现卡死的情况。所以图形界面编程语言都支持多线程，把耗时的任务放在子线程，住线程能继续处理用户交互或者界面渲染， 让用户体验变得更好。  </p>
<p>JavaScript语言的一大特点就是单线程。JavaScript的主要功能是操作DOM和和用户交互，假设设计成多线程，其中一个线程往某个DOM节点添加内容，另一个线程删除了该DOM节点，这个时候，浏览器应该以哪个线程为准呢？所以，为了避免复杂性，JavaScript就被设计成了一个单线程的语言。但是，作为一个单线程语言，是怎么处理异步事件的呢？为了解答这个疑问我们先看下下面两个概念。    </p>
<h3 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h3><p>JavaScript引擎最流行的就是Google的V8引擎了,Chrome和Node.js目前都使用了<a href="https://v8.dev/" target="_blank" rel="noopener">V8引擎</a>。除此之外，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。下面是一个简化了的JS引擎示意图：</p>
<p><img src="/assets/images/javascript/engine.png" alt="img01"></p>
<p>JS引擎主要有两个部分组成：</p>
<ul>
<li>内存堆：这是进行内存管理的地方。</li>
<li>调用堆栈：这是管理代码执行过程中函数栈帧的地方。</li>
</ul>
<h3 id="JavaScript运行时"><a href="#JavaScript运行时" class="headerlink" title="JavaScript运行时"></a>JavaScript运行时</h3><p>JavaScript开发人员基本上都用过<code>setTimeout</code>或者<code>ajax</code>等这些异步的API。但是JavaScript是单线程的，JS引擎并没有提供这些API。那么这些API来自哪里呢？</p>
<p><img src="/assets/images/javascript/runtime.png" alt="img01"></p>
<p>实际上，这些都是JS的运行时环境提供的。如果JS运行在浏览器上，那么这些就都属于Web API，这些API还有<code>EventLoop</code>和<code>callback queue</code>都是由浏览器提供的。</p>
<p>JS引擎只有一个线程，当前函数栈执行完成之后就去不断的取消息队列里的的消息，取到了就执行。JS运行时，就负责给消息队列发送消息，例如网络请求或者用户的交互事件。JS引擎负责取消息执行，JS运行时负责发送消息。</p>
<h2 id="JavaScript运行过程"><a href="#JavaScript运行过程" class="headerlink" title="JavaScript运行过程"></a>JavaScript运行过程</h2><p>JS运行时不断产生事件放到消息队列里，JS引擎的唯一线程也就是主线程不断从消息队列中取出事件去执行。伪代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体过程可以也参考下图：<br>（引用<a href="http://vimeo.com/96425312" target="_blank" rel="noopener">《Help, I’m stuck in an event-loop》</a>）</p>
<p><img src="/assets/images/javascript/eventloop.png" alt="eventloop"></p>
<p>从图中可以看出，JS引擎的运行的过程中，维护了一个主线程的执行过程的堆栈信息。如果在运行的过程中代码调用了外部API，JS运行时会把这个消息添加到队列。继续运行直到当前执行栈为空，事件循环会从队列中取出下一个消息放到执行栈中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">Concurrency model and Event Loop</a></li>
<li><a href="https://vimeo.com/96425312" target="_blank" rel="noopener">I’m stuck in an event-loop.</a></li>
<li><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">JavaScript执行过程示意图</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/17/swizzle-addObject-in-NSMutableArray/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/17/swizzle-addObject-in-NSMutableArray/" class="post-title-link" itemprop="url">swizzle addObject: in NSMutableArray</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-03-17 13:51:12" itemprop="dateCreated datePublished" datetime="2017-03-17T13:51:12+08:00">2017-03-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2017-03-20 13:42:30" itemprop="dateModified" datetime="2017-03-20T13:42:30+08:00">2017-03-20</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>事情的经过是这样的，有个朋友问为何<code>swizzle addObject</code>没有效果并贴出代码。下面是当时的实现(有修改)：</p>
<pre><code>+(void)load
{
    Class class = [self class];
    SEL originalSelector = @selector(addObject:);
    SEL swizzledSelector = @selector(se_addObject:);

    Method originalMethod = class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

    //先调用 class_addMethod,为了防止swizzle掉父类的方法导致后面的swizzle出现隐藏的bug（有可能子类A 替换到方法func:，然后子类B 又把func替换回来）
    BOOL didAddMethod =
    class_addMethod(class,
                    originalSelector,
                    method_getImplementation(swizzledMethod),
                    method_getTypeEncoding(swizzledMethod));

    if (didAddMethod) {
        class_replaceMethod(class,
                            swizzledSelector,
                            method_getImplementation(originalMethod),
                            method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}

-(void)se_addObject:(id)anObject
{
    NSLog(@&quot;调用了替换后的方法&quot;);
    if(anObject) {
        [self se_addObject:anObject];//#1
    } else {
        NSLog(@&quot;啦啦啦啦啦&quot;);
    }
}
</code></pre><p>我第一感觉<code>se_addObject</code>是个死循环，但是修改#1代码为<code>[self addObject:anObject];</code>之后发现swizzle方法仍旧没有调用。<br>难道swizzle失败了吗？但是跟踪调试发现swizzle成功了。但是为什么没有调用呢？在解释这个问题之前，我们先<code>NSMutableArray</code>的继承结构：</p>
<p><img src="/assets/images/autorelease/array.png" alt="img01"></p>
<p>其中以下划线开头的类是框架隐藏的类，这些继承体系可以通过<code>class-dump</code>来验证:</p>
<pre><code>class-dump --arch i386 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation | grep &quot;: NSArray&quot;
</code></pre><h2 id="Class-Clusters"><a href="#Class-Clusters" class="headerlink" title="Class Clusters"></a>Class Clusters</h2><p>Class Clusters（<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html" target="_blank" rel="noopener">类簇</a>）是设计模式中工厂模式的实现，这种实现类似C++中多态的实现，使用基类指针指向不同的派生类，将函数调用转发给不同派生类的实现。在这里，NSArray和NSMutableArray实际上是抽象类，通过NSArray和NSMutableArray接口创建返回的实际上是子类对象，这一过程是如何实现的呢？经过研究发现，<code>NSArray</code>的子类都未实现<code>alloc</code>函数，所以子类在调用<code>alloc</code>函数的时候，实际上调用的都是<code>NSArray</code>实现，反汇编<code>NSArray</code>发现<code>allocWithZone</code>的实现大致如下（改变为伪代码）：</p>
<pre><code>-(instancetype)allocWithZone:(struct _NSZone *)zone
{
    if ([self isKindOfClass:[NSArray class]]) {
        self = [__NSPlaceholderArray immutablePlaceholder];
        return self;
    } else if ([self isKindOfClass:[NSMutableArray class]]) {
        self = [__NSPlaceholderArray mutablePlaceholder];
        return self;
    }
    self = [super allocWithZone:zone];
    return self;
}
</code></pre><p><code>alloc</code>会调用<code>allocWithZone</code>,<code>NSArray</code>根据消息发送者的不同返回了不同子类。所以在我们调用<code>[NSMutableArray alloc]</code>的时候通过<code>NSPlaceholderArray</code>的类方法返回了<code>NSPlaceholderArray</code>类型，并保存当前数组类型信息为<code>mutablePlaceholderArray</code>。</p>
<pre><code>id obj1 = [NSArray alloc];          // __NSPlacehodlerArray *
id obj2 = [NSMutableArray alloc];   // __NSPlacehodlerArray *
</code></pre><p><code>NSArray</code>和<code>NSMutableArray</code>在作为抽象类,<code>isa</code>指针在初始化之前都是指向<code>NSPlaceholderArray</code>。所以swizzle的都是<code>__NSPlacehodlerArray</code>的实现。</p>
<pre><code>id obj1 = [NSArray alloc];
id obj2 = [NSMutableArray alloc];
[obj1 addObject:@&quot;aa&quot;];
[obj2 addObject:@&quot;aa&quot;];
</code></pre><p>这两种情况都会调用swizzle之后的<code>se_addObject</code>方法。</p>
<p>__NSPlacehodlerArray实现如下：</p>
<pre><code>- (id)init {
    if (self == ___immutablePlaceholderArray()) {
        self = [[__NSArrayI alloc] init];
    }
    else if (self == ___mutablePlaceholderArray()) {
        self = [[__NSArrayM alloc] init];
    }
    return self;
}
</code></pre><p>可以通过控制台验证：</p>
<pre><code>(lldb) po [[NSMutableArray alloc] class]
__NSPlaceholderArray

(lldb) po [[[NSMutableArray alloc]init] class]
__NSArrayM

(lldb) po [[NSArray alloc] class]
__NSPlaceholderArray

(lldb) po [[[NSArray alloc]init] class]
__NSArray0
</code></pre><p>最后那个之所以是<code>__NSArray0</code>，是<code>NSPlaceholderArray</code>在初始化时对没有元素的情况做了优化。</p>
<h2 id="处理插入nil数据崩溃"><a href="#处理插入nil数据崩溃" class="headerlink" title="处理插入nil数据崩溃"></a>处理插入nil数据崩溃</h2><p>针对这种场景，已经有一些开源框架<a href="https://github.com/jasenhuang/NSObjectSafe" target="_blank" rel="noopener">NSObjectSafe</a>、<a href="https://github.com/JJMM/SafeKit" target="_blank" rel="noopener">SafeKit</a>。但是这样处理真的合适吗？</p>
<p>我觉得并不合适，原因如下：</p>
<ol>
<li>我们的代码不能兼容错误操作。插入nil数据本身是错误操作，如果这种错误有可能出现，就尽早抛出异常，或者插入之前验证数据的合法性。对于一个库的设计来说也是如此，对用户不正确的使用要尽早抛出异常，而不是猜测用户意图，兼容错误操作。错误发现的越晚，造成的影响越大。<a href="https://en.wikipedia.org/wiki/Fail-fast" target="_blank" rel="noopener">fail-fast</a></li>
<li>更改系统的实现是个危险的操作。针对当前这种情况来说，可能有其他库依赖这种特性。比如<code>Core Data</code>捕获了插入<code>nil</code>的异常并且业务里处理了这种异常，我们更改了<code>addObject</code>的实现之后会影响<code>CoreData</code>。</li>
<li>降低性能。作为一个包括底层框架和应用层很多库要用到的大量频繁的方法，增加一行判断也可能会降低性能。</li>
</ol>
<p>如果真的有必要在插入数据之前判断数据合法性，可以参考苹果官方给出的<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html#//apple_ref/doc/uid/TP40010810-CH4-SW81" target="_blank" rel="noopener">例子</a>，使用如下继承的方式重写相关的函数：</p>
<pre><code>@interface ValidatingArray : NSMutableArray
{
    NSMutableArray *embeddedArray;
}
</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://blog.sunnyxx.com/2014/12/18/class-cluster/" target="_blank" rel="noopener">从NSArray看类簇</a></li>
<li><a href="http://iosqqmail.github.io/2016/01/04/2016-1-4_Swizzle_Foundation%E5%AE%B9%E5%99%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener">Swizzle Foundation容器的正确姿势</a></li>
<li><a href="http://ciechanowski.me/blog/2014/03/05/exposing-nsmutablearray/" target="_blank" rel="noopener">Exposing NSMutableArray</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html" target="_blank" rel="noopener">Class Clusters</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/Autorelease的原理与实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/10/Autorelease的原理与实现/" class="post-title-link" itemprop="url">Autorelease的原理与实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-03-10 13:32:24" itemprop="dateCreated datePublished" datetime="2017-03-10T13:32:24+08:00">2017-03-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2017-03-19 10:20:31" itemprop="dateModified" datetime="2017-03-19T10:20:31+08:00">2017-03-19</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>众所周知，在C/C++中内存管理是非常重要的内容，内存管理是C／C++程序员的基本功，为了方便内存管理，C++的库(STL&amp;&amp;Boost)提供了各种智能指针的实现。同样在iOS MRC时代，iOS的开发也是需要手动内存管理，手动内存管理麻烦而且容易出错，严重影响程序健壮性和开发效率。为了改善这种情况，苹果在iOS5推出了新功能ARC(Automatic Reference Counting)。ARC是如何实现的？objc和编译器底层帮我们做了哪些事情，它们是如何管理内存的？</p>
<h2 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a><strong>Autorelease</strong></h2><p>在MRC时代，<code>alloc</code>创建的对象必须在对象生命周期结束时调用<code>release</code>或者在创建之初调用<code>autorelease</code>。如下：</p>
<pre><code>方式1
NSObject *testObj = [[NSObject alloc]init];
//insert code
[testObj release];

方式2
NSObject *testObj = [[[NSObject alloc]init] autorelease];
</code></pre><p>内存管理的第一原则：谁创建，谁释放。所以方式1我们很容易理解；方式2是如何管理对象的生命周期的？其实调用<code>autorelease</code>方法其实是把当前对象添加到<code>autoreleasepool</code>中管理，我们就不需要手动释放了。</p>
<h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a><strong>@autoreleasepool</strong></h2><p>iOS工程<code>main.m</code>中<code>main</code>函数的实现如下：</p>
<pre><code>int main(int argc, char * argv[]) {  
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre><p>main函数的的业务实现我们不关心，我们只关心<code>@autoreleasepool</code>到底是什么，为了方便，我们改写main函数如下：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *objTest = [[NSObject alloc]init];
    }
    return 0;
}
</code></pre><p>在命令行中使用<code>clang -rewrite-objc main.m</code>让编译器用<code>C++</code>改写这个函数,改写后的代码简化如下：</p>
<pre><code>int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        NSObject *objTest = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));
    }
    return 0;
}
</code></pre><p><code>@autoreleasepool</code>在改写后被注释掉了，同时在作用域的第一行生成了一个<code>__AtAutoreleasePool</code>的C++对象，全局搜索可以看到<code>__AtAutoreleasePool</code>定义如下：</p>
<pre><code>struct __AtAutoreleasePool {
  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();}
  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}
  void * atautoreleasepoolobj;
};
</code></pre><p>这个结构体(和class的唯一区别是不能定义私有变量或私有函数)只有一个构造函数和析构函数，析构函数是在作用域结束时自动调用的，所以<code>main</code>函数代码等价如下：</p>
<pre><code>int main(int argc, const char * argv[]) {  
    {
        void * atautoreleasepoolobj = objc_autoreleasePoolPush();
        //other operator
         objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    return 0;
}
</code></pre><p>然后看下这两个函数的实现：</p>
<pre><code>void *
objc_autoreleasePoolPush(void)
{
    return AutoreleasePoolPage::push();
}

void
objc_autoreleasePoolPop(void *ctxt)
{
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre><p>可以看出只是简单的对<code>AutoreleasePoolPage</code>的封装。<code>AutoreleasePoolPage</code>又是什么？下面就从它的结构和实现上逐步剖析<code>AutoreleasePoolPage</code>。</p>
<h3 id="AutoreleasePoolPage的结构"><a href="#AutoreleasePoolPage的结构" class="headerlink" title="AutoreleasePoolPage的结构"></a><em>AutoreleasePoolPage的结构</em></h3><p>它的结构如下：</p>
<pre><code>class AutoreleasePoolPage {  
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
};
</code></pre><ol>
<li>magic 用来校验 AutoreleasePoolPage 的结构是否完整；</li>
<li>next 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；</li>
<li>thread 指向当前线程；</li>
<li>parent 指向父结点，第一个结点的 parent 值为 nil ；</li>
<li>child 指向子结点，最后一个结点的 child 值为 nil ；</li>
<li>depth 代表深度，从 0 开始，往后递增 1；</li>
<li>hiwat 代表 high water mark。</li>
</ol>
<h3 id="push操作"><a href="#push操作" class="headerlink" title="push操作"></a><em>push操作</em></h3><p><code>objc_autoreleasePoolPush()</code>函数实际上调用了<code>AutoreleasePoolPage::push()</code>函数。</p>
<pre><code>static inline void *push() 
{
    id *dest;
    dest = autoreleaseFast(POOL_BOUNDARY);
    return dest;
}
</code></pre><p>其中<code>POOL_BOUNDARY</code>是<code>nil</code>的宏定义</p>
<pre><code>#   define POOL_BOUNDARY nil`
</code></pre><p>在首次创建AutoRelease Pool的时候插入一个nil值表示嵌套的<code>AutoreleasePool</code>的边界。</p>
<p>push函数调又<code>autoreleaseFast</code>实现具体的插入：</p>
<pre><code>static inline id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    if (page &amp;&amp; !page-&gt;full()) {
        return page-&gt;add(obj);
    } else if (page) {
        return autoreleaseFullPage(obj, page);
    } else {
        return autoreleaseNoPage(obj);
    }
}
</code></pre><p>插入新元素的时候分三种情况需要处理：</p>
<ol>
<li>当前page未满，直接插入到当前page</li>
<li>当前page已满，创建一个新page并插入</li>
<li>当前page不存在，创建一个新page并插入</li>
</ol>
<p>这三种情况最终都会调用<code>page-&gt;add(obj)</code>：</p>
<pre><code>id *add(id obj)
{
    assert(!full());
    unprotect();
    id *ret = next;
    *next++ = obj;
    protect();
    return ret;
}
</code></pre><p>首先断言当前page非满(<code>next != end()</code>),然后解除当前页保护(因为要插入，要使当前页可读可写),更新<code>next</code>指针地址，返回插入的元素地址。第一次初始化<code>autoreleasepool</code>时,传的nil值，返回值是nil值所在的地址。</p>
<h3 id="Pop操作"><a href="#Pop操作" class="headerlink" title="Pop操作"></a><em>Pop操作</em></h3><p>同上，<code>objc_autoreleasePoolPop</code> 实际调用了<code>AutoreleasePoolPage::pop(ctxt)</code>,传入的参数是初始化是返回的<code>nil</code>值的地址:</p>
<pre><code>static inline void pop(void *token) 
{
    AutoreleasePoolPage *page;
    id *stop;

    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {
        if (hotPage()) {
            pop(coldPage()-&gt;begin());
        } else {
            setHotPage(nil);
        }
        return;
    }

    page = pageForPointer(token);
    stop = (id *)token;
    if (*stop != POOL_BOUNDARY) {
        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) {
        } else {
            return badPop(token);
        }
    }

    if (PrintPoolHiwat) printHiwat();

    page-&gt;releaseUntil(stop);

    // memory: delete empty children
      if (page-&gt;lessThanHalfFull()) {                page-&gt;child-&gt;kill();
    }
    else if (page-&gt;child-&gt;child) {
        page-&gt;child-&gt;child-&gt;kill();
   }
}
</code></pre><p><code>pop</code>的参数的含义是需要<code>pop</code>到参数元素所在的地址，Pop的时候首先判断是不是<code>EMPTY_POOL_PLACEHOLDER</code>, <code>EMPTY_POOL_PLACEHOLDER</code>的解释如下：</p>
<blockquote>
<p>EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is pushed and it has never contained any objects. This saves memory when the top level (i.e. libdispatch) pushes and pops pools but never uses them.</p>
</blockquote>
<p><code>EMPTY_POOL_PLACEHOLDER</code>是存储在TLS中的用来表示链表最上层没有元素的<code>pool</code>,这样就不用创建<code>pool</code>可以节约内存。TLS是什么以及具体实现<a href="http://blog.csdn.net/cywosp/article/details/26469435" target="_blank" rel="noopener">这篇文章</a>介绍的比较详细，这里不在解释。如果<code>pool</code>里面有数据，就把里面的数据清空；否者就把<code>hotPage</code>设置为<code>nil</code>。接着调用<code>page-&gt;releaseUntil(stop)</code>给此参数之前的所有对象发送<code>release</code>释放内存，对象内存释放之后，<code>终点page</code>之前的<code>page</code>都会变成空的，最后调用<code>page-&gt;child-&gt;kill()</code>回收这些<code>空page</code>资源。</p>
<p>假设某个线程的autoreleasepool的结构如下图所示，这个autoreleasepool的堆栈里有两个<code>POOL_SENTINEL</code>，说明代码里嵌套了两个autoreleasepool，在整个双向链表里，起始的第一个page为<code>coldPage</code>，最新的最后一个是<code>hotpage</code>。<code>hotPage</code>里保存了最新添加的对象:</p>
<p><img src="/assets/images/autorelease/AutoreleasePoolPage1.png" alt="img01"></p>
<p>此时，如果执行<code>pop(POOL_BOUNDARY)</code>操作，那么<code>autoreleasepool</code>的堆栈结构会变成下图：</p>
<p><img src="/assets/images/autorelease/AutoreleasePoolPage2.png" alt="img01"></p>
<p>所以处理嵌套的<code>autoreleasepool</code>就很简单了，因为<code>autoreleasepool</code>与<code>autoreleasepool</code>之间用特殊的标记分割了，每个<code>autoreleasepool</code>的释放只需要释放到指定位置(初始化时push的nil指针的地址)即可,内层与外层互相不影响。</p>
<h2 id="autorelease操作"><a href="#autorelease操作" class="headerlink" title="autorelease操作"></a><strong>autorelease操作</strong></h2><p>我们已经清楚了<code>autoreleasepool</code>的结构以及<code>autoreleasepool</code>对对象的管理方式，那么我们自己创建的对象是怎么和<code>autoreleasepool</code>关联的？在MRC中,<code>autorelease</code>的调用例如<code>[[[NSObject alloc]init] autorelease]</code>调用堆栈如下：</p>
<p><img src="/assets/images/autorelease/page3.jpeg" alt="img01"></p>
<p><code>autorelease</code>转发给了<code>rootAutorelease</code>调用:</p>
<pre><code>- (id)autorelease {
    return ((id)self)-&gt;rootAutorelease();
}

inline id 
objc_object::rootAutorelease()
{
    if (isTaggedPointer()) return (id)this;
    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;

    return rootAutorelease2();
}
</code></pre><p><code>rootAutorelease</code>首先判断是不是<code>Tagged Pointer</code>,是的话直接返回，因为<code>Tagged Pointer</code>是栈上的对象，不需要内存管理(文末有解释)。接着用<code>__builtin_return_address</code>判断外部是不是ARC环境。最终调用<code>autoreleaseFast</code>将对象插入到<code>autoreleasepool</code>中。</p>
<pre><code>static inline id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    if (page &amp;&amp; !page-&gt;full()) {
        return page-&gt;add(obj);
    } else if (page) {
        return autoreleaseFullPage(obj, page);
    } else {
        return autoreleaseNoPage(obj);
    }
}
</code></pre><p>可以看出，在MRC中，通过对象主动调用<code>autorelease</code>的方式将对象加入到<code>autoreleasepool</code>的管理。那么在ARC中是怎么处理的呢？</p>
<p>在ARC环境下，我们改写main函数如下：</p>
<pre><code>int main(int argc, const char * argv[]) {
@autoreleasepool {
    NSString *testObj = [[NSObject alloc]init];
    @autoreleasepool {
        NSObject *objTest2 = [[NSObject alloc]init];
        objTest2 = testObj;
    }
}
return 0;
}
</code></pre><p>然后使用<code>clang -S -fobjc-arc -emit-llvm main.m -o main.cc</code>生成IR中间代码，截取关键部分如下：</p>
<pre><code>define i32 @main(i32, i8**) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i8**, align 8
  %6 = alloca %0*, align 8
  %7 = alloca %1*, align 8
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
  %8 = call i8* @objc_autoreleasePoolPush() #2
  %9 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8
  %10 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !7
  %11 = bitcast %struct._class_t* %9 to i8*
  %12 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %11, i8* %10)
  %13 = bitcast i8* %12 to %1*
  %14 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !7
  %15 = bitcast %1* %13 to i8*
  %16 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %15, i8* %14)
  %17 = bitcast i8* %16 to %1*
  %18 = bitcast %1* %17 to %0*
  store %0* %18, %0** %6, align 8
  %19 = call i8* @objc_autoreleasePoolPush() #2
  %20 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8
  %21 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !7
  %22 = bitcast %struct._class_t* %20 to i8*
  %23 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %22, i8* %21)
  %24 = bitcast i8* %23 to %1*
  %25 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !7
  %26 = bitcast %1* %24 to i8*
  %27 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %26, i8* %25)
  %28 = bitcast i8* %27 to %1*
  store %1* %28, %1** %7, align 8
  %29 = load %0*, %0** %6, align 8
  %30 = bitcast %0* %29 to %1*
  %31 = bitcast %1** %7 to i8**
  %32 = bitcast %1* %30 to i8*
  call void @objc_storeStrong(i8** %31, i8* %32) #2
  %33 = bitcast %1** %7 to i8**
  call void @objc_storeStrong(i8** %33, i8* null) #2
  call void @objc_autoreleasePoolPop(i8* %19)
  %34 = bitcast %0** %6 to i8**
  call void @objc_storeStrong(i8** %34, i8* null) #2
  call void @objc_autoreleasePoolPop(i8* %8)
  ret i32 0
}
</code></pre><p>可以看出在ARC环境下，在<code>autoreleasePoolPop</code>之前会自动为我们生成<code>objc_storeStrong</code>,第一个参数是当前对象，第二个是赋值的对象(=右边的)。对象在外部被引用时，就retain:</p>
<p><img src="/assets/images/autorelease/page4.jpeg" alt="img01"></p>
<p>当对象没有被引用时，直接释放资源:</p>
<p><img src="/assets/images/autorelease/page5.jpeg" alt="img01"></p>
<p>这里比较奇怪的是对象并没有被加入到<code>autoreleasepool</code>中，应该是编译器对简单的情况作了优化，毕竟<code>autoreleasepool</code>的管理也是一个不小的开销。</p>
<h2 id="autoreleasepool使用场景"><a href="#autoreleasepool使用场景" class="headerlink" title="@autoreleasepool使用场景"></a><strong>@autoreleasepool使用场景</strong></h2><p>什么情况下我们需要显示使用<code>Autorelease Pool</code>？可以参考下苹果文档<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="noopener">这里</a>。</p>
<blockquote>
<p>Each thread in a Cocoa application maintains its own stack of autorelease pool blocks. If you are writing a Foundation-only program or if you detach a thread, you need to create your own autorelease pool block.</p>
</blockquote>
<blockquote>
<p>If your application or thread is long-lived and potentially generates a lot of autoreleased objects, you should use autorelease pool blocks (like AppKit and UIKit do on the main thread); otherwise, autoreleased objects accumulate and your memory footprint grows. If your detached thread does not make Cocoa calls, you do not need to use an autorelease pool block.</p>
</blockquote>
<p>需要程序员自己使用<code>@autoreleasepool</code></p>
<ol>
<li>If you are writing a program that is not based on a<br>UI framework, such as a command-line tool.</li>
<li><p>If you write a loop that creates many temporary objects.<br>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</p>
</li>
<li><p>If you spawn a secondary thread.<br>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.)</p>
</li>
</ol>
<p>大致意思就是大部分时候都不需要程序员关心，但是以下情况需要注意</p>
<ol>
<li>代码不是基于UI framework;比如基于命令行</li>
<li>创建大量的临时对象或者大对象需要立即释放的时候</li>
<li>创建了子线程时，子线程里应该使用<code>@autoreleasepool</code>；如从<code>NSThread</code>中<code>detach</code>出的线程用了<code>Cocoa calls</code><br>以上两种情况需要使用。</li>
</ol>
<p>以下是几种使用的例子：</p>
<pre><code>//情景1 SDWebImage源码
@autoreleasepool {
        UIImage *diskImage = [self diskImageForKey:key];
        //other code
    }

//情景2 (MBProgressHUD源码)
[NSThread detachNewThreadSelector:@selector(launchExecution) toTarget:self withObject:nil];

- (void)launchExecution {
    @autoreleasepool {
    //代码实现
    }
}

//情景3 (Realm源码)
RLMSchema *cachedRealmSchema;
@autoreleasepool {
    // ensure that cachedRealm doesn&apos;t end up in this thread&apos;s autorelease pool
    //确保cachedRealm在当前线程的autorelease pool没有被释放
    cachedRealmSchema = RLMGetAnyCachedRealmForPath(config.path).schema;
}

// if we have a cached realm on another thread, copy without a transaction
if (cachedRealmSchema) {
    RLMRealmSetSchemaAndAlign(realm, cachedRealmSchema);
}
else if (dynamic) {
    RLMRealmSetSchemaAndAlign(realm, [RLMSchema dynamicSchemaFromObjectStoreSchema:realm-&gt;_realm-&gt;schema()]
</code></pre><h2 id="自己实现一个autoreleasepool"><a href="#自己实现一个autoreleasepool" class="headerlink" title="自己实现一个autoreleasepool"></a>自己实现一个autoreleasepool</h2><p>根据以上原理，我们可以实现一个和系统功能差不多类似的<code>autoreleasepool</code>,源代码在GitHub<a href="https://github.com/tianyig/iOSAdvance.git" target="_blank" rel="noopener">autoreleasepool</a>.</p>
<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a><strong>相关知识点</strong></h2><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a><strong>Tagged Pointer</strong></h3><p>苹果对于Tagged Pointer特点的介绍：</p>
<ol>
<li>Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate</li>
<li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ol>
<p>为什么要用<code>Tagged Pointer</code>?因为数据类型的长度是和CPU长度有关的，这样就导致了在64位CPU上一些对象占用的内存会翻倍。同时维护程序中的对象需要 分配内存，维护引用计数，管理生命周期，使用对象给程序的运行增加了负担。我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。因为<code>Tagged pointer</code>不是一个真正的对象，如果使用isa指针在编译时会报错。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://draveness.me/autoreleasepool/" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></li>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="noopener">Objective-C Autorelease Pool 的实现原理</a></li>
<li></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/27/SDWebImage源码阅读-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/27/SDWebImage源码阅读-一/" class="post-title-link" itemprop="url">SDWebImage源码阅读笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-02-27 10:55:02" itemprop="dateCreated datePublished" datetime="2017-02-27T10:55:02+08:00">2017-02-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2017-03-02 13:28:25" itemprop="dateModified" datetime="2017-03-02T13:28:25+08:00">2017-03-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。</p>
<h2 id="SDWebImage结构"><a href="#SDWebImage结构" class="headerlink" title="SDWebImage结构"></a><strong>SDWebImage结构</strong></h2><p>首先我们看看SDWebImage的项目组织结构：</p>
<p><img src="/assets/images/SDWebImage/01.png" alt="img01"></p>
<blockquote>
<p>Downloader负责图片的异步下载；</p>
<p>Cache负责图片的缓存；</p>
<p>SDWebImageManager是总的管理类，维护了一个SDWebImageDownloader实例和一个SDImageCache实例，是下载与缓存的桥梁;SDWebImageDecoder负责图片的解压缩;SDWebImagePrefetcher负责图片的预取;</p>
<p>UIImageView+WebCache和其他的扩展负责给用户提供接口;</p>
</blockquote>
<p>其中，最重要的就是SDWebImageDownloader、SDImageCache、SDWebImageManager三个类，接下来我们就一步步详细分析一下这些类具体如何实现的。</p>
<p>为了便于大家从宏观上有个把握，我这里先给出项目的框架结构:</p>
<p><img src="/assets/images/SDWebImage/02.png" alt="img01"></p>
<p>从这个图我们明显可以看出来，UIImageView+WebCache和UIButton+WebCache负责为用户提供接口；SDWebImageManger负责协调Downloader和Cache，并且为UIKit层提供支持；最底层的两个类为高层抽象提供支持；我们将采用至顶向下分析的方法，一层层分析。</p>
<h2 id="接口层的实现"><a href="#接口层的实现" class="headerlink" title="接口层的实现"></a><strong>接口层的实现</strong></h2><h3 id="UIImageView-WebCache"><a href="#UIImageView-WebCache" class="headerlink" title="UIImageView+WebCache"></a><strong>UIImageView+WebCache</strong></h3><p>这里我们拿UIImageView+WebCache举例，UIButton+WebCache与此类似。UIImageView+WebCache提供的接口如下：</p>
<pre><code>- (void)setImageWithURL:(NSURL *)url;
- (void)setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;
- (void)setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options;
- (void)setImageWithURL:(NSURL *)url completed:(SDWebImageCompletedBlock)completedBlock;
- (void)setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder completed:(SDWebImageCompletedBlock)completedBlock;
- (void)setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options completed:(SDWebImageCompletedBlock)completedBlock;
</code></pre><p>这些接口都调用了</p>
<pre><code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock；
</code></pre><p>这是一种常用的封装的方法，一个函数提供最复杂的实现，其他函数给这个函数在此基础上通过调用的时候提供默认参数，浅浅的封装一层方便用户使用。因为OC函数不支持默认参数(C++支持)，所以需要在提供几个函数包装一下。</p>
<p>这个函数的上半部分实现如下：</p>
<pre><code>[self sd_cancelCurrentImageLoad];
objc_setAssociatedObject(self, &amp;imageURLKey, url,     OBJC_ASSOCIATION_RETAIN_NONATOMIC);

if (!(options &amp; SDWebImageDelayPlaceholder)) {
    dispatch_main_async_safe(^{
        self.image = placeholder;
    });
}
</code></pre><p>在加载一张图片的时候首先取消当前正在加载图片的操作，然后给当前的UIImageView关联一个对应图片的URL，关联的这个url库里本身没有用到，只是暴露出<code>- (NSURL *)sd_imageURL;</code>接口提供给用户使用；if里判断用户是否使用了<code>SDWebImageDelayPlaceholder</code>，如果没有使用就设置<code>placeholder</code>,默认情况没有设置选项，图片在加载完成之前会显示占位图，如果设置了这个选项，会在图片加载完成之后在显示占位图，关于其它选项的具体含义，可以看叶孤城的解析<a href="http://www.jianshu.com/p/6ae6f99b6c4c" title="链接" target="_blank" rel="noopener">这里</a>。<code>dispatch_main_async_safe</code>是SDWebImage封装的一个保证参数block在主线程执行的宏，宏的实现比较简单，这里不在解释。</p>
<p>我们具体分析一下取消操作是如何实现的，<code>[self sd_cancelCurrentImageLoad]</code>调用了父类<code>UIView+EMWebCacheOperation</code>的函数：</p>
<pre><code>[self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;];
</code></pre><p>我们可以看到，这里的key是写死的，因为一个UIImageView在任何时候至多只能对应一种类型的下载操作(可以同时下载image和highlightedImage，两者的key是不一样的)。网络下载以及缓存都是比较耗费系统资源的操作，这么做可以尽量避免资源浪费。例如UITableView在滑动到需要复用UITableViewCell时，如果此时滑出屏幕之前的图片还未加载完成，就没必要在下载了。我们继续深入看父类<code>UIView+EMWebCacheOperation</code>的实现，<code>sd_cancelImageLoadOperationWithKey</code>的全部实现如下：</p>
<pre><code>//这里通过给Category关联属性的方式给每个UIView添加了一个NSMutableDictionary属性，保存了operation或者operation数组;operation从下面可以看出是id &lt;EMSDWebImageOperation&gt;类型,之所以用这样的类型是为了通用性，不局限于使用系统的NSOperation，用户也可以自定义自己的Operation(如SDWebImage里的用到的SDWebImageCombinedOperation)。
NSMutableDictionary *operationDictionary = [self operationDictionary];
    id operations = [operationDictionary objectForKey:key];
    if (operations) {
    //gif图有多张图片，多张图片对应多个operation
        if ([operations isKindOfClass:[NSArray class]]) {
            for (id &lt;SDWebImageOperation&gt; operation in operations) {
                if (operation) {
                    [operation cancel];
                }
            }
        } else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)]){
            //单个图片，直接调用cancle
            [(id&lt;SDWebImageOperation&gt;) operations cancel];
        }
        [operationDictionary removeObjectForKey:key];
    }
</code></pre><p>然后我们接着看sd_setImageWithURL的下半部分的实现，截取部分关键的代码：</p>
<pre><code>__weak __typeof(self)wself = self;
//创建一个id &lt;SDWebImageOperation&gt;(于UIView+EMWebCacheOperation对应)类型的下载task,
id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
          [wself removeActivityIndicator];
        if (!wself) return;
        dispatch_main_sync_safe(^{
            if (!wself) return;
            //如果用户不希望下载完成直接设置image，就只调用completedBlock
            if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
            {
                completedBlock(image, error, cacheType, url);
                return;
            }
            else if (image) {
                wself.image = image;
                [wself setNeedsLayout];
            } else {
                //下载完成设置placeholder
                if ((options &amp; SDWebImageDelayPlaceholder)) {
                    wself.image = placeholder;
                    [wself setNeedsLayout];
                }
            }
            if (completedBlock &amp;&amp; finished) {
                completedBlock(image, error, cacheType, url);
            }
        });
    }];
//将这个Operation添加到此UIImageView的字典里
[self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];
</code></pre><p>接口层的实现到这里就结束了。这里有几个小问题:</p>
<ul>
<li><strong><font color="red">iOS底层如何实现Category关联属性的？</font></strong></li>
<li><strong><font color="red">iOS的Category如何关联weak属性？</font></strong></li>
</ul>
<h2 id="调度层的实现"><a href="#调度层的实现" class="headerlink" title="调度层的实现"></a>调度层的实现</h2><p> 调度层就一个类SDWebImageManager，在头文件中描述如下：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes.<br> It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache).<br> You can use this class directly to benefit from web image downloading with caching in another context than<br> a UIView.</p>
</blockquote>
<p>意思就是SDWebImageManager是位于UIImageView+WebCache之下的用于图片异步下载和缓存的类，你也可以直接使用SDWebImageManager的函数直接下载图片。</p>
<p>SDWebImageManager是一个用dispatch_once实现的单例(关于<font color="red"><strong>dispatch_once底层如何实现的？</strong></font>也是一个有趣的话题，我们以后在讨论它),维护了一个SDImageCache实例和SDWebImageDownloader实例。提供的函数如下：</p>
<p>//初始化SDWebImageManager单例，在init方法中已经初始化了cache单例和downloader单例。</p>
<pre><code>- (instancetype)initWithCache:(SDImageCache *)cache downloader:(SDWebImageDownloader *)downloader;
//下载图片
- (id )downloadImageWithURL:(NSURL *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;
//缓存给定URL的图片
- (void)saveImageToCache:(UIImage *)image forURL:(NSURL *)url;
//取消当前所有的操作
- (void)cancelAll;
//监测当前是否有进行中的操作
- (BOOL)isRunning;
//监测图片是否在缓存中， 先在memory cache里面找  再到disk cache里面找
- (BOOL)cachedImageExistsForURL:(NSURL *)url;
//监测图片是否缓存在disk里
- (BOOL)diskImageExistsForURL:(NSURL *)url;
//监测图片是否在缓存中,监测结束后调用completionBlock
- (void)cachedImageExistsForURL:(NSURL *)url
                     completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
//监测图片是否缓存在disk里,监测结束后调用completionBlock
- (void)diskImageExistsForURL:(NSURL *)url
                   completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
//返回给定URL的cache key，默认是图片的url
- (NSString *)cacheKeyForURL:(NSURL *)url;
</code></pre><p>定义了SDWebImageManagerDelegate协议：</p>
<pre><code>@protocol SDWebImageManagerDelegate 

@optional

/**
 * Controls which image should be downloaded when the image is not found in the cache.
 *
 * @param imageManager The current `SDWebImageManager`
 * @param imageURL     The url of the image to be downloaded
 *
 * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.
 * 控制在cache中没有找到image时 是否应该去下载。默认是YES。
 */
- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;

/**
 * Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.
 * NOTE: This method is called from a global queue in order to not to block the main thread.
 *
 * @param imageManager The current `SDWebImageManager`
 * @param image        The image to transform
 * @param imageURL     The url of the image to transform
 *
 * @return The transformed image object.
 * 在下载之后，缓存之前转换图片。在全局队列中操作，不阻塞主线程
 */
- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;

@end
</code></pre><p> 我们主要看下</p>
<pre><code>- (id )downloadImageWithURL:(NSURL *)url
                                        options:(SDWebImageOptions)options
                                       progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                      completed:(SDWebImageCompletionWithFinishedBlock)completedBlock
</code></pre><p>这个函数返回<code>id &lt;SDWebImageOperation&gt;</code>类型保存当前UIImageView的下载操作；</p>
<p>首先检查URL是否合法：</p>
<pre><code>if ([url isKindOfClass:NSString.class]) {
    url = [NSURL URLWithString:(NSString *)url];
}

// Prevents app crashing on argument type error like sending NSNull instead of NSURL
if (![url isKindOfClass:NSURL.class]) {
    url = nil;
}
</code></pre><p>这两个判断都是检查用户传递参数类型是否正确；</p>
<pre><code>BOOL isFailedUrl = NO;
@synchronized (self.failedURLs) {
    isFailedUrl = [self.failedURLs containsObject:url];
}

if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
    dispatch_main_sync_safe(^{
        NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        completedBlock(nil, error, SDImageCacheTypeNone, YES, url);
    });
    return operation;
}
</code></pre><p>若URL对应的image之前下载失败过并且用户没有设置错误重试，直接调用completedBlock；</p>
<pre><code>@synchronized (self.runningOperations) {
    [self.runningOperations addObject:operation];
}
</code></pre><p>把当前下载操作加入到runningOperations中，因为runningOperations是多线程共享的，所以要加synchronized控制并发；<strong>synchronized底层是如何实现的呢？</strong>我们在以后的文章里去探究。</p>
<p>SDWebImageManager首先去检查cache(memeory &amp;&amp; disk)中是否缓存过要下载的图片，调用imageCache的</p>
<pre><code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock
</code></pre><p>函数里首先判断当前操作是否被取消，如果取消从runningOperations中移除，并直接返回：</p>
<pre><code>if (operation.isCancelled) {
    @synchronized (self.runningOperations) {
        [self.runningOperations removeObject:operation];
    }

    return;
}
</code></pre><p>接下来需要讨论二种情况情况：1.（缓存未找到图片）或（缓存找到了图片但是用户设置了刷新缓存） 2. （用户没有实现shouldDownloadImageForURL协议）或（用户实现了shouldDownloadImageForURL协议并且返回值是YES）</p>
<pre><code>if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]))
</code></pre><p>这两种情况下需要下载图片，上面这一坨就是判断上面的二种情况。</p>
<p>除了上面二种情况还有不需要下载图片的二种情况：1.缓存找到图片 2.缓存未找到图片并且用户禁止下载：</p>
<pre><code>//第一种情况，缓存找到图片(用户未设置刷新缓存并且用户未禁止下载)
else if (image) {
    dispatch_main_sync_safe(^{
        __strong __typeof(weakOperation) strongOperation = weakOperation;
        if (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(image, nil, cacheType, YES, url);
        }
    });
    @synchronized (self.runningOperations) {
        [self.runningOperations removeObject:operation];
    }
}
//第二种情况(缓存未找到且用户通过delegate设置在缓存未找到时禁止下载图片)
else {
    // Image not in cache and download disallowed by delegate
    dispatch_main_sync_safe(^{
        __strong __typeof(weakOperation) strongOperation = weakOperation;
        if (strongOperation &amp;&amp; !weakOperation.isCancelled) {
            completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);
        }
    });
    @synchronized (self.runningOperations) {
        [self.runningOperations removeObject:operation];
    }
}
</code></pre><p>如果需要下载图片，就调用</p>
<pre><code>- (id )downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock
</code></pre><p>下载图片，如果下载失败。直接调用completedBlock返回错误，并根据错误类型将URL添加到failedURLs里。</p>
<pre><code>else if (error) {
    dispatch_main_sync_safe(^{
        if (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);
        }
    });

    if (   error.code != NSURLErrorNotConnectedToInternet
        &amp;&amp; error.code != NSURLErrorCancelled
        &amp;&amp; error.code != NSURLErrorTimedOut
        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff
        &amp;&amp; error.code != NSURLErrorDataNotAllowed
        &amp;&amp; error.code != NSURLErrorCannotFindHost
        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) {
        @synchronized (self.failedURLs) {
            [self.failedURLs addObject:url];
        }
    }
}
</code></pre><p>若图片下载成功，将url从failURLs里删除：</p>
<pre><code>if ((options &amp; SDWebImageRetryFailed)) {
    @synchronized (self.failedURLs) {
        [self.failedURLs removeObject:url];
    }
}
</code></pre><p>这个地方需要解释下，因为<code>[self.failedURLs addObject:url]</code>是<strong>只在下载失败时添加</strong>的，而下载成功和下载失败是互斥的，也就是说，下载成功时failedURLs数组里就不应该有这个url，为什么要这么写呢，这是为了解决竞态条件下的问题，若两个线程下载同一个url的图片，若第一个线程下载失败，第二个下载成功。如果不从failedURLs移除这个url的话，以后下载此url的图片都会失败。</p>
<p>然后处理下载完成的图片：</p>
<pre><code>//是否设置了只缓存内存
BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

//设置刷新缓存且cache找到图片且NSURLCache找到图片，不处理
if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) {
    // Image refresh hit the NSURLCache cache, do not call the completion block
}
//若delegate实现imageManager:transformDownloadedImage:withURL:方法，在缓存之前，需要做调用此delegate方法转换
else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) {
    //在全局队列中转换，不阻塞主线程dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];
        //转换成功后，存入缓存
        if (transformedImage &amp;&amp; finished) {
            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];
            [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];
        }
        //缓存成功之后，调用completedBlock
        dispatch_main_sync_safe(^{
            if (strongOperation &amp;&amp; !strongOperation.isCancelled) {
                completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);
            }
        });
    });
}
else {
    //没有实现转换的delegate，就不做转换直接缓存
    if (downloadedImage &amp;&amp; finished) {
        [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];
    }
    //缓存成功之后，调用completedBlock
    dispatch_main_sync_safe(^{
        if (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);
        }
    });
}
</code></pre><p>}</p>
<p>下载完成之后，从队列里移除：</p>
<pre><code>if (finished) {
    @synchronized (self.runningOperations) {
        if (strongOperation) {
            [self.runningOperations removeObject:strongOperation];
        }
    }
}
</code></pre><p>最后说下返回的<code>SDWebImageCombinedOperation</code>类型，这个类型包含<code>NSOperation *cacheOperation</code>的一个子类型，其中<code>cacheOperation</code>中又存在<code>id &lt;SDWebImageOperation&gt;</code>的下载图片的<code>subOperation</code>。在<code>cancel</code>的时候也应该把这两个操作都<code>cancle</code>。</p>
<pre><code>- (void)cancel {
    self.cancelled = YES;
    if (self.cacheOperation) {
        [self.cacheOperation cancel];
        self.cacheOperation = nil;
    }
    if (self.cancelBlock) {
        self.cancelBlock();

        // TODO: this is a temporary fix to #809.
        // Until we can figure the exact cause of the crash, going with the ivar instead of the setter
//        self.cancelBlock = nil;
        _cancelBlock = nil;
    }
}
</code></pre><p>所以<code>CombinedOperation</code>在<code>cancel</code>的时候会先cancel掉自己的<code>cacheOperation</code>,在调用自己的<code>cancelBlock</code>。</p>
<pre><code>operation.cancelBlock = ^{
    [subOperation cancel];


    @synchronized (self.runningOperations) {
        __strong __typeof(weakOperation) strongOperation = weakOperation;
        if (strongOperation) {
            [self.runningOperations removeObject:strongOperation];
        }
    }
};
</code></pre><p>在自己的<code>cancelBlock</code>把下载操作<code>subOperation</code>取消掉。由此可见封装的<code>CombinedOperation</code>包含了下载和缓存的操作，使代码变得更简洁。</p>
<h2 id="下载和缓存层"><a href="#下载和缓存层" class="headerlink" title="下载和缓存层"></a><strong>下载和缓存层</strong></h2><h3 id="下载层SDWebImageDownloader"><a href="#下载层SDWebImageDownloader" class="headerlink" title="下载层SDWebImageDownloader"></a><strong>下载层SDWebImageDownloader</strong></h3><p>SDWebImageDownloader提供的方法有以下几个：</p>
<pre><code>//给每个HTTP下载请求头的指定field设置值。
- (void)setValue:(NSString *)value forHTTPHeaderField:(NSString *)field;
//返回HTTP特定field的值
- (NSString *)valueForHTTPHeaderField:(NSString *)field;
//设置一个SDWebImageDownloaderOperation的子类作为下载请求的默认NSOperation
- (void)setOperationClass:(Class)operationClass;
//创建一个SDWebImageDownloader异步下载实例，图片下载完成或错误时，通知delegate回调。方法返回一个 SDWebImageOperation
- (id )downloadImageWithURL:(NSURL *)url
                                     options:(SDWebImageDownloaderOptions)options
                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
// 设置下载队列为挂起状态
- (void)setSuspended:(BOOL)suspended;
//取消队列中的所有操作。
- (void)cancelAllDownloads;
</code></pre><p>我们重点研究下载方法：</p>
<pre><code>- (id )downloadImageWithURL:(NSURL *)url
                                     options:(SDWebImageDownloaderOptions)options
                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
</code></pre><p>这几个参数的含义代码注释里都有，这里就不再一一解释。</p>
<pre><code>__block SDWebImageDownloaderOperation *operation;
__weak __typeof(self)wself = self;

[self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
    //block实现
    ...
    operation = [[wself.operationClass alloc] initWithRequest:request
                                                      options:options
                                                     progress:^(NSInteger receivedSize, NSInteger expectedSize)
    ...
}];

return operation;
</code></pre><p>上面是这个方法的框架，可以看出主要调用了<code>addProgressCallback</code>方法，方法的内部创建了下载的<code>operation</code>。我们首先看看<code>addProgressCallback</code>方法的实现:</p>
<pre><code>//如果url为nil，调用completedBlock后return
if (url == nil) {
    if (completedBlock != nil) {
        completedBlock(nil, nil, nil, NO);
    }
    return;
}

//允许多线程下载，使用了并发控制，避免同时修改URLCallbacks
dispatch_barrier_sync(self.barrierQueue, ^{
    BOOL first = NO;
    if (!self.URLCallbacks[url]) {
        self.URLCallbacks[url] = [NSMutableArray new];
        first = YES;
    }

    // Handle single download of simultaneous download request for the same URL
    NSMutableArray *callbacksForURL = self.URLCallbacks[url];
    NSMutableDictionary *callbacks = [NSMutableDictionary new];
    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
    [callbacksForURL addObject:callbacks];
    self.URLCallbacks[url] = callbacksForURL;

    if (first) {
        createCallback();
    }
});
</code></pre><p>这里的并发控制的地方为什么要使用<code>dispatch_barrier_sync</code>，是因为<code>dispatch_barrier_sync</code>这个函数可以设置一个同步执行block，它会等到在这个block加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。。这里的<code>dispatch_barrier_sync</code>实际上相当于一个写锁，任何写操作(删除，添加)，都要在之前的写操作完成后执行，而之后的写操作，也要在之前的的写操作完成之后执行。</p>
<p>URLCallbacks是一个以url作为key的字典，字典的value是一个数组，数组的元素是一个字典。可以看出<code>URLCallbacks</code>、<code>callbacksForURL</code>、<code>callbacks</code>之间的关系如下图：</p>
<p><img src="/assets/images/SDWebImage/03.png" alt="img01"></p>
<p>如果URLCallbacks以url对应的value是空，说明是第一次请求这个url，需要调用<code>createCallback</code>创建下载任务，即调用：</p>
<pre><code>- (id)initWithRequest:(NSURLRequest *)request
        inSession:(NSURLSession *)session
          options:(SDWebImageDownloaderOptions)options
         progress:(SDWebImageDownloaderProgressBlock)progressBlock
        completed:(SDWebImageDownloaderCompletedBlock)completedBlock
        cancelled:(SDWebImageNoParamsBlock)cancelBlock
</code></pre><p>设置默认超时时间15s，然后使用此<code>request</code>创建一个<code>SDWebImageDownloaderOperation</code>,方便把这个下载任务添加到下载队列里：</p>
<pre><code>- (id)initWithRequest:(NSURLRequest *)request
          options:(SDWebImageDownloaderOptions)options
         progress:(SDWebImageDownloaderProgressBlock)progressBlock
        completed:(SDWebImageDownloaderCompletedBlock)completedBlock
        cancelled:(SDWebImageNoParamsBlock)cancelBlock
</code></pre><p>重点看下这个方法的三个block，第一个progress，取出存储在URLCallbacks中的progressBlock并调用：</p>
<pre><code>//只是读操作，dispatch_sync即可
 dispatch_sync(sself.barrierQueue, ^{
     callbacksForURL = [sself.URLCallbacks[url] copy];
 });
 for (NSDictionary *callbacks in callbacksForURL) {
     dispatch_async(dispatch_get_main_queue(), ^{
         SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
         if (callback) callback(receivedSize, expectedSize);
     });
 }
</code></pre><p>同理，<code>completed</code>也是从URLCallbacks中的completedBlock并调用：</p>
<pre><code>//这里有写操作，须用dispatch_barrier_sync
dispatch_barrier_sync(sself.barrierQueue, ^{
    callbacksForURL = [sself.URLCallbacks[url] copy];
    if (finished) {
        [sself.URLCallbacks removeObjectForKey:url];
    }
});
for (NSDictionary *callbacks in callbacksForURL) {
    //这里为什么不像progressBlock一样使用dispatch_async(dispatch_get_main_queue()？
    SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];
    if (callback) callback(image, data, error, finished);
}
</code></pre><p>不同图片的下载任务会异步完成，所以要等待其他图片下载完成，并执行完<code>completedBlock</code>中对<code>URLCallbacks</code>的操作，才能继续之后的操作。</p>
<pre><code>cancelled:^{
    SDWebImageDownloader *sself = wself;
    if (!sself) return;
    dispatch_barrier_async(sself.barrierQueue, ^{
        [sself.URLCallbacks removeObjectForKey:url];
    });
}
</code></pre><p>取消时用的<code>dispatch_barrier_async</code>,dispatch_barrier_async表示的是先等之前的执行完成，然后把该barrier放入queue中，而不等待barrier中代码执行结束，而dispat_barrier_sync表示需要等待barrier中代码执行结束。</p>
<p>然后设置operation</p>
<pre><code>//是否解压下载的图片
operation.shouldDecompressImages = wself.shouldDecompressImages;
//有证书设置证书
if (wself.urlCredential) {
    operation.credential = wself.urlCredential;
} else if (wself.username &amp;&amp; wself.password) {
    operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];
}
//设置优先级
if (options &amp; SDWebImageDownloaderHighPriority) {
    operation.queuePriority = NSOperationQueuePriorityHigh;
} else if (options &amp; SDWebImageDownloaderLowPriority) {
    operation.queuePriority = NSOperationQueuePriorityLow;
}

[wself.downloadQueue addOperation:operation];
if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
    // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency
    [wself.lastAddedOperation addDependency:operation];
    wself.lastAddedOperation = operation;
}
</code></pre><p>最后将这个下载的操作加入到下载队列里。下载方式有两种，FIFO和LIFO。最后根据下载的方式调增任务的依赖。</p>
<h4 id="具体的下载操作SDWebImageDownloaderOperation"><a href="#具体的下载操作SDWebImageDownloaderOperation" class="headerlink" title="具体的下载操作SDWebImageDownloaderOperation"></a><strong>具体的下载操作SDWebImageDownloaderOperation</strong></h4><p>上面的<code>SDWebImageDownloader</code>主要操作就是创建<code>SDWebImageDownloaderOperation</code>添加到下载队列里，可知具体的操作是在<code>SDWebImageDownloaderOperation</code>，我们研究下具体是如何下载的。首先这个类是继承于<code>NSOperation</code>，并重写了<code>start</code>方法。我们首先看看它的<code>start</code>方法的实现：</p>
<p>检测下载状态</p>
<pre><code>//管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES
if (self.isCancelled) {
    self.finished = YES;
    [self reset];
    return;
}
</code></pre><p>如果是iOS4.0以上的版本，需要设置后台执行的操作：</p>
<pre><code>//作为具体的下载操作，尽量不依赖其他类，所以这里使用字符串创建
Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);
BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];
//如果用户设置了后台下载
if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) {
    //如果设置了在后台执行，则进行后台执行
     __weak __typeof__ (self) wself = self;
    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];
    //向系统申请更长的时间执行下载操作
    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^{
        // 如果在系统规定时间内任务还没有完成（一般是10分钟），结束后台任务
        __strong __typeof (wself) sself = wself;
        if (sself) {
            [sself cancel];
            [app endBackgroundTask:sself.backgroundTaskId];
            sself.backgroundTaskId = UIBackgroundTaskInvalid;
        }
    }];
｝
</code></pre><p>这里注册的block会在APP进入后台时执行，block里调用<code>cancel</code>对应的<code>endBackgroundTask</code>,这个block的主要目的是持有<code>self</code>不要被系统销毁，只要<code>self</code>不被系统销毁，当前下载操作就可以继续执行。<code>self</code>被销毁后，我们看看<code>cancel</code>操作做了什么：</p>
<pre><code>- (void)cancel {
    @synchronized (self) {
        if (self.thread) {
            [self performSelector:@selector(cancelInternalAndStop) onThread:self.thread withObject:nil waitUntilDone:NO];
        }
        else {
            [self cancelInternal];
        }
    }
}

- (void)cancelInternalAndStop {
    if (self.isFinished) return;
    [self cancelInternal];
    CFRunLoopStop(CFRunLoopGetCurrent());
}

- (void)cancelInternal {
    if (self.isFinished) return;
    [super cancel];
    if (self.cancelBlock) self.cancelBlock();

    if (self.connection) {
        [self.connection cancel];
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self];
        });

        // As we cancelled the connection, its callback won&apos;t be called and thus won&apos;t
        // maintain the isFinished and isExecuting flags.
        if (self.isExecuting) self.executing = NO;
        if (!self.isFinished) self.finished = YES;
    }

    [self reset];
}
</code></pre><p>底下有三个和<code>cancel</code>相关的操作，如果当前线程存在，在当前线程调用<code>cancelInternalAndStop</code>，否者调用<code>cancelInternal</code>;这两者的区别是<code>cancelInternalAndStop</code>中多了一句<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>,在中止当前线程的时候，也要关闭对应的RunLoop。<code>cancelInternal</code>做了几件事：</p>
<ul>
<li>调用自定义的cancelBlock</li>
<li>调用NSURLConnection的cancel取消self.connection</li>
<li>回收资源</li>
<li>抛出通知</li>
</ul>
<p>注册的后台操作是在进入到后台如果<code>NSOperation</code>未执行完成才执行的，假如在进入到后台之前<code>NSOperation</code>已经完成了呢？</p>
<pre><code>if (self.backgroundTaskId != UIBackgroundTaskInvalid) {
    UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];
    [app endBackgroundTask:self.backgroundTaskId];
    self.backgroundTaskId = UIBackgroundTaskInvalid;
}
</code></pre><p>如果下载任务完成，中止后台操作，将backgroundTaskId置为UIBackgroundTaskInvalid。</p>
<p>注册后台操作的准备工作完成之后，就该开始下载了：</p>
<pre><code>self.executing = YES;
self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];
self.thread = [NSThread currentThread];
</code></pre><p>初始化相关的数据，创建<code>NSURLConnection</code>,如果创建失败就调用<code>completedBlock</code>,成功就启动下载，关键代码如下：</p>
<pre><code>if (self.progressBlock) {
    self.progressBlock(0, NSURLResponseUnknownLength);
}
....
CFRunLoopRun();
....
if (!self.isFinished) {
    [self.connection cancel];
    [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@{NSURLErrorFailingURLErrorKey : self.request.URL}]];
}
</code></pre><p>使用<code>NSURLConnection</code>调用了<code>[self.connection start]</code>后，<code>NSURLConnection</code>的delegate就会不停收到事件回调。当这个connection完成或者终止，才会跳出CFRunLoopRun()(可以理解为CFRunLoopRun阻塞了当前线程)。当跳出Runloop后，就要判断NSURLConnection是不是正常完成任务了。如果没有，也就是说self.isFinished == NO。那么就取消该connection，并且调用</p>
<pre><code>(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;
</code></pre><p>返回错误信息。然后就是<code>NSURLConnection</code>几个delegate过程的处理：</p>
<pre><code>//如果是304代表服务端资源未改变，可直接使用客户端未过期的资源，此时需要取消operation并返回缓存中的image，code小于400说明请求成功
//如果响应成功，开始初始化数组，准备接收imageData
if (![response respondsToSelector:@selector(statusCode)] || ([((NSHTTPURLResponse *)response) statusCode] &lt; 400 &amp;&amp; [((NSHTTPURLResponse *)response) statusCode] != 304)) {
    NSInteger expected = response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0;
    self.expectedSize = expected;
    if (self.progressBlock) {
        self.progressBlock(0, expected);
    }

    self.imageData = [[NSMutableData alloc] initWithCapacity:expected];
    self.response = response;
    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:self];
    });
}
//请求失败之后，抛通知并清理相关资源
else {
    NSUInteger code = [((NSHTTPURLResponse *)response) statusCode];

    //This is the case when server returns &apos;304 Not Modified&apos;. It means that remote image is not changed.
    //In case of 304 we need just cancel the operation and return cached image from the cache.
    if (code == 304) {
        [self cancelInternal];
    } else {
        [self.connection cancel];
    }
    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self];
    });

    if (self.completedBlock) {
        self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:[((NSHTTPURLResponse *)response) statusCode] userInfo:nil], YES);
    }
    CFRunLoopStop(CFRunLoopGetCurrent());
    [self done];
}
</code></pre><p>然后在下载过程中接收数据，以下是部分代码：</p>
<pre><code>if (partialImageRef) {
    //把data转换成image
    UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];
    NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];
    UIImage *scaledImage = [self scaledImageForKey:key image:image];
    //判断是否要解解码，默认是需要解码，解码的操作是在子线程里(delegate在子线程执行的),为什么要解码？我们之后解释
    if (self.shouldDecompressImages) {
        image = [UIImage decodedImageWithImage:scaledImage];
    }
    else {
        image = scaledImage;
    }
    CGImageRelease(partialImageRef);
    dispatch_main_sync_safe(^{
        if (self.completedBlock) {
        //显示在imageView上（不一定下载完，可以显示一部分）
            self.completedBlock(image, nil, nil, NO);
        }
    });
}
</code></pre><blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<h3 id="缓存层SDImageCache"><a href="#缓存层SDImageCache" class="headerlink" title="缓存层SDImageCache"></a>缓存层SDImageCache</h3><p>我们看下<code>SDWebImage</code>的缓存<code>SDImageCache</code>，<code>SDImageCache</code>主要包含两部分，内存缓存<code>memCache</code>和磁盘缓存<code>fileManager</code>,磁盘缓存的写操作是异步的。</p>
<blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI. </p>
</blockquote>
<p>内存缓存是使用<code>NSCache</code>实现的，<code>NSCache</code>使用上类似字典，可以用key-Value的方式存取数据。但是NSCache底层实现和<code>NSDictionary</code>不同(NSCache是线程安全的)。<code>NSCache</code>的具体介绍可以看<a href="http://nshipster.cn/nscache/" target="_blank" rel="noopener">NSCache</a>。</p>
<p>先看看<code>SDImageCache</code>的属性：</p>
<pre><code>//是否解压下载的图片，默认是YES,但是会消耗掉很多内存，如果遇到内存不足的crash时，将值设为NO
@property (assign, nonatomic) BOOL shouldDecompressImages;
//是否自动上传iCloud
@property (assign, nonatomic) BOOL shouldDisableiCloud;
//使用内存缓存
@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;
//内存缓存的代价（占用的内存大小）
@property (assign, nonatomic) NSUInteger maxMemoryCost;
//内存缓存的最大元素个数
@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;
//元素在缓存中最大寿命
@property (assign, nonatomic) NSInteger maxCacheAge;
//最大缓存大小
@property (assign, nonatomic) NSUInteger maxCacheSize;
</code></pre><p>前面<code>SDWebImageManager</code>在下载图片成功时，会调用</p>
<pre><code>[self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk]
</code></pre><p>缓存到内存和磁盘，我们重点看下这个函数的实现:</p>
<pre><code>//错误处理
if (!image || !key) {
    return;
}
//需要内存缓存，计算内存占用，直接缓存
if (self.shouldCacheImagesInMemory) {
    NSUInteger cost = SDCacheCostForImage(image);
    [self.memCache setObject:image forKey:key cost:cost];
}

//需要磁盘异步缓存
if (toDisk) {
    dispatch_async(self.ioQueue, ^{
        NSData *data = imageData;

        if (image &amp;&amp; (recalculate || !data)) {
#if TARGET_OS_IPHONE
            //确定图片是png还是jpeg. imageData为nil而且有alapha通道，当作png处理
            int alphaInfo = CGImageGetAlphaInfo(image.CGImage);
            BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||
                              alphaInfo == kCGImageAlphaNoneSkipFirst ||
                              alphaInfo == kCGImageAlphaNoneSkipLast);
            BOOL imageIsPng = hasAlpha;

            // But if we have an image data, we will look at the preffix
            if ([imageData length] &gt;= [kPNGSignatureData length]) {
                imageIsPng = ImageDataHasPNGPreffix(imageData);
            }
            //根据类型返回image的data
            if (imageIsPng) {
                data = UIImagePNGRepresentation(image);
            }
            else {
                data = UIImageJPEGRepresentation(image, (CGFloat)1.0);
            }
#else
            data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];
#endif
        }
        //磁盘存储
        if (data) {
            if (![_fileManager fileExistsAtPath:_diskCachePath]) {
                [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];
            }

            // 获取缓存路径
            NSString *cachePathForKey = [self defaultCachePathForKey:key];
            // transform to NSUrl
            NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];
            //存储到disk里
            [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];

            // disable iCloud backup
            if (self.shouldDisableiCloud) {
                [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];
            }
        }
    });
}
</code></pre><p>同样的。<code>SDWebImageManager</code>在下载之前会检查缓存是否有此图片：</p>
<pre><code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock
</code></pre><p>关键代码如下：</p>
<pre><code>//从内存缓存里查找
UIImage *image = [self imageFromMemoryCacheForKey:key];
if (image) {
    doneBlock(image, SDImageCacheTypeMemory);
    return nil;
}

//NSOperation的特殊用法，用于取消一个异步操作
NSOperation *operation = [NSOperation new];
dispatch_async(self.ioQueue, ^{
    if (operation.isCancelled) {
        return;
    }

    //disk查找图片成功之后需要解码，所以放在`autoreleasepool`里
    @autoreleasepool {
        //从磁盘查找，解码
        UIImage *diskImage = [self diskImageForKey:key];
        if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) {
            NSUInteger cost = SDCacheCostForImage(diskImage);
            [self.memCache setObject:diskImage forKey:key cost:cost];
        }
        //查找完成
        dispatch_async(dispatch_get_main_queue(), ^{
            doneBlock(diskImage, SDImageCacheTypeDisk);
        });
    }
});
</code></pre><p>最后还有一个Cache清除的方式，对于memory cache来说是完全清空的，对于disk cache，根据设置参数的不同，有两种清除方式：</p>
<ul>
<li>文件的缓存有效期：默认是一周。如果文件的缓存时间超过这个时间值，则将其移除。</li>
<li>最大缓存空间大小：如果所有缓存文件的总大小超过最大缓存空间，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
</ul>
<h2 id="底层支持-工具类"><a href="#底层支持-工具类" class="headerlink" title="底层支持(工具类)"></a>底层支持(工具类)</h2><h3 id="SDWebImageDecoder和SDWebImageCompat"><a href="#SDWebImageDecoder和SDWebImageCompat" class="headerlink" title="SDWebImageDecoder和SDWebImageCompat"></a>SDWebImageDecoder和SDWebImageCompat</h3><p><code>SDWebImageDecoder</code>是用来图片解码的，在上面下载的时候和磁盘读取图片数据时，都调用了解码操作，图片为什么需要解码，可以参考如下解释:</p>
<blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<p><code>SDWebImageCompat</code>是根据屏幕大小设置图片的<code>scale</code>，实现比较简单，这里不再解释。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/13/大并发服务器/四、epoll函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/12/13/大并发服务器/四、epoll函数/" class="post-title-link" itemprop="url">四、epoll函数</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-12-13 21:41:43" itemprop="dateCreated datePublished" datetime="2016-12-13T21:41:43+08:00">2016-12-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2016-12-19 09:53:06" itemprop="dateModified" datetime="2016-12-19T09:53:06+08:00">2016-12-19</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><pre><code>#include &lt;sys/epoll.h&gt;
int epoll_create(int size);
int epoll_create1(int flags);

int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event);
int epoll_wait(int epld,struct epoll_event *events,int maxevents,int timeout);

typedef union epoll_data {
    void     *ptr;
    int     fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;

struct epoll_event {
    uint32_t events;        //Epoll events
    epoll_data_t data;    //User data variable
};
</code></pre><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>epoll有两种触发模式，LT(Level-Triggered，水平触发)，ET(Edge–Triggered边缘触发)。其中LT编程模型和poll是一样的。</p>
<p>LT电平触发和ET触发模式的区别是ET触发是高电平到低电平切换的时候或者低电平切换高电平才会触发。</p>
<ul>
<li><p>EPOLLIN事件:</p>
<ul>
<li>内核的输入缓冲区 为空     低电平</li>
<li>内核的输入缓冲区 不为空     高电平（一直触发EPOLLIN）</li>
</ul>
</li>
<li><p>EPOLLOUT事件:</p>
<ul>
<li>内核发送缓冲区不满    高电平(一直触发EPOLLOUT)</li>
<li>内核发送缓冲区满        低电平</li>
</ul>
</li>
</ul>
<h4 id="LT模型例子"><a href="#LT模型例子" class="headerlink" title="LT模型例子"></a>LT模型例子</h4><pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;signal.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/epoll.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

typedef std::vector&lt;struct epoll_event&gt; EventList;

#define ERR_EXIT(m) \
    do \
    { \
            perror(m); \
            exit(EXIT_FAILURE); \
    } while(0)

int main(void)
{
    signal(SIGPIPE, SIG_IGN);
    signal(SIGCHLD, SIG_IGN);
    int idlefd = open(&quot;dev/null&quot;,O_RDONLY | O_CLOEXEC);
    int listenfd;
    if ((listenfd = socket(PF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP)) &lt; 0)
        ERR_EXIT(&quot;socket&quot;);
    struct sockaddr_in servaddr;
    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(5188);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    int on = 1;
    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)
        ERR_EXIT(&quot;socksockopt&quot;);
    if (bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)
        ERR_EXIT(&quot;bind&quot;);
    if (listen(listenfd, SOMAXCONN) &lt; 0)
        ERR_EXIT(&quot;listen&quot;);

    std::vector&lt;int&gt; clients;
    int epollfd;
    epollfd = epoll_create1(EPOLL_CLOEXEC);

    struct epoll_event event;
    event.data.fd = listenfd;
    event.events = EPOLLIN;
    epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &amp;event);

    EventList events(16);
    struct sockaddr_in peeraddr;
    socklen_t peerlen;
    int connfd;

    int nready;
    while(true)
    {
        //和poll的区别
        nready = epoll_wait(epollfd, &amp;*events.begin(), static_cast&lt;int&gt;(events.size()),-1);
        if (-1 == nready)
        {
            if (EINTR == errno)
                continue;
        }
        if (0 == nready)
            continue;

        if ((size_t)nready == events.size())
            events.resize(events.size() * 2);

        for (int i = 0; i &lt; nready; ++i)
        {
            if (events[i].data.fd == listenfd)
            {
                peerlen = sizeof(peeraddr);
                connfd = ::accept4(listenfd, (struct sockaddr*)&amp;peeraddr,
                        &amp;peerlen, SOCK_NONBLOCK | SOCK_CLOEXEC);
                if (-1 == connfd)
                {
                    if (EMFILE == errno)
                    {
                        close(idlefd);
                        idlefd = accept(listenfd, NULL, NULL);
                        close(idlefd);
                        idlefd = open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);
                        continue;
                    } else {
                        ERR_EXIT(&quot;accept4&quot;);
                    }
                }

                std::cout&lt;&lt;&quot;ip=&quot;&lt;&lt;inet_ntoa(peeraddr.sin_addr)&lt;&lt;
                    &quot; port=&quot;&lt;&lt;ntohs(peeraddr.sin_port)&lt;&lt;std::endl;
                clients.push_back(connfd);

                event.data.fd = connfd;
                event.events = EPOLLIN;
                epoll_ctl(epollfd, EPOLL_CTL_ADD, connfd, &amp;event);
            }
            else if (events[i].events &amp; EPOLLIN)
            {
                connfd = events[i].data.fd;
                if (connfd &lt; 0)
                    continue;
                char buf[1024];
                int ret = read(connfd, buf, 1024);
                if (ret == -1)
                    ERR_EXIT(&quot;read&quot;);
                if (ret == 0)
                {
                    std::cout&lt;&lt;&quot;client close&quot;&lt;&lt;std::endl;
                    close(connfd);
                    event = events[i];
                    epoll_ctl(epollfd, EPOLL_CTL_DEL,connfd, &amp;event);
                    clients.erase(std::remove(clients.begin(), clients.end(), connfd), clients.end());
                }
                std::cout&lt;&lt;buf;
                write(connfd, buf, strlen(buf));
            }
        }
    }
}
</code></pre><p>LT模式下什么时候关注EPOLLOUT事件呢？如果在得到一个套接字马上关注，就会出现busy loop的状态。所以应该在write的时候关注EPOLLOUT事件，如果数据没有写完，我们就需要把未发送完的数据添加到应用层缓冲区，然后关注这个连接套接字的EPOLLOUT事件，等到EPOLLOUT事件到来，取出应用层缓冲区的数据发送，如果应用层缓冲区数据发送完成，取消关注EPOLLOUT事件。流程如下：</p>
<p><img src="/assets/images/concurrent_server/05img01.png" alt="img01"></p>
<h4 id="ET模型"><a href="#ET模型" class="headerlink" title="ET模型"></a>ET模型</h4><p>ET表示边缘触发，是电平从低到高或者从高到低才会触发。我们一开始就可以关注EPOLLIN事件和EPOLLOUT事件，不回出现busy loop。所以当接收缓冲区处于高电平状态时，一定要一次性把数据全部读完。因为如果一次没有读完，接收缓冲区仍然处于高电平状态，下次不会在触发EPOLLIN事件。同理，发送缓冲区的处理类似。处理流程如下：</p>
<p><img src="/assets/images/concurrent_server/05img02.png" alt="img01"></p>
<p>ET模型如何处理EMFILE事件呢？如果accept返回了了EMFILE事件，那么epoll将一直保持在高电平状态，后面新的客户端连接都没有办法处理，需要更复杂的处理逻辑。</p>
<h3 id="select-poll-epoll对比"><a href="#select-poll-epoll对比" class="headerlink" title="select/poll/epoll对比"></a>select/poll/epoll对比</h3><p><img src="/assets/images/concurrent_server/05img03.png" alt="img01"></p>
<p><img src="/assets/images/concurrent_server/05img04.png" alt="img01"></p>
<p><img src="/assets/images/concurrent_server/05img05.png" alt="img01"></p>
<p><img src="/assets/images/concurrent_server/05img06.png" alt="img01"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/04/大并发服务器/三、poll函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/12/04/大并发服务器/三、poll函数/" class="post-title-link" itemprop="url">三、poll函数</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-12-04 21:12:48" itemprop="dateCreated datePublished" datetime="2016-12-04T21:12:48+08:00">2016-12-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2016-12-05 09:51:06" itemprop="dateModified" datetime="2016-12-05T09:51:06+08:00">2016-12-05</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Linux-I-O复用模型"><a href="#Linux-I-O复用模型" class="headerlink" title="Linux I/O复用模型"></a>Linux I/O复用模型</h3><p>Linux下有三种I/O复用模型，select、poll、epoll,前两种在内核中的处理方式是一致的，第三种效率最高。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值为发生时间描述符的个数。</p>
<p>pollfd结构体定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">	int fd;			//file descriptor</span><br><span class="line">	short events;		//requested events</span><br><span class="line">	short revents;	//returned events</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="poll使用的基本流程"><a href="#poll使用的基本流程" class="headerlink" title="poll使用的基本流程"></a>poll使用的基本流程</h4><p><img src="/assets/images/concurrent_server/img_poll01.png" alt="img01"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(m) \</span><br><span class="line">        do \</span><br><span class="line">        &#123; \</span><br><span class="line">                perror(m); \</span><br><span class="line">                exit(EXIT_FAILURE); \</span><br><span class="line">        &#125; while(0)</span><br><span class="line">			</span><br><span class="line">typedef std::vector&lt;struct pollfd&gt; PollFdList;</span><br><span class="line">	</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	//如果客户端关闭套接字close，而服务器调用了一次write,</span><br><span class="line">	//服务器就会接收一个RST segment（TCP传输层）,</span><br><span class="line">	//如果服务器再次调用write，就会产生SIGPIPE信号</span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line">	//避免僵尸进程</span><br><span class="line">	signal(SIGCHLD, SIG_IGN);</span><br><span class="line">	int listenfd;</span><br><span class="line">	//非阻塞，替换进程时关闭描述符</span><br><span class="line">	listenfd = socket(PF_INET,SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,IPPROTO_TCP);</span><br><span class="line">	if (listenfd &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;socket&quot;);</span><br><span class="line">	struct sockaddr_in servaddr;</span><br><span class="line">	memset(&amp;servaddr,0,sizeof(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(5188);</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	</span><br><span class="line">	int on = 1;</span><br><span class="line">	if (setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;setsockopt&quot;);</span><br><span class="line">	if (bind(listenfd,(struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;bind&quot;);</span><br><span class="line">	if (listen(listenfd,SOMAXCONN) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;listen&quot;);</span><br><span class="line">	</span><br><span class="line">	struct pollfd pfd;</span><br><span class="line">	pfd.fd = listenfd;</span><br><span class="line">	pfd.events = POLLIN;</span><br><span class="line">	</span><br><span class="line">	PollFdList pollfds;</span><br><span class="line">	pollfds.push_back(pfd);</span><br><span class="line">	</span><br><span class="line">	int nready;</span><br><span class="line">	</span><br><span class="line">	struct sockaddr_in peeraddr;</span><br><span class="line">	socklen_t peerlen;</span><br><span class="line">	int connfd;</span><br><span class="line">	</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		//1.文件描述符数组 2.文件描述符的个数 3.超时时间</span><br><span class="line">		nready = poll(&amp;*pollfds.begin(),pollfds.size(),-1);</span><br><span class="line">		if (nready == -1)</span><br><span class="line">		&#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				continue;</span><br><span class="line">			ERR_EXIT(&quot;poll&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (pollfds[0].revents &amp; POLLIN)</span><br><span class="line">		&#123;</span><br><span class="line">			peerlen = sizeof(peeraddr);</span><br><span class="line">			connfd = ::accept4(listenfd, (struct sockaddr*)&amp;peeraddr,</span><br><span class="line">								&amp;peerlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line">			if (connfd == -1)</span><br><span class="line">				ERR_EXIT(&quot;accept4&quot;);</span><br><span class="line">			pfd.fd = connfd;</span><br><span class="line">			pfd.events = POLLIN;</span><br><span class="line">			pfd.revents = 0;</span><br><span class="line">			pollfds.push_back(pfd);</span><br><span class="line">			--nready;</span><br><span class="line">			</span><br><span class="line">			//连接成功</span><br><span class="line">			std::cout&lt;&lt;&quot;ip=&quot;&lt;&lt;inet_ntoa(peeraddr.sin_addr)&lt;&lt;</span><br><span class="line">					&quot;port=&quot;&lt;&lt;ntohs(peeraddr.sin_port)&lt;&lt;std::endl;</span><br><span class="line">			</span><br><span class="line">			if (nready == 0)</span><br><span class="line">				continue;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout&lt;&lt;nready&lt;&lt;std::endl;</span><br><span class="line">		for (PollFdList::iterator it = pollfds.begin()+1; it != pollfds.end() &amp;&amp; nready &gt; 0;++it)</span><br><span class="line">		&#123;</span><br><span class="line">			if (it-&gt;revents &amp;&amp; POLLIN)</span><br><span class="line">			&#123;</span><br><span class="line">				--nready;</span><br><span class="line">				connfd = it-&gt;fd;</span><br><span class="line">				char buf[1024] = &#123;0&#125;;</span><br><span class="line">				int ret = read(connfd, buf, 102);</span><br><span class="line">				if (ret == -1)</span><br><span class="line">					ERR_EXIT(&quot;read&quot;);</span><br><span class="line">				if (ret == 0)</span><br><span class="line">				&#123;</span><br><span class="line">					std::cout&lt;&lt;&quot;client close&quot;&lt;&lt;std::endl;</span><br><span class="line">					it  = pollfds.erase(it);</span><br><span class="line">					--it;</span><br><span class="line">					close(connfd);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				std::cout&lt;&lt;buf;</span><br><span class="line">				write(connfd, buf, strlen(buf));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题与改进"><a href="#问题与改进" class="headerlink" title="问题与改进"></a>问题与改进</h3><h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p>如果服务器主动断开连接（先于client调用close），服务端就会进入time_wait状态。协议设计上，应该让客户端主动断开连接，这样就把TIME_WAIT状态分散到大量的客户端。但是如果一些恶意客户端一直不断开连接，这样就会占用服务器端的连接资源，所以服务端需要机制踢掉不活跃的连接。</p>
<h4 id="完善read和write"><a href="#完善read和write" class="headerlink" title="完善read和write"></a>完善read和write</h4><p>上面的代码在实际使用的时候有几个问题。一、read操作可能一次不能把对应fd所对应的缓冲区的数据读完，这时fd仍然是活跃的。二、假设应答的数据量比较大，一次write操作不一定能把所有业务数据写到内核缓冲区中。<br>解决办法就是对于read和write操作都建立对应的缓冲区，等数据完全发送／接收完成之后在进行业务操作。</p>
<p>对于write操作来说，需要在数据未完全发送时关注connfd的POLLOUT事件(如果一开始就关注connfd的POLLOUT事件，connnfd会不停的产生事件，造成忙等待)。等应用层缓存区中的数据完全发送完成之后，取消关注connfd的POLLOUT事件。</p>
<h4 id="accept返回EMFILE的处理"><a href="#accept返回EMFILE的处理" class="headerlink" title="accept返回EMFILE的处理"></a>accept返回EMFILE的处理</h4><p>EMFILE是打开的文件描述符的个数超出了上限。解决办法有以下几种：</p>
<ul>
<li>调高进程文件描述符个数（不能解决根本问题，不推荐）</li>
<li>死等，直到有可用的文件描述符（不推荐）</li>
<li>退出程序</li>
<li>关闭监听套接字（不现实，什么时候重新打开呢？）</li>
<li><strong>如果是epoll模型，可以改用edge trigger。</strong>问题是如果漏掉一次accept，程序再也不会收到新连接。</li>
<li><strong>准备一个空闲的文件描述符。</strong>遇到这种情况，先关闭这个空闲文件，获得一个可用的描述符，再accept拿到socket连接的文件描述符；随后立即调用close，这样就优雅的断开了与客户端的链接；最后重新打开空闲文件，以备再次出现这种情况使用。这是比较常用的处理方法。</li>
</ul>
<p>最后一种方式处理的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(m) \</span><br><span class="line">        do \</span><br><span class="line">        &#123; \</span><br><span class="line">                perror(m); \</span><br><span class="line">                exit(EXIT_FAILURE); \</span><br><span class="line">        &#125; while(0)</span><br><span class="line"></span><br><span class="line">typedef std::vector&lt;struct pollfd&gt; PollFdList;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line">	signal(SIGCHLD, SIG_IGN);</span><br><span class="line"></span><br><span class="line">	int idlefd = open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);</span><br><span class="line">	int listenfd;</span><br><span class="line"></span><br><span class="line">	//if ((listenfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0)</span><br><span class="line">	if ((listenfd = socket(PF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;socket&quot;);</span><br><span class="line"></span><br><span class="line">	struct sockaddr_in servaddr;</span><br><span class="line">	memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(5188);</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">	int on = 1;</span><br><span class="line">	if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;setsockopt&quot;);</span><br><span class="line"></span><br><span class="line">	if (bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;bind&quot;);</span><br><span class="line">	if (listen(listenfd, SOMAXCONN) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;listen&quot;);</span><br><span class="line"></span><br><span class="line">	struct pollfd pfd;</span><br><span class="line">	pfd.fd = listenfd;</span><br><span class="line">	pfd.events = POLLIN;</span><br><span class="line"></span><br><span class="line">	PollFdList pollfds;</span><br><span class="line">	pollfds.push_back(pfd);</span><br><span class="line"></span><br><span class="line">	int nready;</span><br><span class="line"></span><br><span class="line">	struct sockaddr_in peeraddr;</span><br><span class="line">	socklen_t peerlen;</span><br><span class="line">	int connfd;</span><br><span class="line"></span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		nready = poll(&amp;*pollfds.begin(), pollfds.size(), -1);</span><br><span class="line">		if (nready == -1)</span><br><span class="line">		&#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				continue;</span><br><span class="line">			</span><br><span class="line">			ERR_EXIT(&quot;poll&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (nready == 0)	// nothing happended</span><br><span class="line">			continue;</span><br><span class="line">		</span><br><span class="line">		if (pollfds[0].revents &amp; POLLIN)</span><br><span class="line">		&#123;</span><br><span class="line">			peerlen = sizeof(peeraddr);</span><br><span class="line">			connfd = accept4(listenfd, (struct sockaddr*)&amp;peeraddr,</span><br><span class="line">						&amp;peerlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line"></span><br><span class="line">/*			if (connfd == -1)</span><br><span class="line">				ERR_EXIT(&quot;accept4&quot;);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			if (connfd == -1)</span><br><span class="line">			&#123;</span><br><span class="line">				if (errno == EMFILE)</span><br><span class="line">				&#123;</span><br><span class="line">					close(idlefd);</span><br><span class="line">					idlefd = accept(listenfd, NULL, NULL);</span><br><span class="line">					close(idlefd);</span><br><span class="line">					idlefd = open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">					ERR_EXIT(&quot;accept4&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pfd.fd = connfd;</span><br><span class="line">			pfd.events = POLLIN;</span><br><span class="line">			pfd.revents = 0;</span><br><span class="line">			pollfds.push_back(pfd);</span><br><span class="line">			--nready;</span><br><span class="line"></span><br><span class="line">			// 连接成功</span><br><span class="line">			std::cout&lt;&lt;&quot;ip=&quot;&lt;&lt;inet_ntoa(peeraddr.sin_addr)&lt;&lt;</span><br><span class="line">				&quot; port=&quot;&lt;&lt;ntohs(peeraddr.sin_port)&lt;&lt;std::endl;</span><br><span class="line">			if (nready == 0)</span><br><span class="line">				continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//std::cout&lt;&lt;pollfds.size()&lt;&lt;std::endl;</span><br><span class="line">		//std::cout&lt;&lt;nready&lt;&lt;std::endl;</span><br><span class="line">		for (PollFdList::iterator it=pollfds.begin()+1;</span><br><span class="line">			it != pollfds.end() &amp;&amp; nready &gt;0; ++it)</span><br><span class="line">		&#123;</span><br><span class="line">				if (it-&gt;revents &amp; POLLIN)</span><br><span class="line">				&#123;</span><br><span class="line">					--nready;</span><br><span class="line">					connfd = it-&gt;fd;</span><br><span class="line">					char buf[1024] = &#123;0&#125;;</span><br><span class="line">					int ret = read(connfd, buf, 1024);</span><br><span class="line">					if (ret == -1)</span><br><span class="line">						ERR_EXIT(&quot;read&quot;);</span><br><span class="line">					if (ret == 0)</span><br><span class="line">					&#123;</span><br><span class="line">						std::cout&lt;&lt;&quot;client close&quot;&lt;&lt;std::endl;</span><br><span class="line">						it = pollfds.erase(it);</span><br><span class="line">						--it;</span><br><span class="line"></span><br><span class="line">						close(connfd);</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					std::cout&lt;&lt;buf;</span><br><span class="line">					write(connfd, buf, strlen(buf));</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/01/大并发服务器/二、大型网站架构演变/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/12/01/大并发服务器/二、大型网站架构演变/" class="post-title-link" itemprop="url">二、大型网站架构演变</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-12-01 11:30:57" itemprop="dateCreated datePublished" datetime="2016-12-01T11:30:57+08:00">2016-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2016-12-05 11:03:41" itemprop="dateModified" datetime="2016-12-05T11:03:41+08:00">2016-12-05</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇大并发服务器架构大致讲了下大并发服务器架构演变，这一章以大型网站为例，介绍下大并发服务器架构演变的过程。</p>
<h3 id="Web-Server和Database-Server分离"><a href="#Web-Server和Database-Server分离" class="headerlink" title="Web Server和Database Server分离"></a>Web Server和Database Server分离</h3><p>网站刚开始建站时，访问量比较小，可以将web服务器和数据库服务器部署在同一台服务器上。此时Web服务器和数据库服务器互相影响。任何一个出现性能瓶颈，都会影响网站的访问速度。不符合大并发服务器的高性能的要求。任何一个瘫痪，都会导致整个网站瘫痪，不符合大并发服务器的高可用要求。我们可以将Web Server和Database Server分离：</p>
<p><img src="/assets/images/concurrent_server/img01.png" alt="img01"></p>
<p>对Web资源的请求从请求方式上来说可以分为对静态资源和对动态资源的请求:</p>
<ol>
<li>静态请求：html,js,css,image等。这些请求由HTTP服务器（apache，nginx）处理</li>
<li>动态请求：jsp,PHP,asp.Net等。这些请求由应用服务器（JBoss，Tomcat）处理。<br>对静态资源的访问不需要处理，而对动态资源的请求需要业务逻辑处理后返回，所以两者的访问速度是不一样的。为了提高性能，可以将Web服务器进行动静资源分离：</li>
</ol>
<p><img src="/assets/images/concurrent_server/img02.png" alt="img01"></p>
<h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p><img src="/assets/images/concurrent_server/img03.png" alt="img01"></p>
<h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><p>浏览器缓存是将访问的文件保存在客户端，在同一个会话过程中会检查缓存的副本是否足够新，在后退网页时，访问过的资源可以从浏览器缓存中拿出使用。减少服务器处理请求的数量，提高访问速度。浏览器缓存状态是由header参数控制的，header的参数有四种：</p>
<ol>
<li>Cache-Control 取值如下：<ul>
<li>max-age（单位为s）指定设置缓存最大的有效时间，定义的是时间长短。</li>
<li>s-maxage（单位为s）同max-age，只用于共享缓存（比如CDN缓存）</li>
<li>public 指定响应会被缓存，并且在多用户间共享。</li>
<li>private 响应只作为私有的缓存</li>
<li>no-cache 指定不缓存响应，表明资源不进行缓存.但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。</li>
<li>no-store 绝对禁止缓存</li>
<li>must-revalidate指定如果页面是过期的，则去服务器进行获取。</li>
</ul>
</li>
<li>Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</li>
<li>Last-modified 服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。</li>
<li>ETag 根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。</li>
</ol>
<h4 id="前端页面缓存（Front-Page-Cache，squid）"><a href="#前端页面缓存（Front-Page-Cache，squid）" class="headerlink" title="前端页面缓存（Front Page Cache，squid）"></a>前端页面缓存（Front Page Cache，squid）</h4><p>与浏览器缓存将页面缓存在客户端不同，squid是通过代理将页面缓存在单独的服务器上。它是这样实现其功能的，当客户端请求一个页面时，首先请求Squid服务器，Squid随之连接到远程服务器并向这个页面发出请求，然后Squid把页面返回到客户端机器同时本地缓存一份。当下一次某个客户端需要同样的数据的时候，Squid就从缓存中直接取出发送给客户端。</p>
<h4 id="页面片段缓存（ESI，Edge-Side-Includes）"><a href="#页面片段缓存（ESI，Edge-Side-Includes）" class="headerlink" title="页面片段缓存（ESI，Edge Side Includes）"></a>页面片段缓存（ESI，Edge Side Includes）</h4><p>前面提到的缓存技术，都是缓存整个页面的。但是有时候会存在某些页面，这些页面中的一部分是可静态的，一部分是动态的，这时候就需要用到动态内容缓存技术。动态内容缓存技术大致有三种，CSI，SSI，ESI。<br>这里讲下ESI,其中Squid就有支持ESI的模块。</p>
<blockquote>
<p>ESI是一种简单的标识语言，开发人员可以使用它标志内容片断以便通过相应的Cache服务器来加速缓存。同时ESI还定义了一 套内容效验标准，可以实现原服务器对Cache服务器中缓存内容的管理，提高了网站对内容的控制能力。CDN网络也可以利用在分布全国各地的节点中安装支 持ESI的Cache服务器来提供对网站动态内容提供CDN服务。</p>
</blockquote>
<p>举个例子，比如网站首页大部分内容都是静态的，但是会在登录之后显示某某，欢迎你的字样的动态内容。如果因为这一点动态内容不缓存页面就太可惜了。用ESI可以做如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;esi:include src=&quot;/welcome&quot; /&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">#foreach($user in $users)</span><br><span class="line">&lt;li&gt;$user.name&lt;/li&gt;</span><br><span class="line">#end</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>缓存服务器会将整个页面cache，然后它发现这儿有个ESI标签，它会根据src指定的地址去源服务器请求内容，然后将其合并到缓存的页面中，然后将完整的内容发送到客户端。整个过程类似下图所示：</p>
<p><img src="/assets/images/concurrent_server/img04.png" alt="img01"></p>
<h4 id="本地数据缓存"><a href="#本地数据缓存" class="headerlink" title="本地数据缓存"></a>本地数据缓存</h4><p>缓存数据库的查询结果到数据库服务器。</p>
<h3 id="Web-Server集群"><a href="#Web-Server集群" class="headerlink" title="Web Server集群"></a>Web Server集群</h3><h4 id="前端负载均衡"><a href="#前端负载均衡" class="headerlink" title="前端负载均衡"></a>前端负载均衡</h4><ul>
<li>DNS负载均衡<br>在DNS服务器中，可以为多个不同的地址配置同一个名字，对于不同的客户机访问同一个名字，得到不同的地址。</li>
<li>反向代理<br>使用代理服务器将请求发给内部服务器，让代理服务器将请求均匀转发给多台内部web服务器之一，从而达到负载均衡的目的。标准代理方式是客户使用代理访问多个外部Web服务器，而这种代理方式是多个客户使用它访问内部Web服务器，因此也被称为反向代理模式。</li>
<li>基于NAT的负载均衡技术<br>简单的来说，NAT负载均衡是将外网IP地址转换为内部IP地址，将外网大量的访问合理的分配到内部的多台服务器上,从而降低服务器访问压力。</li>
<li>LVS<br>Linux虚拟服务器负载均衡。</li>
<li>F5硬件负载均衡</li>
</ul>
<h4 id="应用服务器负载均衡"><a href="#应用服务器负载均衡" class="headerlink" title="应用服务器负载均衡"></a>应用服务器负载均衡</h4><p>增加任务服务器，由任务服务器调度业务服务器实现负载均衡。上一篇已经讲过，这里不在详细讲解。</p>
<h4 id="数据库负载均衡"><a href="#数据库负载均衡" class="headerlink" title="数据库负载均衡"></a>数据库负载均衡</h4><p>通过构建数据库服务器集群实在数据库服务器负载均衡。</p>
<h3 id="CDN、分布式缓存、分库分表"><a href="#CDN、分布式缓存、分库分表" class="headerlink" title="CDN、分布式缓存、分库分表"></a>CDN、分布式缓存、分库分表</h3><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>在各个运营商不同地区增加内容分发网络，这样不同地区、不同运营商接入都能提升访问数据。</p>
<h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><p>增加分布式缓存替代本地缓存，让所有的机器共享缓存。目前流行的分布式缓存方案有memcached、membase、redis。基本上当前的NoSql方案都可以用作分布式缓存方案。分布式缓存结构如下:</p>
<p><img src="/assets/images/concurrent_server/img08.png" alt="img01"></p>
<h4 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h4><p>当数据库数据量非常大的时候，为了将数据库查询均衡到不同的服务器上，需要对数据库进行分区，数据库分区分为以下两种方式：</p>
<ol>
<li>垂直分区<br>当服务器并发量比较大的时候，数据库访问就会容易出现锁竞争，而锁竞争是数据库访问性能的杀手， 所以，我们可以将不同业务数据分离到不同的数据库。如图：</li>
</ol>
<p><img src="/assets/images/concurrent_server/img09.png" alt="img01"></p>
<ol start="2">
<li>水平分区<br>数据库中有部分表可能数据量非常大，可以将数据库大表中的数据分摊到不同的数据库中对应的表。不同数据库中对应表的数据总和就是这张表对应的所有数据。数据分摊的方式有不同的实现，一般都使用hash算法。如图：</li>
</ol>
<p><img src="/assets/images/concurrent_server/img10.png" alt="img01"></p>
<p>数据库分库分表之后数据库物理结构发生了改变，不能在像之前直接访问，需要增加DAL数据访问层。</p>
<h3 id="多数据中心-分布式存储与计算"><a href="#多数据中心-分布式存储与计算" class="headerlink" title="多数据中心+分布式存储与计算"></a>多数据中心+分布式存储与计算</h3><p>增加多数据中心和分布式存储与计算后的结构图</p>
<p><img src="/assets/images/concurrent_server/img11.png" alt="img01"></p>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><p>大型网站当中有一些数据对数据的一致性要求不高，这些数据没有必要保持在关系型数据库中。关系型数据库对关系的一致性要求比较高，数据库的事物，大表的join都是数据库性能的杀手。我们可以把这些数据分离出来，把这些数据放到数据中心里。数据中心一般都使用NoSql数据库，NoSql采用key/value存储数据。大并发的性能比关系型数据库的性能要高。</p>
<p>NoSql的数据一般存在于分布式的文件系统中，为什么要使用自己的文件系统呢？举个淘宝例子，淘宝商品有很多小图片，假如放在操作系统管理的文件系统中，操作系统文件系统每一个块都比较小，这样查找某个图片时需要多次查找块，这个过程需要多次移动磁头，所以整体是比较耗时。假如把每一个块都增大，将相关性比较大的数据存到块里，每个块包含一些存储数据的信息。通过hash算法，就能快速找到文件。目前比较有名的分布式文件系统有：Lustre，HDFS，GFS，TFS，FreeNas等。</p>
<h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4><h5 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map/Reduce"></a>Map/Reduce</h5><p>假如我们要统计一些文件中每个单词出现的的个数。可能文件非常多，无法全部加载到内容中。我们可以使用多台机器来统计。每台机器统计一部分，把统计的结果暂时保存到key/value数据库中，这个过程称作Map。</p>
<p>Map完成之后需要将相同结果合并，比如a机器出现单词hello3次，b机器出现4次，那么reduce服务器需要把统计结果相加为hello出现7次，合并的过程称作reduce。 </p>
<p>Map/Reduce的过程如下：</p>
<p><img src="/assets/images/concurrent_server/img12.png" alt="img01"></p>
<p>key-value数据库，作为NoSql的解决方案，基本都支持Map/Reduce算法。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/20/大并发服务器/一、大并发服务器架构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/11/20/大并发服务器/一、大并发服务器架构/" class="post-title-link" itemprop="url">一、大并发服务器架构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-11-20 19:41:42" itemprop="dateCreated datePublished" datetime="2016-11-20T19:41:42+08:00">2016-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2016-12-04 21:15:13" itemprop="dateModified" datetime="2016-12-04T21:15:13+08:00">2016-12-04</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务器设计目标"><a href="#服务器设计目标" class="headerlink" title="服务器设计目标"></a>服务器设计目标</h2><h3 id="高性能-High-Performance"><a href="#高性能-High-Performance" class="headerlink" title="高性能(High Performance)"></a>高性能(High Performance)</h3><p>对于大量的并发请求，服务器能否及时快速的做出响应，这就要求我们编写的程序能够最大发挥出机器的性能，能够在短时间处理尽可能多的的并发请求。</p>
<h3 id="高可用-High-Availability"><a href="#高可用-High-Availability" class="headerlink" title="高可用(High Availability)"></a>高可用(High Availability)</h3><p>要求服务器能够提供7x24小时不间断的服务，如果某台服务器出现故障，也能自动转移到备用机，而不需要人工干预（faileover机制）。</p>
<h3 id="伸缩性-Scalability"><a href="#伸缩性-Scalability" class="headerlink" title="伸缩性(Scalability)"></a>伸缩性(Scalability)</h3><p>服务器采用良好的架构，分层设计，业务分离，能够进行灵活的部署。比如服务器有A，B两个组件，这两个组件可以部署在同一台服务器上，也可以部署在不同的服务器上，这就要求这两个组件不能使用本地通信机制，比如共享内存。而应该使用TCP这样的跨机器的通信方式。</p>
<h2 id="典型的服务器结构"><a href="#典型的服务器结构" class="headerlink" title="典型的服务器结构"></a>典型的服务器结构</h2><p>常用的软件体系结构有C/S和B/S两种，C/S是指客户端-服务器模型，B/S是指浏览器-服务器模型，因为浏览器也是客户端程序，所以说本质上也是C/S结构。下图是C/S结构图。</p>
<p><img src="/assets/images/concurrent_server/cs_net.png" alt="CS结构图" title="加载中"></p>
<h2 id="服务器并发的影响因素"><a href="#服务器并发的影响因素" class="headerlink" title="服务器并发的影响因素"></a>服务器并发的影响因素</h2><h3 id="网络I-O-服务器高性能编程技术"><a href="#网络I-O-服务器高性能编程技术" class="headerlink" title="网络I/O+服务器高性能编程技术"></a>网络I/O+服务器高性能编程技术</h3><p>对于Linux来说，网络I/O最高效的编程模型是epoll。对于服务器编程来说，耗时操作有以下几个类型：</p>
<ol>
<li>数据拷贝 比如数据从内核拷贝到应用层，一般通过缓存常用的数据解决。</li>
<li>环境切换 线程切换，对于单核服务器来说，使用多线程不一定能提高性能，采用状态机模型解决最好。</li>
<li>内存分配 增加内存池，减少向操作系统申请内存。</li>
<li>锁竞争    尽量减少锁竞争。</li>
</ol>
<h3 id="数据库限制"><a href="#数据库限制" class="headerlink" title="数据库限制"></a>数据库限制</h3><ol>
<li><p>数据库连接数</p>
<p>假如数据库并发连接数是10个，假设应用服务器有1000个连接请求，将会有990个请求失败。</p>
</li>
<li><p>数据库连接时限</p>
<p>假如数据库并发连接数10个，假设数据库1s之内最多处理1000个请求，如果应用服务器有1w个请求，那么处理全部请求需要10s。如果系统规定最大响应时间是5s，那么当前数据库最大并发量是5000。</p>
</li>
</ol>
<h2 id="提高服务器性能"><a href="#提高服务器性能" class="headerlink" title="提高服务器性能"></a>提高服务器性能</h2><h3 id="降低数据库访问压力"><a href="#降低数据库访问压力" class="headerlink" title="降低数据库访问压力"></a>降低数据库访问压力</h3><ol>
<li><p>增加DAL队列 + 连接池。为了解决这个问题，可以增加一个DAL队列，大量数据库访问的时候，我们可以让当前不能处理的连接排队。为了提升性能，也可以增加一个数据库连接池，连接池创建的时候申请一些数据库连接放到池里，当下一次需要数据库连接的时候直接从连接池中取出处理。如下图：</p>
<p><img src="/assets/images/concurrent_server/cs_net.png" alt="" title="服务器结构图"></p>
</li>
<li><p>尽量将业务逻辑挪到应用服务器，数据库少做业务处理。因为在数据库上计算占用CPU，不如在操作系统上业务处理效率高。</p>
</li>
<li>缓存数据。把常用的数据缓存起来，下一次请求时从缓存中取数据。降低对数据库请求的次数。<ul>
<li>缓存算法。常用缓存算法有FIFO、LRU、LFU，最近开源的nosql数据库一般都会实现数据内存缓存，例如分布式缓存框架redis、memcached。</li>
<li>缓存的实效性。另外缓存是有时效性的，使用缓存的时候会有同步的问题。一般有两种处理方案。一、缓存失效时，我们需要重新去数据库查询。这种方案实时性比较差。二、更新数据库时，将一些热点数据同步更新至缓存。这种方案实时性比较高，但是实现起来比较麻烦。</li>
</ul>
</li>
<li>数据库负载均衡。大部分情况下，数据库读操作多于写操作。这时候就应该对数据进行数据库读写分离，也就是数据库的负载均衡。目前主流的数据库都具有replication进行负载均衡。（Master-Slaver模式）</li>
<li><p>分库分表。因为不同类型的数据读写速度是不一样的，把不同数据分离能显著提升数据库性能。分库是指数据库可以按照一定的逻辑把表分散到不同的数据库（垂直分区），比如我们可以把一个数据库分为用户表、业务表、基础表组成的库。另外一种比较常用的方法是水平分区，每个数据库都有对应的表，只是把对应表里的记录分割到不同的数据库，这样就很方便的扩展数据库。</p>
<p><img src="/assets/images/concurrent_server/cs_net.png" alt="服务器结构图" title="服务器结构图"></p>
</li>
</ol>
<h3 id="应用服务器负载均衡"><a href="#应用服务器负载均衡" class="headerlink" title="应用服务器负载均衡"></a>应用服务器负载均衡</h3><ol>
<li><p>业务分离。将业务分割到不同服务器上，对应的业务访问对应的服务器。此时应用服务器也应该进行负载均衡，可以通过增加一个任务服务器来实现。实现方案有下面两种。一、应用服务器提供接口提供自己的状态，任务服务器监视应用服务器的状态（CPU、IO、并发、换页），任务服务器就可以选择负载最低的应用服务器分配任务。二、应用服务器空闲时，主动去任务服务器取任务。任务服务器也要实现faileover机制。</p>
<p><img src="/assets/images/concurrent_server/cs_net.png" alt="服务器结构图" title="服务器结构图"></p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/29/iOS数据结构-实现NSMutableArray/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/05/29/iOS数据结构-实现NSMutableArray/" class="post-title-link" itemprop="url">iOS数据结构(一):实现NSMutableArray</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-05-29 20:11:59" itemprop="dateCreated datePublished" datetime="2016-05-29T20:11:59+08:00">2016-05-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2017-03-19 10:28:29" itemprop="dateModified" datetime="2017-03-19T10:28:29+08:00">2017-03-19</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集合是Cocoa中常用的数据结构，但是对于程序员来说底层实现一般都是透明的。今天，我们根据使用场景自己实现一个<code>NSMutableArray</code>。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>因为<code>NSMutableArray</code>是一个<code>class cluster</code>,所以实现起来非常简单，只需要继承它然后实现它基本方法就能实现具有完整功能的<code>NSMutableArray</code>(上层方法是根据基本方法来实现的)。下面是<code>NSMutableArray</code>的基本方法：</p>
<pre><code>- (NSUInteger)count;
- (id)objectAtIndex:(NSUInteger)index;
- (void)addObject:(id)anObject;
- (void)insertObject:(id)anObject atIndex:(NSUInteger)index;
- (void)removeLastObject;
- (void)removeObjectAtIndex:(NSUInteger)index;
- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject;
</code></pre><p>实际上，上面的基本方法还是可以简化，比如<code>addObject:</code>可以用<code>insertObject:atIndex:,</code>实现，而<code>removeLastObject</code>可以用<code>removeObjectAtIndex:</code>来实现。</p>
<p>实现这些方法的大致思路是什么呢？首先，我们可以用C array作为底层的存储结构，但是C array是不可变的，不支持添加或者删除某个元素，所以，在涉及到添加或者删除元素的时候，我们可以通过copy数组的方式来处理。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>完整代码实现已经放在GitHub上。<a href="https://github.com/tianyig/minishell" target="_blank" rel="noopener">NSMutableArray源代码</a>。</p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><pre><code>@interface JJMutableArray : NSMutableArray
@end
</code></pre><p>我们的实现继承<code>NSMutableArray</code>,这样就可以不用关心初始化的内存分配，把精力放到这几个方法的实现上。</p>
<h3 id="定义私有变量"><a href="#定义私有变量" class="headerlink" title="定义私有变量"></a>定义私有变量</h3><pre><code>@implementation JJMutableArray {
    NSUInteger _count;
    NSUInteger _capacity;
    id *_objs;
}
</code></pre><p><code>_objs</code>是C array，<code>_capacity</code>用来储存数组内存空间的大小，数组里实际元素的个数用<code>_count</code>来表示。</p>
<p>使用<code>JJMutableArray</code>第一步是初始化，所以我们需要先实现<code>initWithCapacity:</code>,实际上已<code>+array</code>开头的方法基本上都是用这个方法实现的，这个方法的具体实现官方没有具体的文档，这里直接调用<code>[super init]</code>即可。</p>
<p>可能这里有同学比较好奇，这个实现应该非常简单啊，数组里存储的是固定大小的指针，根据参数分配固定大小的内存空间不就可以了吗？其实有以下几个需要考虑的问题：</p>
<ol>
<li>如果分配的空间远远大于实际需要的，是不是需要担心内存浪费？</li>
<li>如果分配的空间小于实际需要的，那么在增加大量新的元素的效率如何？(这个涉及到内存增长策略，下面会解释)</li>
<li>如果参数是0如何处理，是不是等同于调用<code>[[NSMutableArray alloc] init]</code>？</li>
</ol>
<p>这里先回答第三个问题，实际上它们是不等价的,至于两者有什么不同可以参考stackoverflow上的这个答案:<a href="http://stackoverflow.com/questions/6077422/objective-c-nsarray-init-versus-initwithcapacity0/6077543#6077543" target="_blank" rel="noopener">Objective-c NSArray init versus initWithCapacity:0</a>。</p>
<p><code>initWithCapacity:</code>的具体实现细节不是这篇文章的主题，这里不再讨论。</p>
<p>然后与之对应的我们实现<code>dealloc</code>函数，当一个数组被销毁的时候，需要释放它管理的所有对象的内存空间，简单起见，我们直接移除所有元素然后释放数组的内存空间。</p>
<pre><code>- (void)dealloc
{
    [self removeAllObjects];
    free(_objs);
    [super dealloc];
}
</code></pre><p>接下来可以开始实现一些具体的函数，首先实现<code>count</code>函数,因为<code>_count</code>保存了实际元素的个数，直接返回即可:</p>
<pre><code>- (NSUInteger)count
{
    return _count;
}
</code></pre><p>然后是<code>objectAtIndex:</code>,实现也很简单，直接返回对应位置元素即可:</p>
<pre><code>- (id)objectAtIndex: (NSUInteger)index
{
    return _objs[index];
}
</code></pre><p>这里没有做参数越界检查和错误处理，所以在使用这个函数的时候越界的时候会直接崩溃，和系统函数表现一致。</p>
<h3 id="插入的实现"><a href="#插入的实现" class="headerlink" title="插入的实现"></a>插入的实现</h3><p>之前提过，<code>addObject:</code>可以通过<code>insertObject:atIndex:</code>实现：</p>
<pre><code>- (void)addObject:(id)anObject
{
    [self insertObject: anObject atIndex: [self count]];
}
</code></pre><p>考虑内存空间已经满的时候，这个时候需要给新元素分配新的内存空间：</p>
<pre><code>- (void)insertObject: (id)anObject atIndex: (NSUInteger)index
{
    if(_count &gt;= _capacity)
    {
</code></pre><p>计算新元素需要需要的空间，在第一次分配的时候，我们最少分配16个元素的空间。之后每次分配当前空间2倍大小，是因为配置新空间,数据移动,释还旧空间是个大工程，时间成本很高，应该加入未雨绸缪的考虑，这样可以减少以后的内存分配和移动操作，提升数组效率。分配完空间之后，把原来的元素拷贝过来，下面是代码：</p>
<pre><code>NSUInteger newCapacity = MAX(_capacity * 2, 16);
id *newObjs = malloc(newCapacity * sizeof(*newObjs));
memcpy(newObjs, _objs, _count * sizeof(*_objs));
</code></pre><p> 关于内存空间的分配，我们这里采用的是最简单的策略，即每次分配原来空间的2倍大小，这里参考了SGI STL的实现策略。(最新的C++11对vector的增长策略做了调整)。</p>
<p>然后释放之前的内存空间：</p>
<pre><code>    free(_objs);
    _objs = newObjs;
    _capacity = newCapacity;
}
</code></pre><p>经过这样的操作之后，已经能保证有足够的空间存储新的元素。我们接着需要把要插入位置之后的元素向后挪动一个位置，给要插入的元素留出位置，这里可以使用<code>memmove</code>函数。</p>
<pre><code>memmove(_objs + index + 1, _objs + index, ([self count] - index) * sizeof(*_objs));
</code></pre><p>作为<code>memcpy</code>的变体，标准是允许<code>memmove</code>允许移动的区域是有重叠的，而且会覆盖重叠的部分，并且它会假设要移动的位置有足够的空间容纳要移动的元素，否则就会指针越界。(注意：<code>memmove</code>的实现有多种，且在debug和release下行为不一定一致)</p>
<p>移动完成之后，就需要在空出的位置放置我们的新元素，然后让元素个数加1：</p>
<pre><code>    _objs[index] = [anObject retain];

    _count++;
}
</code></pre><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>移除最后一个元素可以通过下面的方式实现：</p>
<pre><code>- (void)removeLastObject
{
    [self removeObjectAtIndex: [self count] - 1];
}
</code></pre><p>移除指针位置的元素也非常简单，将元素空间释放之后将后面的元素前移一个位置即可：</p>
<pre><code>- (void)removeObjectAtIndex: (NSUInteger)index
{
    _objs[index] ＝ nil;//ARC
    memmove(_objs + index, _objs + index + 1, ([self count] - index - 1) * sizeof(*_objs));
    _count--;
}
</code></pre><p>这里同样需要错误处理和参数合法性检查，为了方便，这里不在处理。</p>
<p>同样的原因，这里真正的实现应该尽量减少元素移动的次数。考虑一个极端情况，假设插入了几百万个元素，然后把它们全部移除。我们不希望每移除一个元素，就做一次内存调整。具体实现属于内存使用优化相关内容，这里采用最简单的实现。真正实现和<code>insertObject:atIndex:</code>类似。</p>
<h3 id="元素替换"><a href="#元素替换" class="headerlink" title="元素替换"></a>元素替换</h3><p>这个实现同样非常简单，直接替换即可:</p>
<pre><code>- (void)replaceObjectAtIndex: (NSUInteger)index withObject: (id)anObject
{
    _objs[index] = nil;
    _objs[index] = anObject;
}
</code></pre><p>好了，<code>NSMutableArray</code>的基础实现已经完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里简单实现了<code>NSMutableArray</code>，实际上<code>NSMutableArray</code>的底层实现采用的是非线性存储。很可能是用的是红黑树之类的平衡树来实现的。通过文档和官方开源<code>CFArray</code>源代码可以看出来(更底层的未来源，只能根据现象猜测):</p>
<blockquote>
<p>The access time for a value in the array is guaranteed to be at<br>    worst O(lg N) for any implementation, current and future, but will<br>    often be O(1) (constant time). Linear search operations similarly<br>    have a worst case complexity of O(N<em>lg N), though typically the<br>    bounds will be tighter, and so on. Insertion or deletion operations<br>    will typically be linear in the number of values in the array, but<br>    may be O(N</em>lg N) clearly in the worst case in some implementations.<br>    There are no favored positions within the array for performance;<br>    that is, it is not necessarily faster to access values with low<br>    indices, or to insert or delete values with high indices, or<br>    whatever.</p>
</blockquote>
<p>这个文档提到保证最低查询时间是对数级的，我们知道，如果是线性存储的只能是线性查找效率，是不可能达到对数查找的效率的。说明底层应该不是线性存储。</p>
<p>下面是CFArray判断两个数组是否等价的代码，从代码可以看出，数组元素是存在某个节点上的，从函数命名规范上来看，猜测哈希表作为底层数据结构存储的。</p>
<pre><code>static Boolean __CFArrayEqual(CFTypeRef cf1, CFTypeRef cf2) {
CFArrayRef array1 = (CFArrayRef)cf1;
CFArrayRef array2 = (CFArrayRef)cf2;
const CFArrayCallBacks *cb1, *cb2;
CFIndex idx, cnt;
if (array1 == array2) return true;
cnt = __CFArrayGetCount(array1);
if (cnt != __CFArrayGetCount(array2)) return false;
cb1 = __CFArrayGetCallBacks(array1);
cb2 = __CFArrayGetCallBacks(array2);
if (cb1-&gt;equal != cb2-&gt;equal) return false;
if (0 == cnt) return true;    /* after function comparison! */
for (idx = 0; idx &lt; cnt; idx++) {
const void *val1 = __CFArrayGetBucketAtIndex(array1, idx)-&gt;_item;
const void *val2 = __CFArrayGetBucketAtIndex(array2, idx)-&gt;_item;
if (val1 != val2) {
    if (NULL == cb1-&gt;equal) return false;
    if (!INVOKE_CALLBACK2(cb1-&gt;equal, val1, val2)) return false;
}
}
return true;
}
</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><p><a href="http://www.vellios.com/2010/08/22/why-game-devs-dont-use-objective-c/" target="_blank" rel="noopener">http://www.vellios.com/2010/08/22/why-game-devs-dont-use-objective-c/</a></p>
</li>
<li><p><a href="http://www.gnustep.org/resources/OpenStepSpec/FoundationKit/Classes/NSMutableArray.html" target="_blank" rel="noopener">http://www.gnustep.org/resources/OpenStepSpec/FoundationKit/Classes/NSMutableArray.html</a></p>
</li>
<li>STL源码剖析 侯捷</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/30/MarkDown语法学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天意">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风过无痕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/01/30/MarkDown语法学习/" class="post-title-link" itemprop="url">MarkDown语法学习</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-01-30 12:30:35" itemprop="dateCreated datePublished" datetime="2016-01-30T12:30:35+08:00">2016-01-30</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>欢迎来到我的<a href="www.liudesheng.com">博客</a>,第一篇我们会学习使用MarkDown语法来书写文章。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown语法中，标题是文本前面加上<code>#</code>来表示的，一个#代表一级标题，同里，还可以增加二级标题，三级标题，最大不能超过六级。例如:</p>
<blockquote>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre></blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表只需在文字前面加上 <code>-</code>。例如：</p>
<blockquote>
<pre><code>- 文本1
- 文本2
- 文本3
</code></pre></blockquote>
<p>如果需要创建有序列表，在文字前加上1.2.3.。注意：-、1.和文本之间要保留一个空格。例如:</p>
<blockquote>
<pre><code>1. 文本1
2. 文本2
3. 文本3
</code></pre></blockquote>
<h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2><p>在Markdown中，插入链接需要语法即可。例如:</p>
<blockquote>
<pre><code>[博客](www.liudesheng.com)
</code></pre></blockquote>
<p>插入图片使用以下的格式：</p>
<blockquote>
<pre><code>![]()(http://weibo.com/hnrain?s=6cm7D0)
</code></pre></blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果在写作的时候需要引用别人的文字，直接在需要引用的文字前面加<code>&gt;</code>就好。例如：</p>
<blockquote>
<pre><code>这是一段引用的文字。
</code></pre></blockquote>
<h2 id="粗体斜体"><a href="#粗体斜体" class="headerlink" title="粗体斜体"></a>粗体斜体</h2><p>用两个<code>*</code>包含的文本是粗体，用一个<code>*</code>包含的文本是斜体。例如:</p>
<blockquote>
<pre><code>**这是粗体**
*这是斜体*
</code></pre><p>生存还是<strong>毁灭</strong>,这是一个<em>问题</em>。</p>
</blockquote>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>在MarkDown中表格的表示方式非常形象。例子如下</p>
<blockquote>
<pre><code>| table            | row           | pes  |
| -------------     |:-------------:| -----:|
| col1              | right-aligned | data12345 |
| col2              | centered      | data2 |
| col3             | test      |    d3 |
</code></pre></blockquote>
<p>默认居左，横线两边加冒号的是居中，冒号在右边的是居右。效果如下：</p>
<table>
<thead>
<tr>
<th>table</th>
<th style="text-align:center">row</th>
<th style="text-align:right">pes</th>
</tr>
</thead>
<tbody>
<tr>
<td>col1</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">data12345</td>
</tr>
<tr>
<td>col2</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">data2</td>
</tr>
<tr>
<td>col3</td>
<td style="text-align:center">test</td>
<td style="text-align:right">d3</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">天意</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">天意</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
