
<!DOCTYPE html>
<html lang="null">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="得胜的技术博客，谢谢关注">
    <title>所有文章: 2017/2 - 得胜的技术博客，谢谢关注</title>
    <meta name="author" content="刘得胜">
    
    
    
    <meta name="description">
<meta property="og:type" content="blog">
<meta property="og:title" content="得胜的技术博客，谢谢关注">
<meta property="og:url" content="http://yoursite.com/archives/2017/02/index.html">
<meta property="og:site_name" content="得胜的技术博客，谢谢关注">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="得胜的技术博客，谢谢关注">
<meta name="twitter:description">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css" type="text/css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">得胜的技术博客，谢谢关注</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="/#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="/#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/27/SDWebImage源码阅读-一/">
                            SDWebImage源码阅读笔记
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-27T10:55:02+08:00">
	
		    Feb 27, 2017
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="前言"><strong>前言</strong></h2><p>SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。</p>
<h2 id="SDWebImage结构"><strong>SDWebImage结构</strong></h2><p>首先我们看看SDWebImage的项目组织结构：</p>
<p><img src="/assets/images/SDWebImage/01.png" alt="img01"></p>
<blockquote>
<p>Downloader负责图片的异步下载；</p>
<p>Cache负责图片的缓存；</p>
<p>SDWebImageManager是总的管理类，维护了一个SDWebImageDownloader实例和一个SDImageCache实例，是下载与缓存的桥梁;SDWebImageDecoder负责图片的解压缩;SDWebImagePrefetcher负责图片的预取;</p>
<p>UIImageView+WebCache和其他的扩展负责给用户提供接口;</p>
</blockquote>
<p>其中，最重要的就是SDWebImageDownloader、SDImageCache、SDWebImageManager三个类，接下来我们就一步步详细分析一下这些类具体如何实现的。</p>
<p>为了便于大家从宏观上有个把握，我这里先给出项目的框架结构:</p>
<p><img src="/assets/images/SDWebImage/02.png" alt="img01"></p>
<p>从这个图我们明显可以看出来，UIImageView+WebCache和UIButton+WebCache负责为用户提供接口；SDWebImageManger负责协调Downloader和Cache，并且为UIKit层提供支持；最底层的两个类为高层抽象提供支持；我们将采用至顶向下分析的方法，一层层分析。</p>
<h2 id="接口层的实现"><strong>接口层的实现</strong></h2><h3 id="UIImageView+WebCache"><strong>UIImageView+WebCache</strong></h3><p>这里我们拿UIImageView+WebCache举例，UIButton+WebCache与此类似。UIImageView+WebCache提供的接口如下：</p>
<pre><code><span class="pp">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这些接口都调用了</p>
<pre><code><span class="pp">- <span class="params">(void)</span>sd_setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageCompletionBlock</span>)</span>completedBlock；</span>
</code></pre><p>这是一种常用的封装的方法，一个函数提供最复杂的实现，其他函数给这个函数在此基础上通过调用的时候提供默认参数，浅浅的封装一层方便用户使用。因为OC函数不支持默认参数(C++支持)，所以需要在提供几个函数包装一下。</p>
<p>这个函数的上半部分实现如下：</p>
<pre><code><span class="list">[<span class="keyword">self</span> sd_cancelCurrentImageLoad]<span class="comment">;</span>
objc_setAssociatedObject<span class="list">(<span class="keyword">self</span>, &amp;imageURLKey, url,     OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><span class="comment">;</span>

if <span class="list">(<span class="keyword">!</span><span class="list">(<span class="keyword">options</span> &amp; SDWebImageDelayPlaceholder)</span>)</span> {
    dispatch_main_async_safe<span class="list">(<span class="keyword">^</span>{
        self.image = placeholder<span class="comment">;</span>
    })</span><span class="comment">;</span>
}</span>
</code></pre><p>在加载一张图片的时候首先取消当前正在加载图片的操作，然后给当前的UIImageView关联一个对应图片的URL，关联的这个url库里本身没有用到，只是暴露出<code>- (NSURL *)sd_imageURL;</code>接口提供给用户使用；if里判断用户是否使用了<code>SDWebImageDelayPlaceholder</code>，如果没有使用就设置<code>placeholder</code>,默认情况没有设置选项，图片在加载完成之前会显示占位图，如果设置了这个选项，会在图片加载完成之后在显示占位图，关于其它选项的具体含义，可以看叶孤城的解析<a href="http://www.jianshu.com/p/6ae6f99b6c4c" title="链接" target="_blank" rel="external">这里</a>。<code>dispatch_main_async_safe</code>是SDWebImage封装的一个保证参数block在主线程执行的宏，宏的实现比较简单，这里不在解释。</p>
<p>我们具体分析一下取消操作是如何实现的，<code>[self sd_cancelCurrentImageLoad]</code>调用了父类<code>UIView+EMWebCacheOperation</code>的函数：</p>
<pre><code><span class="collection">[self sd_cancelImageLoadOperationWithKey:@<span class="string">"UIImageViewImageLoad"</span>]</span><span class="comment">;</span>
</code></pre><p>我们可以看到，这里的key是写死的，因为一个UIImageView在任何时候至多只能对应一种类型的下载操作(可以同时下载image和highlightedImage，两者的key是不一样的)。网络下载以及缓存都是比较耗费系统资源的操作，这么做可以尽量避免资源浪费。例如UITableView在滑动到需要复用UITableViewCell时，如果此时滑出屏幕之前的图片还未加载完成，就没必要在下载了。我们继续深入看父类<code>UIView+EMWebCacheOperation</code>的实现，<code>sd_cancelImageLoadOperationWithKey</code>的全部实现如下：</p>
<pre><code><span class="comment">//这里通过给Category关联属性的方式给每个UIView添加了一个NSMutableDictionary属性，保存了operation或者operation数组;operation从下面可以看出是id &lt;EMSDWebImageOperation&gt;类型,之所以用这样的类型是为了通用性，不局限于使用系统的NSOperation，用户也可以自定义自己的Operation(如SDWebImage里的用到的SDWebImageCombinedOperation)。</span>
<span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];
    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];
    <span class="keyword">if</span> (operations) {
    <span class="comment">//gif图有多张图片，多张图片对应多个operation</span>
        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> class]]) {
            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) {
                <span class="keyword">if</span> (operation) {
                    [operation cancel];
                }
            }
        } <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>{
            <span class="comment">//单个图片，直接调用cancle</span>
            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];
        }
        [operationDictionary removeObjectForKey:key];
    }
</code></pre><p>然后我们接着看sd_setImageWithURL的下半部分的实现，截取部分关键的代码：</p>
<pre><code>__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;
<span class="comment">//创建一个id &lt;SDWebImageOperation&gt;(于UIView+EMWebCacheOperation对应)类型的下载task,</span>
<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) {
          [wself removeActivityIndicator];
        <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
            <span class="comment">//如果用户不希望下载完成直接设置image，就只调用completedBlock</span>
            <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
            {
                completedBlock(image, error, cacheType, url);
                <span class="keyword">return</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (image) {
                wself<span class="variable">.image</span> = image;
                [wself setNeedsLayout];
            } <span class="keyword">else</span> {
                <span class="comment">//下载完成设置placeholder</span>
                <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) {
                    wself<span class="variable">.image</span> = placeholder;
                    [wself setNeedsLayout];
                }
            }
            <span class="keyword">if</span> (completedBlock &amp;&amp; finished) {
                completedBlock(image, error, cacheType, url);
            }
        });
    }];
<span class="comment">//将这个Operation添加到此UIImageView的字典里</span>
[<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];
</code></pre><p>接口层的实现到这里就结束了。这里有几个小问题:</p>
<ul>
<li><strong><font color="red">iOS底层如何实现Category关联属性的？</font></strong></li>
<li><strong><font color="red">iOS的Category如何关联weak属性？</font></strong></li>
</ul>
<h2 id="调度层的实现">调度层的实现</h2><p> 调度层就一个类SDWebImageManager，在头文件中描述如下：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes.<br> It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache).<br> You can use this class directly to benefit from web image downloading with caching in another context than<br> a UIView.</p>
</blockquote>
<p>意思就是SDWebImageManager是位于UIImageView+WebCache之下的用于图片异步下载和缓存的类，你也可以直接使用SDWebImageManager的函数直接下载图片。</p>
<p>SDWebImageManager是一个用dispatch_once实现的单例(关于<font color="red"><strong>dispatch_once底层如何实现的？</strong></font>也是一个有趣的话题，我们以后在讨论它),维护了一个SDImageCache实例和SDWebImageDownloader实例。提供的函数如下：</p>
<p>//初始化SDWebImageManager单例，在init方法中已经初始化了cache单例和downloader单例。</p>
<pre><code>- (instancetype)initWithCache:(SDImageCache *)cache downloader:(SDWebImageDownloader *)downloader;
<span class="comment">//下载图片</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;
<span class="comment">//缓存给定URL的图片</span>
- (<span class="keyword">void</span>)saveImageToCache:(<span class="built_in">UIImage</span> *)image forURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//取消当前所有的操作</span>
- (<span class="keyword">void</span>)cancelAll;
<span class="comment">//监测当前是否有进行中的操作</span>
- (<span class="built_in">BOOL</span>)isRunning;
<span class="comment">//监测图片是否在缓存中， 先在memory cache里面找  再到disk cache里面找</span>
- (<span class="built_in">BOOL</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否缓存在disk里</span>
- (<span class="built_in">BOOL</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否在缓存中,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                     completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//监测图片是否缓存在disk里,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                   completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//返回给定URL的cache key，默认是图片的url</span>
- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url;
</code></pre><p>定义了SDWebImageManagerDelegate协议：</p>
<pre><code><span class="comment">@protocol SDWebImageManagerDelegate </span>

<span class="comment">@optional</span>

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Controls which image should be downloaded when the image is not found in the cache.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to be downloaded</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span>
 <span class="keyword">*</span> 控制在cache中没有找到image时 是否应该去下载。默认是YES。
 <span class="keyword">*</span>/
- (BOOL)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager shouldDownloadImageForURL:(NSURL <span class="keyword">*</span>)imageURL;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.
 <span class="keyword">*</span> NOTE: This method is called from a global queue in order to not to block the main thread.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param image        The image to transform</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to transform</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return The transformed image object.</span>
 <span class="keyword">*</span> 在下载之后，缓存之前转换图片。在全局队列中操作，不阻塞主线程
 <span class="keyword">*</span>/
- (UIImage <span class="keyword">*</span>)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager transformDownloadedImage:(UIImage <span class="keyword">*</span>)image withURL:(NSURL <span class="keyword">*</span>)imageURL;

<span class="comment">@end</span>
</code></pre><p> 我们主要看下</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                        options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options
                                       progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                      completed:<span class="params">(<span class="variable">SDWebImageCompletionWithFinishedBlock</span>)</span>completedBlock</span>
</code></pre><p>这个函数返回<code>id &lt;SDWebImageOperation&gt;</code>类型保存当前UIImageView的下载操作；</p>
<p>首先检查URL是否合法：</p>
<pre><code><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) {
    url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];
}

<span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span>
<span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) {
    url = nil;
}
</code></pre><p>这两个判断都是检查用户传递参数类型是否正确；</p>
<pre><code><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;
<span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) {
    isFailedUrl = [<span class="keyword">self</span><span class="variable">.failedURLs</span> containsObject:url];
}

<span class="keyword">if</span> (url<span class="variable">.absoluteString</span><span class="variable">.length</span> == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
    dispatch_main_sync_safe(^{
        <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];
        completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
    });
    <span class="keyword">return</span> operation;
}
</code></pre><p>若URL对应的image之前下载失败过并且用户没有设置错误重试，直接调用completedBlock；</p>
<pre><code><span class="variable">@synchronized</span> (self.runningOperations) {
    <span class="attr_selector">[self.runningOperations addObject:operation]</span>;
}
</code></pre><p>把当前下载操作加入到runningOperations中，因为runningOperations是多线程共享的，所以要加synchronized控制并发；<strong>synchronized底层是如何实现的呢？</strong>我们在以后的文章里去探究。</p>
<p>SDWebImageManager首先去检查cache(memeory &amp;&amp; disk)中是否缓存过要下载的图片，调用imageCache的</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSOperation</span> *)</span>queryDiskCacheForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key done:<span class="params">(<span class="variable">SDWebImageQueryCompletedBlock</span>)</span>doneBlock</span>
</code></pre><p>函数里首先判断当前操作是否被取消，如果取消从runningOperations中移除，并直接返回：</p>
<pre><code><span class="tag">if</span> (operation.isCancelled) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="attr_selector">[self.runningOperations removeObject:operation]</span>;
    }

    return;
}
</code></pre><p>接下来需要讨论二种情况情况：1.（缓存未找到图片）或（缓存找到了图片但是用户设置了刷新缓存） 2. （用户没有实现shouldDownloadImageForURL协议）或（用户实现了shouldDownloadImageForURL协议并且返回值是YES）</p>
<pre><code>if <span class="list">(<span class="list">(!image || options &amp; SDWebImageRefreshCached)</span> <span class="keyword">&amp;&amp;</span> <span class="list">(![self.delegate respondsToSelector:@selector<span class="list">(<span class="keyword">imageManager</span><span class="keyword">:shouldDownloadImageForURL</span>:)</span>] || [self.delegate imageManager<span class="keyword">:self</span> shouldDownloadImageForURL<span class="keyword">:url</span>])</span>)</span>
</code></pre><p>这两种情况下需要下载图片，上面这一坨就是判断上面的二种情况。</p>
<p>除了上面二种情况还有不需要下载图片的二种情况：1.缓存找到图片 2.缓存未找到图片并且用户禁止下载：</p>
<pre><code><span class="comment">//第一种情况，缓存找到图片(用户未设置刷新缓存并且用户未禁止下载)</span>
<span class="keyword">else</span> <span class="keyword">if</span> (image) {
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) {
            completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
<span class="comment">//第二种情况(缓存未找到且用户通过delegate设置在缓存未找到时禁止下载图片)</span>
<span class="keyword">else</span> {
    <span class="comment">// Image not in cache and download disallowed by delegate</span>
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation<span class="variable">.isCancelled</span>) {
            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
</code></pre><p>如果需要下载图片，就调用</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock</span>
</code></pre><p>下载图片，如果下载失败。直接调用completedBlock返回错误，并根据错误类型将URL添加到failedURLs里。</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">error</span>) {
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(nil, <span class="built_in">error</span>, SDImageCacheTypeNone, finished, url);
        }
    });

    <span class="keyword">if</span> (   <span class="built_in">error</span>.code != NSURLErrorNotConnectedToInternet
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCancelled
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorTimedOut
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorInternationalRoamingOff
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorDataNotAllowed
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotFindHost
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotConnectToHost) {
        @synchronized (<span class="variable">self</span>.failedURLs) {
            [<span class="variable">self</span>.failedURLs addObject:url];
        }
    }
}
</code></pre><p>若图片下载成功，将url从failURLs里删除：</p>
<pre><code><span class="tag">if</span> ((options &amp; SDWebImageRetryFailed)) {
    <span class="variable">@synchronized</span> (self.failedURLs) {
        <span class="attr_selector">[self.failedURLs removeObject:url]</span>;
    }
}
</code></pre><p>这个地方需要解释下，因为<code>[self.failedURLs addObject:url]</code>是<strong>只在下载失败时添加</strong>的，而下载成功和下载失败是互斥的，也就是说，下载成功时failedURLs数组里就不应该有这个url，为什么要这么写呢，这是为了解决竞态条件下的问题，若两个线程下载同一个url的图片，若第一个线程下载失败，第二个下载成功。如果不从failedURLs移除这个url的话，以后下载此url的图片都会失败。</p>
<p>然后处理下载完成的图片：</p>
<pre><code><span class="comment">//是否设置了只缓存内存</span>
BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

<span class="comment">//设置刷新缓存且cache找到图片且NSURLCache找到图片，不处理</span>
<span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) {
    <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span>
}
<span class="comment">//若delegate实现imageManager:transformDownloadedImage:withURL:方法，在缓存之前，需要做调用此delegate方法转换</span>
<span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="annotation">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) {
    <span class="comment">//在全局队列中转换，不阻塞主线程dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{</span>
        UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];
        <span class="comment">//转换成功后，存入缓存</span>
        <span class="keyword">if</span> (transformedImage &amp;&amp; finished) {
            BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];
            [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">recalculateFromImage:</span>imageWasTransformed <span class="string">imageData:</span>(imageWasTransformed ? nil : data) <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
        }
        <span class="comment">//缓存成功之后，调用completedBlock</span>
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
                completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);
            }
        });
    });
}
<span class="keyword">else</span> {
    <span class="comment">//没有实现转换的delegate，就不做转换直接缓存</span>
    <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) {
        [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
    }
    <span class="comment">//缓存成功之后，调用completedBlock</span>
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);
        }
    });
}
</code></pre><p>}</p>
<p>下载完成之后，从队列里移除：</p>
<pre><code><span class="tag">if</span> (finished) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="tag">if</span> (strongOperation) {
            <span class="attr_selector">[self.runningOperations removeObject:strongOperation]</span>;
        }
    }
}
</code></pre><p>最后说下返回的<code>SDWebImageCombinedOperation</code>类型，这个类型包含<code>NSOperation *cacheOperation</code>的一个子类型，其中<code>cacheOperation</code>中又存在<code>id &lt;SDWebImageOperation&gt;</code>的下载图片的<code>subOperation</code>。在<code>cancel</code>的时候也应该把这两个操作都<code>cancle</code>。</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">self</span><span class="variable">.cancelled</span> = <span class="literal">YES</span>;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cacheOperation</span>) {
        [<span class="keyword">self</span><span class="variable">.cacheOperation</span> cancel];
        <span class="keyword">self</span><span class="variable">.cacheOperation</span> = <span class="literal">nil</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) {
        <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

        <span class="comment">// <span class="doctag">TODO:</span> this is a temporary fix to #809.</span>
        <span class="comment">// Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span>
<span class="comment">//        self.cancelBlock = nil;</span>
        _cancelBlock = <span class="literal">nil</span>;
    }
}
</code></pre><p>所以<code>CombinedOperation</code>在<code>cancel</code>的时候会先cancel掉自己的<code>cacheOperation</code>,在调用自己的<code>cancelBlock</code>。</p>
<pre><code><span class="label">operation.cancelBlock</span> = ^{
    [<span class="keyword">subOperation </span>cancel]<span class="comment">;</span>


    <span class="comment">@synchronized (self.runningOperations) {</span>
        __strong __typeof(weakOperation) <span class="keyword">strongOperation </span>= weakOperation<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">strongOperation) </span>{
            [<span class="keyword">self.runningOperations </span>removeObject:<span class="keyword">strongOperation];
</span>        }
    }
}<span class="comment">;</span>
</code></pre><p>在自己的<code>cancelBlock</code>把下载操作<code>subOperation</code>取消掉。由此可见封装的<code>CombinedOperation</code>包含了下载和缓存的操作，使代码变得更简洁。</p>
<h2 id="下载和缓存层"><strong>下载和缓存层</strong></h2><h3 id="下载层SDWebImageDownloader"><strong>下载层SDWebImageDownloader</strong></h3><p>SDWebImageDownloader提供的方法有以下几个：</p>
<pre><code><span class="comment">//给每个HTTP下载请求头的指定field设置值。</span>
- (<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//返回HTTP特定field的值</span>
- (<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//设置一个SDWebImageDownloaderOperation的子类作为下载请求的默认NSOperation</span>
- (<span class="keyword">void</span>)setOperationClass:(Class)operationClass;
<span class="comment">//创建一个SDWebImageDownloader异步下载实例，图片下载完成或错误时，通知delegate回调。方法返回一个 SDWebImageOperation</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                     options:(SDWebImageDownloaderOptions)options
                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
<span class="comment">// 设置下载队列为挂起状态</span>
- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended;
<span class="comment">//取消队列中的所有操作。</span>
- (<span class="keyword">void</span>)cancelAllDownloads;
</code></pre><p>我们重点研究下载方法：</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                     options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
                                    progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                   completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这几个参数的含义代码注释里都有，这里就不再一一解释。</p>
<pre><code>__block SDWebImageDownloaderOperation *operation;
__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;

[<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
    <span class="comment">//block实现</span>
    ...
    operation = [[wself<span class="variable">.operationClass</span> alloc] initWithRequest:request
                                                      options:options
                                                     progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize)
    ...
}];

<span class="keyword">return</span> operation;
</code></pre><p>上面是这个方法的框架，可以看出主要调用了<code>addProgressCallback</code>方法，方法的内部创建了下载的<code>operation</code>。我们首先看看<code>addProgressCallback</code>方法的实现:</p>
<pre><code><span class="comment">//如果url为nil，调用completedBlock后return</span>
<span class="keyword">if</span> (url == <span class="literal">nil</span>) {
    <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) {
        completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
    }
    <span class="keyword">return</span>;
}

<span class="comment">//允许多线程下载，使用了并发控制，避免同时修改URLCallbacks</span>
dispatch_barrier_sync(<span class="keyword">self</span><span class="variable">.barrierQueue</span>, ^{
    <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;
    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url]) {
        <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = [<span class="built_in">NSMutableArray</span> new];
        first = <span class="literal">YES</span>;
    }

    <span class="comment">// Handle single download of simultaneous download request for the same URL</span>
    <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url];
    <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];
    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];
    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];
    [callbacksForURL addObject:callbacks];
    <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = callbacksForURL;

    <span class="keyword">if</span> (first) {
        createCallback();
    }
});
</code></pre><p>这里的并发控制的地方为什么要使用<code>dispatch_barrier_sync</code>，是因为<code>dispatch_barrier_sync</code>这个函数可以设置一个同步执行block，它会等到在这个block加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。。这里的<code>dispatch_barrier_sync</code>实际上相当于一个写锁，任何写操作(删除，添加)，都要在之前的写操作完成后执行，而之后的写操作，也要在之前的的写操作完成之后执行。</p>
<p>URLCallbacks是一个以url作为key的字典，字典的value是一个数组，数组的元素是一个字典。可以看出<code>URLCallbacks</code>、<code>callbacksForURL</code>、<code>callbacks</code>之间的关系如下图：</p>
<p><img src="/assets/images/SDWebImage/03.png" alt="img01"></p>
<p>如果URLCallbacks以url对应的value是空，说明是第一次请求这个url，需要调用<code>createCallback</code>创建下载任务，即调用：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
        inSession:<span class="params">(<span class="variable">NSURLSession</span> *)</span>session
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>设置默认超时时间15s，然后使用此<code>request</code>创建一个<code>SDWebImageDownloaderOperation</code>,方便把这个下载任务添加到下载队列里：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>重点看下这个方法的三个block，第一个progress，取出存储在URLCallbacks中的progressBlock并调用：</p>
<pre><code><span class="comment">//只是读操作，dispatch_sync即可</span>
 <span class="built_in">dispatch_sync</span>(sself<span class="variable">.barrierQueue</span>, ^{
     callbacksForURL = [sself<span class="variable">.URLCallbacks</span>[url] <span class="keyword">copy</span>];
 });
 <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) {
     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
         SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
         <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);
     });
 }
</code></pre><p>同理，<code>completed</code>也是从URLCallbacks中的completedBlock并调用：</p>
<pre><code><span class="comment">//这里有写操作，须用dispatch_barrier_sync</span>
dispatch_barrier_sync(sself.barrierQueue, ^{
    callbacksForURL = [sself.URLCallbacks[url] copy];
    <span class="keyword">if</span> (finished) {
        [sself.URLCallbacks removeObjectForKey:url];
    }
});
<span class="keyword">for</span> (NSDictionary *callbacks <span class="keyword">in</span> callbacksForURL) {
    <span class="comment">//这里为什么不像progressBlock一样使用dispatch_async(dispatch_get_main_queue()？</span>
    SDWebImageDownloaderCompletedBlock <span class="keyword">callback</span> = callbacks[kCompletedCallbackKey];
    <span class="keyword">if</span> (<span class="keyword">callback</span>) <span class="keyword">callback</span>(image, data, error, finished);
}
</code></pre><p>不同图片的下载任务会异步完成，所以要等待其他图片下载完成，并执行完<code>completedBlock</code>中对<code>URLCallbacks</code>的操作，才能继续之后的操作。</p>
<pre><code>cancelled:^{
    SDWebImageDownloader *sself = wself<span class="comment">;</span>
    if (!sself) return<span class="comment">;</span>
    dispatch_barrier_async(sself.barrierQueue, ^{
        [sself.URLCallbacks removeObjectForKey:url]<span class="comment">;</span>
    })<span class="comment">;</span>
}
</code></pre><p>取消时用的<code>dispatch_barrier_async</code>,dispatch_barrier_async表示的是先等之前的执行完成，然后把该barrier放入queue中，而不等待barrier中代码执行结束，而dispat_barrier_sync表示需要等待barrier中代码执行结束。</p>
<p>然后设置operation</p>
<pre><code><span class="comment">//是否解压下载的图片</span>
operation.shouldDecompressImages = wself.shouldDecompressImages;
<span class="comment">//有证书设置证书</span>
<span class="keyword">if</span> (wself.urlCredential) {
    operation.credential = wself.urlCredential;
} <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) {
    operation.credential = [NSURLCredential <span class="string">credentialWithUser:</span>wself.username <span class="string">password:</span>wself.password <span class="string">persistence:</span>NSURLCredentialPersistenceForSession];
}
<span class="comment">//设置优先级</span>
<span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) {
    operation.queuePriority = NSOperationQueuePriorityHigh;
} <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) {
    operation.queuePriority = NSOperationQueuePriorityLow;
}

[wself.downloadQueue <span class="string">addOperation:</span>operation];
<span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
    <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span>
    [wself.lastAddedOperation <span class="string">addDependency:</span>operation];
    wself.lastAddedOperation = operation;
}
</code></pre><p>最后将这个下载的操作加入到下载队列里。下载方式有两种，FIFO和LIFO。最后根据下载的方式调增任务的依赖。</p>
<h4 id="具体的下载操作SDWebImageDownloaderOperation"><strong>具体的下载操作SDWebImageDownloaderOperation</strong></h4><p>上面的<code>SDWebImageDownloader</code>主要操作就是创建<code>SDWebImageDownloaderOperation</code>添加到下载队列里，可知具体的操作是在<code>SDWebImageDownloaderOperation</code>，我们研究下具体是如何下载的。首先这个类是继承于<code>NSOperation</code>，并重写了<code>start</code>方法。我们首先看看它的<code>start</code>方法的实现：</p>
<p>检测下载状态</p>
<pre><code><span class="comment">//管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span>
<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) {
    <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    [<span class="keyword">self</span> reset];
    <span class="keyword">return</span>;
}
</code></pre><p>如果是iOS4.0以上的版本，需要设置后台执行的操作：</p>
<pre><code><span class="comment">//作为具体的下载操作，尽量不依赖其他类，所以这里使用字符串创建</span>
Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);
<span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];
<span class="comment">//如果用户设置了后台下载</span>
<span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) {
    <span class="comment">//如果设置了在后台执行，则进行后台执行</span>
     __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    <span class="comment">//向系统申请更长的时间执行下载操作</span>
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = [app beginBackgroundTaskWithExpirationHandler:^{
        <span class="comment">// 如果在系统规定时间内任务还没有完成（一般是10分钟），结束后台任务</span>
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;
        <span class="keyword">if</span> (sself) {
            [sself cancel];
            [app endBackgroundTask:sself<span class="variable">.backgroundTaskId</span>];
            sself<span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
        }
    }];
｝
</code></pre><p>这里注册的block会在APP进入后台时执行，block里调用<code>cancel</code>对应的<code>endBackgroundTask</code>,这个block的主要目的是持有<code>self</code>不要被系统销毁，只要<code>self</code>不被系统销毁，当前下载操作就可以继续执行。<code>self</code>被销毁后，我们看看<code>cancel</code>操作做了什么：</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.thread</span>) {
            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelInternalAndStop) onThread:<span class="keyword">self</span><span class="variable">.thread</span> withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];
        }
        <span class="keyword">else</span> {
            [<span class="keyword">self</span> cancelInternal];
        }
    }
}

- (<span class="keyword">void</span>)cancelInternalAndStop {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">self</span> cancelInternal];
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
}

- (<span class="keyword">void</span>)cancelInternal {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">super</span> cancel];
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.connection</span>) {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
        });

        <span class="comment">// As we cancelled the connection, its callback won't be called and thus won't</span>
        <span class="comment">// maintain the isFinished and isExecuting flags.</span>
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isExecuting</span>) <span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">NO</span>;
        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    }

    [<span class="keyword">self</span> reset];
}
</code></pre><p>底下有三个和<code>cancel</code>相关的操作，如果当前线程存在，在当前线程调用<code>cancelInternalAndStop</code>，否者调用<code>cancelInternal</code>;这两者的区别是<code>cancelInternalAndStop</code>中多了一句<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>,在中止当前线程的时候，也要关闭对应的RunLoop。<code>cancelInternal</code>做了几件事：</p>
<ul>
<li>调用自定义的cancelBlock</li>
<li>调用NSURLConnection的cancel取消self.connection</li>
<li>回收资源</li>
<li>抛出通知</li>
</ul>
<p>注册的后台操作是在进入到后台如果<code>NSOperation</code>未执行完成才执行的，假如在进入到后台之前<code>NSOperation</code>已经完成了呢？</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.backgroundTaskId</span> != <span class="built_in">UIBackgroundTaskInvalid</span>) {
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    [app endBackgroundTask:<span class="keyword">self</span><span class="variable">.backgroundTaskId</span>];
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
}
</code></pre><p>如果下载任务完成，中止后台操作，将backgroundTaskId置为UIBackgroundTaskInvalid。</p>
<p>注册后台操作的准备工作完成之后，就该开始下载了：</p>
<pre><code><span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">YES</span>;
<span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span><span class="variable">.request</span> delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];
<span class="keyword">self</span><span class="variable">.thread</span> = [<span class="built_in">NSThread</span> currentThread];
</code></pre><p>初始化相关的数据，创建<code>NSURLConnection</code>,如果创建失败就调用<code>completedBlock</code>,成功就启动下载，关键代码如下：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
    <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);
}
....
<span class="built_in">CFRunLoopRun</span>();
....
<span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) {
    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    [<span class="keyword">self</span> connection:<span class="keyword">self</span><span class="variable">.connection</span> didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@{<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>}]];
}
</code></pre><p>使用<code>NSURLConnection</code>调用了<code>[self.connection start]</code>后，<code>NSURLConnection</code>的delegate就会不停收到事件回调。当这个connection完成或者终止，才会跳出CFRunLoopRun()(可以理解为CFRunLoopRun阻塞了当前线程)。当跳出Runloop后，就要判断NSURLConnection是不是正常完成任务了。如果没有，也就是说self.isFinished == NO。那么就取消该connection，并且调用</p>
<pre><code>(<span class="typename">void</span>)<span class="string">connection:</span>(NSURLConnection *)connection <span class="string">didFailWithError:</span>(NSError *)error;
</code></pre><p>返回错误信息。然后就是<code>NSURLConnection</code>几个delegate过程的处理：</p>
<pre><code><span class="comment">//如果是304代表服务端资源未改变，可直接使用客户端未过期的资源，此时需要取消operation并返回缓存中的image，code小于400说明请求成功</span>
<span class="comment">//如果响应成功，开始初始化数组，准备接收imageData</span>
<span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] != <span class="number">304</span>)) {
    <span class="built_in">NSInteger</span> expected = response<span class="variable">.expectedContentLength</span> &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response<span class="variable">.expectedContentLength</span> : <span class="number">0</span>;
    <span class="keyword">self</span><span class="variable">.expectedSize</span> = expected;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
        <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, expected);
    }

    <span class="keyword">self</span><span class="variable">.imageData</span> = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];
    <span class="keyword">self</span><span class="variable">.response</span> = response;
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];
    });
}
<span class="comment">//请求失败之后，抛通知并清理相关资源</span>
<span class="keyword">else</span> {
    <span class="built_in">NSUInteger</span> code = [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode];

    <span class="comment">//This is the case when server returns '304 Not Modified'. It means that remote image is not changed.</span>
    <span class="comment">//In case of 304 we need just cancel the operation and return cached image from the cache.</span>
    <span class="keyword">if</span> (code == <span class="number">304</span>) {
        [<span class="keyword">self</span> cancelInternal];
    } <span class="keyword">else</span> {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    }
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
    });

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="keyword">self</span><span class="variable">.completedBlock</span>(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:[((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] userInfo:<span class="literal">nil</span>], <span class="literal">YES</span>);
    }
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
    [<span class="keyword">self</span> done];
}
</code></pre><p>然后在下载过程中接收数据，以下是部分代码：</p>
<pre><code><span class="keyword">if</span> (partialImageRef) {
    <span class="comment">//把data转换成image</span>
    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:partialImageRef scale:<span class="number">1</span> orientation:orientation];
    <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>];
    <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];
    <span class="comment">//判断是否要解解码，默认是需要解码，解码的操作是在子线程里(delegate在子线程执行的),为什么要解码？我们之后解释</span>
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) {
        image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];
    }
    <span class="keyword">else</span> {
        image = scaledImage;
    }
    <span class="built_in">CGImageRelease</span>(partialImageRef);
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="comment">//显示在imageView上（不一定下载完，可以显示一部分）</span>
            <span class="keyword">self</span><span class="variable">.completedBlock</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
        }
    });
}
</code></pre><blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<h3 id="缓存层SDImageCache">缓存层SDImageCache</h3><p>我们看下<code>SDWebImage</code>的缓存<code>SDImageCache</code>，<code>SDImageCache</code>主要包含两部分，内存缓存<code>memCache</code>和磁盘缓存<code>fileManager</code>,磁盘缓存的写操作是异步的。</p>
<blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI. </p>
</blockquote>
<p>内存缓存是使用<code>NSCache</code>实现的，<code>NSCache</code>使用上类似字典，可以用key-Value的方式存取数据。但是NSCache底层实现和<code>NSDictionary</code>不同(NSCache是线程安全的)。<code>NSCache</code>的具体介绍可以看<a href="http://nshipster.cn/nscache/" target="_blank" rel="external">NSCache</a>。</p>
<p>先看看<code>SDImageCache</code>的属性：</p>
<pre><code><span class="comment">//是否解压下载的图片，默认是YES,但是会消耗掉很多内存，如果遇到内存不足的crash时，将值设为NO</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;
<span class="comment">//是否自动上传iCloud</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;
<span class="comment">//使用内存缓存</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;
<span class="comment">//内存缓存的代价（占用的内存大小）</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCost;
<span class="comment">//内存缓存的最大元素个数</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCountLimit;
<span class="comment">//元素在缓存中最大寿命</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;
<span class="comment">//最大缓存大小</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;
</code></pre><p>前面<code>SDWebImageManager</code>在下载图片成功时，会调用</p>
<pre><code>[self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk]
</code></pre><p>缓存到内存和磁盘，我们重点看下这个函数的实现:</p>
<pre><code><span class="comment">//错误处理</span>
<span class="keyword">if</span> (!image || !key) {
    <span class="keyword">return</span>;
}
<span class="comment">//需要内存缓存，计算内存占用，直接缓存</span>
<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldCacheImagesInMemory</span>) {
    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);
    [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:image forKey:key cost:cost];
}

<span class="comment">//需要磁盘异步缓存</span>
<span class="keyword">if</span> (toDisk) {
    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^{
        <span class="built_in">NSData</span> *data = imageData;

        <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) {
<span class="preprocessor">#if TARGET_OS_IPHONE</span>
            <span class="comment">//确定图片是png还是jpeg. imageData为nil而且有alapha通道，当作png处理</span>
            <span class="keyword">int</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(image<span class="variable">.CGImage</span>);
            <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == k<span class="built_in">CGImageAlphaNone</span> ||
                              alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||
                              alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);
            <span class="built_in">BOOL</span> imageIsPng = hasAlpha;

            <span class="comment">// But if we have an image data, we will look at the preffix</span>
            <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) {
                imageIsPng = ImageDataHasPNGPreffix(imageData);
            }
            <span class="comment">//根据类型返回image的data</span>
            <span class="keyword">if</span> (imageIsPng) {
                data = <span class="built_in">UIImagePNGRepresentation</span>(image);
            }
            <span class="keyword">else</span> {
                data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);
            }
<span class="preprocessor">#else</span>
            data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image<span class="variable">.representations</span> usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];
<span class="preprocessor">#endif</span>
        }
        <span class="comment">//磁盘存储</span>
        <span class="keyword">if</span> (data) {
            <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) {
                [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];
            }

            <span class="comment">// 获取缓存路径</span>
            <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];
            <span class="comment">// transform to NSUrl</span>
            <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];
            <span class="comment">//存储到disk里</span>
            [_fileManager createFileAtPath:cachePathForKey contents:data attributes:<span class="literal">nil</span>];

            <span class="comment">// disable iCloud backup</span>
            <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDisableiCloud</span>) {
                [fileURL setResourceValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];
            }
        }
    });
}
</code></pre><p>同样的。<code>SDWebImageManager</code>在下载之前会检查缓存是否有此图片：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSOperation</span> *)</span>queryDiskCacheForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key done:<span class="params">(<span class="variable">SDWebImageQueryCompletedBlock</span>)</span>doneBlock</span>
</code></pre><p>关键代码如下：</p>
<pre><code><span class="comment">//从内存缓存里查找</span>
<span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];
<span class="keyword">if</span> (image) {
    doneBlock(image, SDImageCacheTypeMemory);
    <span class="keyword">return</span> <span class="literal">nil</span>;
}

<span class="comment">//NSOperation的特殊用法，用于取消一个异步操作</span>
<span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];
<span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^{
    <span class="keyword">if</span> (operation<span class="variable">.isCancelled</span>) {
        <span class="keyword">return</span>;
    }

    <span class="comment">//disk查找图片成功之后需要解码，所以放在`autoreleasepool`里</span>
    <span class="keyword">@autoreleasepool</span> {
        <span class="comment">//从磁盘查找，解码</span>
        <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];
        <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span><span class="variable">.shouldCacheImagesInMemory</span>) {
            <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);
            [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:diskImage forKey:key cost:cost];
        }
        <span class="comment">//查找完成</span>
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            doneBlock(diskImage, SDImageCacheTypeDisk);
        });
    }
});
</code></pre><p>最后还有一个Cache清除的方式，对于memory cache来说是完全清空的，对于disk cache，根据设置参数的不同，有两种清除方式：</p>
<ul>
<li>文件的缓存有效期：默认是一周。如果文件的缓存时间超过这个时间值，则将其移除。</li>
<li>最大缓存空间大小：如果所有缓存文件的总大小超过最大缓存空间，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
</ul>
<h2 id="底层支持(工具类)">底层支持(工具类)</h2><h3 id="SDWebImageDecoder和SDWebImageCompat">SDWebImageDecoder和SDWebImageCompat</h3><p><code>SDWebImageDecoder</code>是用来图片解码的，在上面下载的时候和磁盘读取图片数据时，都调用了解码操作，图片为什么需要解码，可以参考如下解释:</p>
<blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<p><code>SDWebImageCompat</code>是根据屏幕大小设置图片的<code>scale</code>，实现比较简单，这里不再解释。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/27/SDWebImage源码阅读-一/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 頁 共 1 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 刘得胜. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">刘得胜</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2015/11/24/Hello-World-0/">
                            <h3 class="media-heading">Hello World</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Nov 24, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/01/30/Xcode升级之后Alcatraz和插件失效/">
                            <h3 class="media-heading">Xcode升级之后Alcatraz和插件失效</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 30, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/02/07/不经意间/">
                            <h3 class="media-heading">你在哪里</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Feb 7, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/02/12/nil0Nil0NULL0null0nullptr0NSNull/">
                            <h3 class="media-heading">nil/Nil/NULL/NUL/nullptr/NSNull</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Feb 12, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/03/12/hello-world/">
                            <h3 class="media-heading">MarkDown语法学习</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Mar 12, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/04/17/iOS静态代码检查/">
                            <h3 class="media-heading">iOS静态代码检查</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Apr 17, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/04/28/JSPatch使用笔记/">
                            <h3 class="media-heading">JSPatch使用笔记</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Apr 28, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/05/29/iOS数据结构-实现NSMutableArray/">
                            <h3 class="media-heading">iOS数据结构(一):实现NSMutableArray</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 29, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/06/02/Swift-Name-Mangling/">
                            <h3 class="media-heading">Name Mangling</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jun 2, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/09/09/关于iOS组件化方案的思考/">
                            <h3 class="media-heading">关于iOS组件化方案的思考</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Sep 9, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 16 篇文章
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js" type="text/javascript"></script>
<script src="/assets/js/tranquilpeak.js" type="text/javascript"></script>
<!--SCRIPTS END-->



    </body>
</html>
