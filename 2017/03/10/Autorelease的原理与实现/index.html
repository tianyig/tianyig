<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Autorelease的原理与实现 | 得胜的技术博客，谢谢关注</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言众所周知，在C/C++中内存管理是非常重要的内容，内存管理是C／C++程序员的基本功，为了方便内存管理，C++的库(STL&amp;amp;&amp;amp;Boost)提供了各种智能指针的实现。同样在iOS MRC时代，iOS的开发也是需要手动内存管理，手动内存管理麻烦而且容易出错，严重影响程序健壮性和开发效率。为了改善这种情况，苹果在iOS5推出了新功能ARC(Automatic Reference Co">
<meta property="og:type" content="article">
<meta property="og:title" content="Autorelease的原理与实现">
<meta property="og:url" content="http://yoursite.com/2017/03/10/Autorelease的原理与实现/index.html">
<meta property="og:site_name" content="得胜的技术博客，谢谢关注">
<meta property="og:description" content="前言众所周知，在C/C++中内存管理是非常重要的内容，内存管理是C／C++程序员的基本功，为了方便内存管理，C++的库(STL&amp;amp;&amp;amp;Boost)提供了各种智能指针的实现。同样在iOS MRC时代，iOS的开发也是需要手动内存管理，手动内存管理麻烦而且容易出错，严重影响程序健壮性和开发效率。为了改善这种情况，苹果在iOS5推出了新功能ARC(Automatic Reference Co">
<meta property="og:image" content="http://yoursite.com/assets/images/autorelease/AutoreleasePoolPage1.png">
<meta property="og:image" content="http://yoursite.com/assets/images/autorelease/AutoreleasePoolPage2.png">
<meta property="og:image" content="http://yoursite.com/assets/images/autorelease/page3.jpeg">
<meta property="og:image" content="http://yoursite.com/assets/images/autorelease/page4.jpeg">
<meta property="og:image" content="http://yoursite.com/assets/images/autorelease/page5.jpeg">
<meta property="og:updated_time" content="2017-03-13T02:13:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Autorelease的原理与实现">
<meta name="twitter:description" content="前言众所周知，在C/C++中内存管理是非常重要的内容，内存管理是C／C++程序员的基本功，为了方便内存管理，C++的库(STL&amp;amp;&amp;amp;Boost)提供了各种智能指针的实现。同样在iOS MRC时代，iOS的开发也是需要手动内存管理，手动内存管理麻烦而且容易出错，严重影响程序健壮性和开发效率。为了改善这种情况，苹果在iOS5推出了新功能ARC(Automatic Reference Co">
  
    <link rel="alternative" href="/atom.xml" title="得胜的技术博客，谢谢关注" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xorsh.com1.z0.glb.clouddn.com/headIcon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">刘得胜</a></h1>
		</hgroup>

		
		<p class="header-subtitle">这城市华灯初上，多两个人悲剧散场</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/iOS开发/" style="font-size: 20px;">iOS开发</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/大并发服务器/" style="font-size: 15px;">大并发服务器</a> <a href="/tags/学术/" style="font-size: 10px;">学术</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/标签/" style="font-size: 10px;">标签</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/源码阅读/" style="font-size: 10px;">源码阅读</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">刘得胜</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xorsh.com1.z0.glb.clouddn.com/headIcon.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">刘得胜</h1>
			</hgroup>
			
			<p class="header-subtitle">这城市华灯初上，多两个人悲剧散场</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Autorelease的原理与实现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/10/Autorelease的原理与实现/" class="article-date">
  	<time datetime="2017-03-10T05:32:24.000Z" itemprop="datePublished">2017-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Autorelease的原理与实现
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><strong>前言</strong></h2><p>众所周知，在C/C++中内存管理是非常重要的内容，内存管理是C／C++程序员的基本功，为了方便内存管理，C++的库(STL&amp;&amp;Boost)提供了各种智能指针的实现。同样在iOS MRC时代，iOS的开发也是需要手动内存管理，手动内存管理麻烦而且容易出错，严重影响程序健壮性和开发效率。为了改善这种情况，苹果在iOS5推出了新功能ARC(Automatic Reference Counting)。ARC是如何实现的？objc和编译器底层帮我们做了哪些事情，它们是如何管理内存的？</p>
<h2 id="Autorelease"><strong>Autorelease</strong></h2><p>在MRC时代，<code>alloc</code>创建的对象必须在对象生命周期结束时调用<code>release</code>或者在创建之初调用<code>autorelease</code>。如下：</p>
<pre><code>方式1
NSObject *testObj = <span class="comment">[<span class="comment">[NSObject alloc]</span>init]</span>;
//insert code
<span class="comment">[testObj release]</span>;

方式2
NSObject *testObj = <span class="comment">[<span class="comment">[<span class="comment">[NSObject alloc]</span>init]</span> autorelease]</span>;
</code></pre><p>内存管理的第一原则：谁创建，谁释放。所以方式1我们很容易理解；方式2是如何管理对象的生命周期的？其实调用<code>autorelease</code>方法其实是把当前对象添加到<code>autoreleasepool</code>中管理，我们就不需要手动释放了。</p>
<h2 id="@autoreleasepool"><strong>@autoreleasepool</strong></h2><p>iOS工程<code>main.m</code>中<code>main</code>函数的实现如下：</p>
<pre><code><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {  
    <span class="keyword">@autoreleasepool</span> {
        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));
    }
}
</code></pre><p>main函数的的业务实现我们不关心，我们只关心<code>@autoreleasepool</code>到底是什么，为了方便，我们改写main函数如下：</p>
<pre><code><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="built_in">NSObject</span> *objTest = [[<span class="built_in">NSObject</span> alloc]init];
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>在命令行中使用<code>clang -rewrite-objc main.m</code>让编译器用<code>C++</code>改写这个函数,改写后的代码简化如下：</p>
<pre><code><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {
    <span class="comment">/* @autoreleasepool */</span> { __AtAutoreleasePool __autoreleasepool; 
        <span class="built_in">NSObject</span> *objTest = ((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p><code>@autoreleasepool</code>在改写后被注释掉了，同时在作用域的第一行生成了一个<code>__AtAutoreleasePool</code>的C++对象，全局搜索可以看到<code>__AtAutoreleasePool</code>定义如下：</p>
<pre><code>struct __AtAutoreleasePool {
  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush()<span class="comment">;}</span>
  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj)<span class="comment">;}</span>
  void * atautoreleasepoolobj<span class="comment">;</span>
}<span class="comment">;</span>
</code></pre><p>这个结构体(和class的唯一区别是不能定义私有变量或私有函数)只有一个构造函数和析构函数，析构函数是在作用域结束时自动调用的，所以<code>main</code>函数代码等价如下：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{  
    {
        <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();
        <span class="comment">//other operator</span>
         objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>然后看下这两个函数的实现：</p>
<pre><code><span class="function"><span class="keyword">void</span> *
<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">return</span> AutoreleasePoolPage::push();
}

<span class="function"><span class="keyword">void</span>
<span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span>
</span>{
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre><p>可以看出只是简单的对<code>AutoreleasePoolPage</code>的封装。<code>AutoreleasePoolPage</code>又是什么？下面就从它的结构和实现上逐步剖析<code>AutoreleasePoolPage</code>。</p>
<h3 id="AutoreleasePoolPage的结构"><em>AutoreleasePoolPage的结构</em></h3><p>它的结构如下：</p>
<pre><code><span class="keyword">class</span> AutoreleasePoolPage {  
    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;
    id *next;
    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;
    AutoreleasePoolPage * <span class="keyword">const</span> parent;
    AutoreleasePoolPage *child;
    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;
    <span class="keyword">uint32_t</span> hiwat;
};
</code></pre><ol>
<li>magic 用来校验 AutoreleasePoolPage 的结构是否完整；</li>
<li>next 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；</li>
<li>thread 指向当前线程；</li>
<li>parent 指向父结点，第一个结点的 parent 值为 nil ；</li>
<li>child 指向子结点，最后一个结点的 child 值为 nil ；</li>
<li>depth 代表深度，从 0 开始，往后递增 1；</li>
<li>hiwat 代表 high water mark。</li>
</ol>
<h3 id="push操作"><em>push操作</em></h3><p><code>objc_autoreleasePoolPush()</code>函数实际上调用了<code>AutoreleasePoolPage::push()</code>函数。</p>
<pre><code><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> 
</span>{
    id *dest;
    dest = autoreleaseFast(POOL_BOUNDARY);
    <span class="keyword">return</span> dest;
}
</code></pre><p>其中<code>POOL_BOUNDARY</code>是<code>nil</code>的宏定义</p>
<pre><code><span class="preprocessor">#   <span class="keyword">define</span> POOL_BOUNDARY nil`</span>
</code></pre><p>在首次创建AutoRelease Pool的时候插入一个nil值表示嵌套的<code>AutoreleasePool</code>的边界。</p>
<p>push函数调又<code>autoreleaseFast</code>实现具体的插入：</p>
<pre><code>static <span class="keyword">inline</span> id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    <span class="keyword">if</span> (page <span class="subst">&amp;&amp;</span> <span class="subst">!</span>page<span class="subst">-&gt;</span><span class="literal">full</span>()) {
        <span class="keyword">return</span> page<span class="subst">-&gt;</span>add(obj);
    } <span class="keyword">else</span> <span class="keyword">if</span> (page) {
        <span class="keyword">return</span> autoreleaseFullPage(obj, page);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> autoreleaseNoPage(obj);
    }
}
</code></pre><p>插入新元素的时候分三种情况需要处理：</p>
<ol>
<li>当前page未满，直接插入到当前page</li>
<li>当前page已满，创建一个新page并插入</li>
<li>当前page不存在，创建一个新page并插入</li>
</ol>
<p>这三种情况最终都会调用<code>page-&gt;add(obj)</code>：</p>
<pre><code>id *add(id obj)
{
    assert(!full())<span class="comment">;</span>
    unprotect()<span class="comment">;</span>
    id *ret = next<span class="comment">;</span>
    *next++ = obj<span class="comment">;</span>
    protect()<span class="comment">;</span>
    return ret<span class="comment">;</span>
}
</code></pre><p>首先断言当前page非满(<code>next != end()</code>),然后解除当前页保护(因为要插入，要使当前页可读可写),更新<code>next</code>指针地址，返回插入的元素地址。第一次初始化<code>autoreleasepool</code>时,传的nil值，返回值是nil值所在的地址。</p>
<h3 id="Pop操作"><em>Pop操作</em></h3><p>同上，<code>objc_autoreleasePoolPop</code> 实际调用了<code>AutoreleasePoolPage::pop(ctxt)</code>,传入的参数是初始化是返回的<code>nil</code>值的地址:</p>
<pre><code>static <span class="keyword">inline</span> <span class="literal">void</span> pop(<span class="literal">void</span> *token) 
{
    AutoreleasePoolPage *page;
    id *stop;

    <span class="keyword">if</span> (token == (<span class="literal">void</span>*)EMPTY_POOL_PLACEHOLDER) {
        <span class="keyword">if</span> (hotPage()) {
            pop(coldPage()<span class="subst">-&gt;</span>begin());
        } <span class="keyword">else</span> {
            setHotPage(nil);
        }
        <span class="keyword">return</span>;
    }

    page = pageForPointer(token);
    stop = (id *)token;
    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) {
        <span class="keyword">if</span> (stop == page<span class="subst">-&gt;</span>begin()  <span class="subst">&amp;&amp;</span>  <span class="subst">!</span>page<span class="subst">-&gt;</span><span class="keyword">parent</span>) {
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> badPop(token);
        }
    }

    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();

    page<span class="subst">-&gt;</span>releaseUntil(stop);

    <span class="comment">// memory: delete empty children</span>
      <span class="keyword">if</span> (page<span class="subst">-&gt;</span>lessThanHalfFull()) {                page<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>kill();
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (page<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>child) {
        page<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>kill();
   }
}
</code></pre><p><code>pop</code>的参数的含义是需要<code>pop</code>到参数元素所在的地址，Pop的时候首先判断是不是<code>EMPTY_POOL_PLACEHOLDER</code>, <code>EMPTY_POOL_PLACEHOLDER</code>的解释如下：</p>
<blockquote>
<p>EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is pushed and it has never contained any objects. This saves memory when the top level (i.e. libdispatch) pushes and pops pools but never uses them.</p>
</blockquote>
<p><code>EMPTY_POOL_PLACEHOLDER</code>是存储在TLS中的用来表示链表最上层没有元素的<code>pool</code>,这样就不用创建<code>pool</code>可以节约内存。TLS是什么以及具体实现<a href="http://blog.csdn.net/cywosp/article/details/26469435" target="_blank" rel="external">这篇文章</a>介绍的比较详细，这里不在解释。如果<code>pool</code>里面有数据，就把里面的数据清空；否者就把<code>hotPage</code>设置为<code>nil</code>。接着调用<code>page-&gt;releaseUntil(stop)</code>给此参数之前的所有对象发送<code>release</code>释放内存，对象内存释放之后，<code>终点page</code>之前的<code>page</code>都会变成空的，最后调用<code>page-&gt;child-&gt;kill()</code>回收这些<code>空page</code>资源。</p>
<p>假设某个线程的autoreleasepool的结构如下图所示，这个autoreleasepool的堆栈里有两个<code>POOL_SENTINEL</code>，说明代码里嵌套了两个autoreleasepool，在整个双向链表里，起始的第一个page为<code>coldPage</code>，最新的最后一个是<code>hotpage</code>。<code>hotPage</code>里保存了最新添加的对象:</p>
<p><img src="/assets/images/autorelease/AutoreleasePoolPage1.png" alt="img01"></p>
<p>此时，如果执行<code>pop(POOL_BOUNDARY)</code>操作，那么<code>autoreleasepool</code>的堆栈结构会变成下图：</p>
<p><img src="/assets/images/autorelease/AutoreleasePoolPage2.png" alt="img01"></p>
<p>所以处理嵌套的<code>autoreleasepool</code>就很简单了，因为<code>autoreleasepool</code>与<code>autoreleasepool</code>之间用特殊的标记分割了，每个<code>autoreleasepool</code>的释放只需要释放到指定位置(初始化时push的nil指针的地址)即可,内层与外层互相不影响。</p>
<h2 id="autorelease操作"><strong>autorelease操作</strong></h2><p>我们已经清楚了<code>autoreleasepool</code>的结构以及<code>autoreleasepool</code>对对象的管理方式，那么我们自己创建的对象是怎么和<code>autoreleasepool</code>关联的？在MRC中,<code>autorelease</code>的调用例如<code>[[[NSObject alloc]init] autorelease]</code>调用堆栈如下：</p>
<p><img src="/assets/images/autorelease/page3.jpeg" alt="img01"></p>
<p><code>autorelease</code>转发给了<code>rootAutorelease</code>调用:</p>
<pre><code>- (<span class="keyword">id</span>)autorelease {
    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();
}

<span class="keyword">inline</span> <span class="keyword">id</span> 
objc_object::rootAutorelease()
{
    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;
    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;

    <span class="keyword">return</span> rootAutorelease2();
}
</code></pre><p><code>rootAutorelease</code>首先判断是不是<code>Tagged Pointer</code>,是的话直接返回，因为<code>Tagged Pointer</code>是栈上的对象，不需要内存管理(文末有解释)。接着用<code>__builtin_return_address</code>判断外部是不是ARC环境。最终调用<code>autoreleaseFast</code>将对象插入到<code>autoreleasepool</code>中。</p>
<pre><code>static <span class="keyword">inline</span> id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    <span class="keyword">if</span> (page <span class="subst">&amp;&amp;</span> <span class="subst">!</span>page<span class="subst">-&gt;</span><span class="literal">full</span>()) {
        <span class="keyword">return</span> page<span class="subst">-&gt;</span>add(obj);
    } <span class="keyword">else</span> <span class="keyword">if</span> (page) {
        <span class="keyword">return</span> autoreleaseFullPage(obj, page);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> autoreleaseNoPage(obj);
    }
}
</code></pre><p>可以看出，在MRC中，通过对象主动调用<code>autorelease</code>的方式将对象加入到<code>autoreleasepool</code>的管理。那么在ARC中是怎么处理的呢？</p>
<p>在ARC环境下，我们改写main函数如下：<br>    int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        NSString </em>testObj = [[NSObject alloc]init];<br>        @autoreleasepool {<br>            NSObject *objTest2 = [[NSObject alloc]init];<br>            objTest2 = testObj;<br>        }<br>    }<br>    return 0;<br>}</p>
<p>然后使用<code>clang -S -fobjc-arc -emit-llvm main.m -o main.cc</code>生成IR中间代码，截取关键部分如下：</p>
<pre><code><span class="xml">define i32 @main(i32, i8**) #0 {
</span><span class="perl">  <span class="variable">%3</span> = alloca i32, align <span class="number">4</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%4</span> = alloca i32, align <span class="number">4</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%5</span> = alloca i8**, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%6</span> = alloca <span class="variable">%0</span>*, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%7</span> = alloca <span class="variable">%1</span>*, align <span class="number">8</span></span><span class="xml">
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
</span><span class="perl">  <span class="variable">%8</span> = call i8* <span class="variable">@objc_autoreleasePoolPush</span>() <span class="comment">#2</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%9</span> = load <span class="variable">%struct</span>._class_t*, <span class="variable">%struct</span>._class_t** <span class="variable">@"</span>OBJC_CLASSLIST_REFERENCES<span class="number">_</span><span class="variable">$_</span><span class="string">", align 8</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%10</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>, align 8, !invariant.load !7</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%11</span> = bitcast <span class="variable">%struct</span>._class_t* <span class="variable">%9</span> to i8*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%12</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%11</span>, i8* <span class="variable">%10</span>)</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%13</span> = bitcast i8* <span class="variable">%12</span> to <span class="variable">%1</span>*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%14</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>.2, align 8, !invariant.load !7</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%15</span> = bitcast <span class="variable">%1</span>* <span class="variable">%13</span> to i8*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%16</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%15</span>, i8* <span class="variable">%14</span>)</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%17</span> = bitcast i8* <span class="variable">%16</span> to <span class="variable">%1</span>*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%18</span> = bitcast <span class="variable">%1</span>* <span class="variable">%17</span> to <span class="variable">%0</span>*</span></span><span class="xml">
  store %0* %18, %0** %6, align 8
</span><span class="perl"><span class="string">  <span class="variable">%19</span> = call i8* <span class="variable">@objc_autoreleasePoolPush</span>() #2</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%20</span> = load <span class="variable">%struct</span>._class_t*, <span class="variable">%struct</span>._class_t** <span class="variable">@"</span>OBJC_CLASSLIST_REFERENCES_<span class="variable">$_</span>"</span>, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%21</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>, align <span class="number">8</span>, !invariant.load !<span class="number">7</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%22</span> = bitcast <span class="variable">%struct</span>._class_t* <span class="variable">%20</span> to i8*</span><span class="xml">
</span><span class="perl">  <span class="variable">%23</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%22</span>, i8* <span class="variable">%21</span>)</span><span class="xml">
</span><span class="perl">  <span class="variable">%24</span> = bitcast i8* <span class="variable">%23</span> to <span class="variable">%1</span>*</span><span class="xml">
</span><span class="perl">  <span class="variable">%25</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>.<span class="number">2</span>, align <span class="number">8</span>, !invariant.load !<span class="number">7</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%26</span> = bitcast <span class="variable">%1</span>* <span class="variable">%24</span> to i8*</span><span class="xml">
</span><span class="perl">  <span class="variable">%27</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%26</span>, i8* <span class="variable">%25</span>)</span><span class="xml">
</span><span class="perl">  <span class="variable">%28</span> = bitcast i8* <span class="variable">%27</span> to <span class="variable">%1</span>*</span><span class="xml">
  store %1* %28, %1** %7, align 8
</span><span class="perl">  <span class="variable">%29</span> = load <span class="variable">%0</span>*, <span class="variable">%0</span>** <span class="variable">%6</span>, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%30</span> = bitcast <span class="variable">%0</span>* <span class="variable">%29</span> to <span class="variable">%1</span>*</span><span class="xml">
</span><span class="perl">  <span class="variable">%31</span> = bitcast <span class="variable">%1</span>** <span class="variable">%7</span> to i8**</span><span class="xml">
</span><span class="perl">  <span class="variable">%32</span> = bitcast <span class="variable">%1</span>* <span class="variable">%30</span> to i8*</span><span class="xml">
  call void @objc_storeStrong(i8** %31, i8* %32) #2
</span><span class="perl">  <span class="variable">%33</span> = bitcast <span class="variable">%1</span>** <span class="variable">%7</span> to i8**</span><span class="xml">
  call void @objc_storeStrong(i8** %33, i8* null) #2
  call void @objc_autoreleasePoolPop(i8* %19)
</span><span class="perl">  <span class="variable">%34</span> = bitcast <span class="variable">%0</span>** <span class="variable">%6</span> to i8**</span><span class="xml">
  call void @objc_storeStrong(i8** %34, i8* null) #2
  call void @objc_autoreleasePoolPop(i8* %8)
  ret i32 0
}</span>
</code></pre><p>可以看出在ARC环境下，在<code>autoreleasePoolPop</code>之前会自动为我们生成<code>objc_storeStrong</code>,第一个参数是当前对象，第二个是赋值的对象(=右边的)。对象在外部被引用时，就retain:</p>
<p><img src="/assets/images/autorelease/page4.jpeg" alt="img01"></p>
<p>当对象没有被引用时，直接释放资源:</p>
<p><img src="/assets/images/autorelease/page5.jpeg" alt="img01"></p>
<p>这里比较奇怪的是对象并没有被加入到<code>autoreleasepool</code>中，应该是编译器对简单的情况作了优化，毕竟<code>autoreleasepool</code>的管理也是一个不小的开销。</p>
<h2 id="@autoreleasepool使用场景"><strong>@autoreleasepool使用场景</strong></h2><p>什么情况下我们需要显示使用<code>Autorelease Pool</code>？可以参考下苹果文档<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>Each thread in a Cocoa application maintains its own stack of autorelease pool blocks. If you are writing a Foundation-only program or if you detach a thread, you need to create your own autorelease pool block.</p>
<p>If your application or thread is long-lived and potentially generates a lot of autoreleased objects, you should use autorelease pool blocks (like AppKit and UIKit do on the main thread); otherwise, autoreleased objects accumulate and your memory footprint grows. If your detached thread does not make Cocoa calls, you do not need to use an autorelease pool block.</p>
</blockquote>
<p>需要程序员自己使用<code>@autoreleasepool</code></p>
<ol>
<li>If you are writing a program that is not based on a<br>UI framework, such as a command-line tool.</li>
<li><p>If you write a loop that creates many temporary objects.<br>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</p>
</li>
<li><p>If you spawn a secondary thread.<br>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.)</p>
</li>
</ol>
<p>大致意思就是大部分时候都不需要程序员关心，但是以下情况需要注意</p>
<ol>
<li>代码不是基于UI framework;比如基于命令行</li>
<li>创建大量的临时对象或者大对象需要立即释放的时候</li>
<li>创建了子线程时，子线程里应该使用<code>@autoreleasepool</code>；如从<code>NSThread</code>中<code>detach</code>出的线程用了<code>Cocoa calls</code><br>以上两种情况需要使用。</li>
</ol>
<p>以下是几种使用的例子：</p>
<pre><code><span class="comment">//情景1 SDWebImage源码</span>
<span class="annotation">@autoreleasepool</span> {
        UIImage *diskImage = [self <span class="string">diskImageForKey:</span>key];
        <span class="comment">//other code</span>
    }

<span class="comment">//情景2 (MBProgressHUD源码)</span>
[NSThread <span class="string">detachNewThreadSelector:</span><span class="annotation">@selector</span>(launchExecution) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];

- (<span class="typename">void</span>)launchExecution {
    <span class="annotation">@autoreleasepool</span> {
    <span class="comment">//代码实现</span>
    }
}

<span class="comment">//情景3 (Realm源码)</span>
RLMSchema *cachedRealmSchema;
<span class="annotation">@autoreleasepool</span> {
    <span class="comment">// ensure that cachedRealm doesn't end up in this thread's autorelease pool</span>
    <span class="comment">//确保cachedRealm在当前线程的autorelease pool没有被释放</span>
    cachedRealmSchema = RLMGetAnyCachedRealmForPath(config.path).schema;
}

<span class="comment">// if we have a cached realm on another thread, copy without a transaction</span>
<span class="keyword">if</span> (cachedRealmSchema) {
    RLMRealmSetSchemaAndAlign(realm, cachedRealmSchema);
}
<span class="keyword">else</span> <span class="keyword">if</span> (dynamic) {
    RLMRealmSetSchemaAndAlign(realm, [RLMSchema <span class="string">dynamicSchemaFromObjectStoreSchema:</span>realm-&gt;_realm-&gt;schema()]
</code></pre><h2 id="自己实现一个autoreleasepool">自己实现一个autoreleasepool</h2><p>根据以上原理，我们可以实现一个和系统功能差不多类似的<code>autoreleasepool</code>,源代码在GitHub<a href="https://github.com/tianyig/iOSAdvance.git" target="_blank" rel="external">autoreleasepool</a>.</p>
<h2 id="相关知识点"><strong>相关知识点</strong></h2><h3 id="Tagged_Pointer"><strong>Tagged Pointer</strong></h3><p>苹果对于Tagged Pointer特点的介绍：</p>
<ol>
<li>Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate</li>
<li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ol>
<p>为什么要用<code>Tagged Pointer</code>?因为数据类型的长度是和CPU长度有关的，这样就导致了在64位CPU上一些对象占用的内存会翻倍。同时维护程序中的对象需要 分配内存，维护引用计数，管理生命周期，使用对象给程序的运行增加了负担。我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。因为<code>Tagged pointer</code>不是一个真正的对象，如果使用isa指针在编译时会报错。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://draveness.me/autoreleasepool/" target="_blank" rel="external">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></li>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></li>
<li></li>
</ol>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/02/27/SDWebImage源码阅读-一/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">SDWebImage源码阅读笔记</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Autorelease的原理与实现" data-title="Autorelease的原理与实现" data-url="http://yoursite.com/2017/03/10/Autorelease的原理与实现/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 刘得胜
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>