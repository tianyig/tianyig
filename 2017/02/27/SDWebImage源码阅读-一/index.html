<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS开发,源码阅读," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="前言SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。
SDWebImage结构首先我们看看SDWebImage的项目组织结构：


Downloader负责图片的异步下载；
Cache负责图片的缓存；
SDWebImageManager是">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage源码阅读笔记">
<meta property="og:url" content="http://yoursite.com/2017/02/27/SDWebImage源码阅读-一/index.html">
<meta property="og:site_name" content="技术博客，谢谢关注">
<meta property="og:description" content="前言SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。
SDWebImage结构首先我们看看SDWebImage的项目组织结构：


Downloader负责图片的异步下载；
Cache负责图片的缓存；
SDWebImageManager是">
<meta property="og:image" content="http://yoursite.com/assets/images/SDWebImage/01.png">
<meta property="og:image" content="http://yoursite.com/assets/images/SDWebImage/02.png">
<meta property="og:image" content="http://yoursite.com/assets/images/SDWebImage/03.png">
<meta property="og:updated_time" content="2017-03-02T05:28:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDWebImage源码阅读笔记">
<meta name="twitter:description" content="前言SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。
SDWebImage结构首先我们看看SDWebImage的项目组织结构：


Downloader负责图片的异步下载；
Cache负责图片的缓存；
SDWebImageManager是">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> SDWebImage源码阅读笔记 | 技术博客，谢谢关注 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">技术博客，谢谢关注</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">这城市华灯初上，多两个人悲剧散场</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                SDWebImage源码阅读笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2017-02-27T10:55:02+08:00" content="2017-02-27">
              2017-02-27
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h2 id="前言"><strong>前言</strong></h2><p>SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。</p>
<h2 id="SDWebImage结构"><strong>SDWebImage结构</strong></h2><p>首先我们看看SDWebImage的项目组织结构：</p>
<p><img src="/assets/images/SDWebImage/01.png" alt="img01"></p>
<blockquote>
<p>Downloader负责图片的异步下载；</p>
<p>Cache负责图片的缓存；</p>
<p>SDWebImageManager是总的管理类，维护了一个SDWebImageDownloader实例和一个SDImageCache实例，是下载与缓存的桥梁;SDWebImageDecoder负责图片的解压缩;SDWebImagePrefetcher负责图片的预取;</p>
<p>UIImageView+WebCache和其他的扩展负责给用户提供接口;</p>
</blockquote>
<p>其中，最重要的就是SDWebImageDownloader、SDImageCache、SDWebImageManager三个类，接下来我们就一步步详细分析一下这些类具体如何实现的。</p>
<p>为了便于大家从宏观上有个把握，我这里先给出项目的框架结构:</p>
<p><img src="/assets/images/SDWebImage/02.png" alt="img01"></p>
<p>从这个图我们明显可以看出来，UIImageView+WebCache和UIButton+WebCache负责为用户提供接口；SDWebImageManger负责协调Downloader和Cache，并且为UIKit层提供支持；最底层的两个类为高层抽象提供支持；我们将采用至顶向下分析的方法，一层层分析。</p>
<h2 id="接口层的实现"><strong>接口层的实现</strong></h2><h3 id="UIImageView+WebCache"><strong>UIImageView+WebCache</strong></h3><p>这里我们拿UIImageView+WebCache举例，UIButton+WebCache与此类似。UIImageView+WebCache提供的接口如下：</p>
<pre><code><span class="pp">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这些接口都调用了</p>
<pre><code><span class="pp">- <span class="params">(void)</span>sd_setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageCompletionBlock</span>)</span>completedBlock；</span>
</code></pre><p>这是一种常用的封装的方法，一个函数提供最复杂的实现，其他函数给这个函数在此基础上通过调用的时候提供默认参数，浅浅的封装一层方便用户使用。因为OC函数不支持默认参数(C++支持)，所以需要在提供几个函数包装一下。</p>
<p>这个函数的上半部分实现如下：</p>
<pre><code><span class="list">[<span class="keyword">self</span> sd_cancelCurrentImageLoad]<span class="comment">;</span>
objc_setAssociatedObject<span class="list">(<span class="keyword">self</span>, &amp;imageURLKey, url,     OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><span class="comment">;</span>

if <span class="list">(<span class="keyword">!</span><span class="list">(<span class="keyword">options</span> &amp; SDWebImageDelayPlaceholder)</span>)</span> {
    dispatch_main_async_safe<span class="list">(<span class="keyword">^</span>{
        self.image = placeholder<span class="comment">;</span>
    })</span><span class="comment">;</span>
}</span>
</code></pre><p>在加载一张图片的时候首先取消当前正在加载图片的操作，然后给当前的UIImageView关联一个对应图片的URL，关联的这个url库里本身没有用到，只是暴露出<code>- (NSURL *)sd_imageURL;</code>接口提供给用户使用；if里判断用户是否使用了<code>SDWebImageDelayPlaceholder</code>，如果没有使用就设置<code>placeholder</code>,默认情况没有设置选项，图片在加载完成之前会显示占位图，如果设置了这个选项，会在图片加载完成之后在显示占位图，关于其它选项的具体含义，可以看叶孤城的解析<a href="http://www.jianshu.com/p/6ae6f99b6c4c" title="链接" target="_blank" rel="external">这里</a>。<code>dispatch_main_async_safe</code>是SDWebImage封装的一个保证参数block在主线程执行的宏，宏的实现比较简单，这里不在解释。</p>
<p>我们具体分析一下取消操作是如何实现的，<code>[self sd_cancelCurrentImageLoad]</code>调用了父类<code>UIView+EMWebCacheOperation</code>的函数：</p>
<pre><code><span class="collection">[self sd_cancelImageLoadOperationWithKey:@<span class="string">"UIImageViewImageLoad"</span>]</span><span class="comment">;</span>
</code></pre><p>我们可以看到，这里的key是写死的，因为一个UIImageView在任何时候至多只能对应一种类型的下载操作(可以同时下载image和highlightedImage，两者的key是不一样的)。网络下载以及缓存都是比较耗费系统资源的操作，这么做可以尽量避免资源浪费。例如UITableView在滑动到需要复用UITableViewCell时，如果此时滑出屏幕之前的图片还未加载完成，就没必要在下载了。我们继续深入看父类<code>UIView+EMWebCacheOperation</code>的实现，<code>sd_cancelImageLoadOperationWithKey</code>的全部实现如下：</p>
<pre><code><span class="comment">//这里通过给Category关联属性的方式给每个UIView添加了一个NSMutableDictionary属性，保存了operation或者operation数组;operation从下面可以看出是id &lt;EMSDWebImageOperation&gt;类型,之所以用这样的类型是为了通用性，不局限于使用系统的NSOperation，用户也可以自定义自己的Operation(如SDWebImage里的用到的SDWebImageCombinedOperation)。</span>
<span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];
    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];
    <span class="keyword">if</span> (operations) {
    <span class="comment">//gif图有多张图片，多张图片对应多个operation</span>
        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> class]]) {
            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) {
                <span class="keyword">if</span> (operation) {
                    [operation cancel];
                }
            }
        } <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>{
            <span class="comment">//单个图片，直接调用cancle</span>
            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];
        }
        [operationDictionary removeObjectForKey:key];
    }
</code></pre><p>然后我们接着看sd_setImageWithURL的下半部分的实现，截取部分关键的代码：</p>
<pre><code>__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;
<span class="comment">//创建一个id &lt;SDWebImageOperation&gt;(于UIView+EMWebCacheOperation对应)类型的下载task,</span>
<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) {
          [wself removeActivityIndicator];
        <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
            <span class="comment">//如果用户不希望下载完成直接设置image，就只调用completedBlock</span>
            <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
            {
                completedBlock(image, error, cacheType, url);
                <span class="keyword">return</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (image) {
                wself<span class="variable">.image</span> = image;
                [wself setNeedsLayout];
            } <span class="keyword">else</span> {
                <span class="comment">//下载完成设置placeholder</span>
                <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) {
                    wself<span class="variable">.image</span> = placeholder;
                    [wself setNeedsLayout];
                }
            }
            <span class="keyword">if</span> (completedBlock &amp;&amp; finished) {
                completedBlock(image, error, cacheType, url);
            }
        });
    }];
<span class="comment">//将这个Operation添加到此UIImageView的字典里</span>
[<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];
</code></pre><p>接口层的实现到这里就结束了。这里有几个小问题:</p>
<ul>
<li><strong><font color="red">iOS底层如何实现Category关联属性的？</font></strong></li>
<li><strong><font color="red">iOS的Category如何关联weak属性？</font></strong></li>
</ul>
<h2 id="调度层的实现">调度层的实现</h2><p> 调度层就一个类SDWebImageManager，在头文件中描述如下：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes.<br> It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache).<br> You can use this class directly to benefit from web image downloading with caching in another context than<br> a UIView.</p>
</blockquote>
<p>意思就是SDWebImageManager是位于UIImageView+WebCache之下的用于图片异步下载和缓存的类，你也可以直接使用SDWebImageManager的函数直接下载图片。</p>
<p>SDWebImageManager是一个用dispatch_once实现的单例(关于<font color="red"><strong>dispatch_once底层如何实现的？</strong></font>也是一个有趣的话题，我们以后在讨论它),维护了一个SDImageCache实例和SDWebImageDownloader实例。提供的函数如下：</p>
<p>//初始化SDWebImageManager单例，在init方法中已经初始化了cache单例和downloader单例。</p>
<pre><code>- (instancetype)initWithCache:(SDImageCache *)cache downloader:(SDWebImageDownloader *)downloader;
<span class="comment">//下载图片</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;
<span class="comment">//缓存给定URL的图片</span>
- (<span class="keyword">void</span>)saveImageToCache:(<span class="built_in">UIImage</span> *)image forURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//取消当前所有的操作</span>
- (<span class="keyword">void</span>)cancelAll;
<span class="comment">//监测当前是否有进行中的操作</span>
- (<span class="built_in">BOOL</span>)isRunning;
<span class="comment">//监测图片是否在缓存中， 先在memory cache里面找  再到disk cache里面找</span>
- (<span class="built_in">BOOL</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否缓存在disk里</span>
- (<span class="built_in">BOOL</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否在缓存中,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                     completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//监测图片是否缓存在disk里,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                   completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//返回给定URL的cache key，默认是图片的url</span>
- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url;
</code></pre><p>定义了SDWebImageManagerDelegate协议：</p>
<pre><code><span class="comment">@protocol SDWebImageManagerDelegate </span>

<span class="comment">@optional</span>

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Controls which image should be downloaded when the image is not found in the cache.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to be downloaded</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span>
 <span class="keyword">*</span> 控制在cache中没有找到image时 是否应该去下载。默认是YES。
 <span class="keyword">*</span>/
- (BOOL)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager shouldDownloadImageForURL:(NSURL <span class="keyword">*</span>)imageURL;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.
 <span class="keyword">*</span> NOTE: This method is called from a global queue in order to not to block the main thread.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param image        The image to transform</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to transform</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return The transformed image object.</span>
 <span class="keyword">*</span> 在下载之后，缓存之前转换图片。在全局队列中操作，不阻塞主线程
 <span class="keyword">*</span>/
- (UIImage <span class="keyword">*</span>)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager transformDownloadedImage:(UIImage <span class="keyword">*</span>)image withURL:(NSURL <span class="keyword">*</span>)imageURL;

<span class="comment">@end</span>
</code></pre><p> 我们主要看下</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                        options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options
                                       progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                      completed:<span class="params">(<span class="variable">SDWebImageCompletionWithFinishedBlock</span>)</span>completedBlock</span>
</code></pre><p>这个函数返回<code>id &lt;SDWebImageOperation&gt;</code>类型保存当前UIImageView的下载操作；</p>
<p>首先检查URL是否合法：</p>
<pre><code><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) {
    url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];
}

<span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span>
<span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) {
    url = nil;
}
</code></pre><p>这两个判断都是检查用户传递参数类型是否正确；</p>
<pre><code><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;
<span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) {
    isFailedUrl = [<span class="keyword">self</span><span class="variable">.failedURLs</span> containsObject:url];
}

<span class="keyword">if</span> (url<span class="variable">.absoluteString</span><span class="variable">.length</span> == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
    dispatch_main_sync_safe(^{
        <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];
        completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
    });
    <span class="keyword">return</span> operation;
}
</code></pre><p>若URL对应的image之前下载失败过并且用户没有设置错误重试，直接调用completedBlock；</p>
<pre><code><span class="variable">@synchronized</span> (self.runningOperations) {
    <span class="attr_selector">[self.runningOperations addObject:operation]</span>;
}
</code></pre><p>把当前下载操作加入到runningOperations中，因为runningOperations是多线程共享的，所以要加synchronized控制并发；<strong>synchronized底层是如何实现的呢？</strong>我们在以后的文章里去探究。</p>
<p>SDWebImageManager首先去检查cache(memeory &amp;&amp; disk)中是否缓存过要下载的图片，调用imageCache的</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSOperation</span> *)</span>queryDiskCacheForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key done:<span class="params">(<span class="variable">SDWebImageQueryCompletedBlock</span>)</span>doneBlock</span>
</code></pre><p>函数里首先判断当前操作是否被取消，如果取消从runningOperations中移除，并直接返回：</p>
<pre><code><span class="tag">if</span> (operation.isCancelled) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="attr_selector">[self.runningOperations removeObject:operation]</span>;
    }

    return;
}
</code></pre><p>接下来需要讨论二种情况情况：1.（缓存未找到图片）或（缓存找到了图片但是用户设置了刷新缓存） 2. （用户没有实现shouldDownloadImageForURL协议）或（用户实现了shouldDownloadImageForURL协议并且返回值是YES）</p>
<pre><code>if <span class="list">(<span class="list">(!image || options &amp; SDWebImageRefreshCached)</span> <span class="keyword">&amp;&amp;</span> <span class="list">(![self.delegate respondsToSelector:@selector<span class="list">(<span class="keyword">imageManager</span><span class="keyword">:shouldDownloadImageForURL</span>:)</span>] || [self.delegate imageManager<span class="keyword">:self</span> shouldDownloadImageForURL<span class="keyword">:url</span>])</span>)</span>
</code></pre><p>这两种情况下需要下载图片，上面这一坨就是判断上面的二种情况。</p>
<p>除了上面二种情况还有不需要下载图片的二种情况：1.缓存找到图片 2.缓存未找到图片并且用户禁止下载：</p>
<pre><code><span class="comment">//第一种情况，缓存找到图片(用户未设置刷新缓存并且用户未禁止下载)</span>
<span class="keyword">else</span> <span class="keyword">if</span> (image) {
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) {
            completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
<span class="comment">//第二种情况(缓存未找到且用户通过delegate设置在缓存未找到时禁止下载图片)</span>
<span class="keyword">else</span> {
    <span class="comment">// Image not in cache and download disallowed by delegate</span>
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation<span class="variable">.isCancelled</span>) {
            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
</code></pre><p>如果需要下载图片，就调用</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock</span>
</code></pre><p>下载图片，如果下载失败。直接调用completedBlock返回错误，并根据错误类型将URL添加到failedURLs里。</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">error</span>) {
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(nil, <span class="built_in">error</span>, SDImageCacheTypeNone, finished, url);
        }
    });

    <span class="keyword">if</span> (   <span class="built_in">error</span>.code != NSURLErrorNotConnectedToInternet
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCancelled
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorTimedOut
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorInternationalRoamingOff
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorDataNotAllowed
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotFindHost
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotConnectToHost) {
        @synchronized (<span class="variable">self</span>.failedURLs) {
            [<span class="variable">self</span>.failedURLs addObject:url];
        }
    }
}
</code></pre><p>若图片下载成功，将url从failURLs里删除：</p>
<pre><code><span class="tag">if</span> ((options &amp; SDWebImageRetryFailed)) {
    <span class="variable">@synchronized</span> (self.failedURLs) {
        <span class="attr_selector">[self.failedURLs removeObject:url]</span>;
    }
}
</code></pre><p>这个地方需要解释下，因为<code>[self.failedURLs addObject:url]</code>是<strong>只在下载失败时添加</strong>的，而下载成功和下载失败是互斥的，也就是说，下载成功时failedURLs数组里就不应该有这个url，为什么要这么写呢，这是为了解决竞态条件下的问题，若两个线程下载同一个url的图片，若第一个线程下载失败，第二个下载成功。如果不从failedURLs移除这个url的话，以后下载此url的图片都会失败。</p>
<p>然后处理下载完成的图片：</p>
<pre><code><span class="comment">//是否设置了只缓存内存</span>
BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

<span class="comment">//设置刷新缓存且cache找到图片且NSURLCache找到图片，不处理</span>
<span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) {
    <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span>
}
<span class="comment">//若delegate实现imageManager:transformDownloadedImage:withURL:方法，在缓存之前，需要做调用此delegate方法转换</span>
<span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="annotation">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) {
    <span class="comment">//在全局队列中转换，不阻塞主线程dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{</span>
        UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];
        <span class="comment">//转换成功后，存入缓存</span>
        <span class="keyword">if</span> (transformedImage &amp;&amp; finished) {
            BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];
            [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">recalculateFromImage:</span>imageWasTransformed <span class="string">imageData:</span>(imageWasTransformed ? nil : data) <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
        }
        <span class="comment">//缓存成功之后，调用completedBlock</span>
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
                completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);
            }
        });
    });
}
<span class="keyword">else</span> {
    <span class="comment">//没有实现转换的delegate，就不做转换直接缓存</span>
    <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) {
        [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
    }
    <span class="comment">//缓存成功之后，调用completedBlock</span>
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);
        }
    });
}
</code></pre><p>}</p>
<p>下载完成之后，从队列里移除：</p>
<pre><code><span class="tag">if</span> (finished) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="tag">if</span> (strongOperation) {
            <span class="attr_selector">[self.runningOperations removeObject:strongOperation]</span>;
        }
    }
}
</code></pre><p>最后说下返回的<code>SDWebImageCombinedOperation</code>类型，这个类型包含<code>NSOperation *cacheOperation</code>的一个子类型，其中<code>cacheOperation</code>中又存在<code>id &lt;SDWebImageOperation&gt;</code>的下载图片的<code>subOperation</code>。在<code>cancel</code>的时候也应该把这两个操作都<code>cancle</code>。</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">self</span><span class="variable">.cancelled</span> = <span class="literal">YES</span>;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cacheOperation</span>) {
        [<span class="keyword">self</span><span class="variable">.cacheOperation</span> cancel];
        <span class="keyword">self</span><span class="variable">.cacheOperation</span> = <span class="literal">nil</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) {
        <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

        <span class="comment">// <span class="doctag">TODO:</span> this is a temporary fix to #809.</span>
        <span class="comment">// Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span>
<span class="comment">//        self.cancelBlock = nil;</span>
        _cancelBlock = <span class="literal">nil</span>;
    }
}
</code></pre><p>所以<code>CombinedOperation</code>在<code>cancel</code>的时候会先cancel掉自己的<code>cacheOperation</code>,在调用自己的<code>cancelBlock</code>。</p>
<pre><code><span class="label">operation.cancelBlock</span> = ^{
    [<span class="keyword">subOperation </span>cancel]<span class="comment">;</span>


    <span class="comment">@synchronized (self.runningOperations) {</span>
        __strong __typeof(weakOperation) <span class="keyword">strongOperation </span>= weakOperation<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">strongOperation) </span>{
            [<span class="keyword">self.runningOperations </span>removeObject:<span class="keyword">strongOperation];
</span>        }
    }
}<span class="comment">;</span>
</code></pre><p>在自己的<code>cancelBlock</code>把下载操作<code>subOperation</code>取消掉。由此可见封装的<code>CombinedOperation</code>包含了下载和缓存的操作，使代码变得更简洁。</p>
<h2 id="下载和缓存层"><strong>下载和缓存层</strong></h2><h3 id="下载层SDWebImageDownloader"><strong>下载层SDWebImageDownloader</strong></h3><p>SDWebImageDownloader提供的方法有以下几个：</p>
<pre><code><span class="comment">//给每个HTTP下载请求头的指定field设置值。</span>
- (<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//返回HTTP特定field的值</span>
- (<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//设置一个SDWebImageDownloaderOperation的子类作为下载请求的默认NSOperation</span>
- (<span class="keyword">void</span>)setOperationClass:(Class)operationClass;
<span class="comment">//创建一个SDWebImageDownloader异步下载实例，图片下载完成或错误时，通知delegate回调。方法返回一个 SDWebImageOperation</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                     options:(SDWebImageDownloaderOptions)options
                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
<span class="comment">// 设置下载队列为挂起状态</span>
- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended;
<span class="comment">//取消队列中的所有操作。</span>
- (<span class="keyword">void</span>)cancelAllDownloads;
</code></pre><p>我们重点研究下载方法：</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                     options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
                                    progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                   completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这几个参数的含义代码注释里都有，这里就不再一一解释。</p>
<pre><code>__block SDWebImageDownloaderOperation *operation;
__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;

[<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
    <span class="comment">//block实现</span>
    ...
    operation = [[wself<span class="variable">.operationClass</span> alloc] initWithRequest:request
                                                      options:options
                                                     progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize)
    ...
}];

<span class="keyword">return</span> operation;
</code></pre><p>上面是这个方法的框架，可以看出主要调用了<code>addProgressCallback</code>方法，方法的内部创建了下载的<code>operation</code>。我们首先看看<code>addProgressCallback</code>方法的实现:</p>
<pre><code><span class="comment">//如果url为nil，调用completedBlock后return</span>
<span class="keyword">if</span> (url == <span class="literal">nil</span>) {
    <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) {
        completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
    }
    <span class="keyword">return</span>;
}

<span class="comment">//允许多线程下载，使用了并发控制，避免同时修改URLCallbacks</span>
dispatch_barrier_sync(<span class="keyword">self</span><span class="variable">.barrierQueue</span>, ^{
    <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;
    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url]) {
        <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = [<span class="built_in">NSMutableArray</span> new];
        first = <span class="literal">YES</span>;
    }

    <span class="comment">// Handle single download of simultaneous download request for the same URL</span>
    <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url];
    <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];
    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];
    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];
    [callbacksForURL addObject:callbacks];
    <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = callbacksForURL;

    <span class="keyword">if</span> (first) {
        createCallback();
    }
});
</code></pre><p>这里的并发控制的地方为什么要使用<code>dispatch_barrier_sync</code>，是因为<code>dispatch_barrier_sync</code>这个函数可以设置一个同步执行block，它会等到在这个block加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。。这里的<code>dispatch_barrier_sync</code>实际上相当于一个写锁，任何写操作(删除，添加)，都要在之前的写操作完成后执行，而之后的写操作，也要在之前的的写操作完成之后执行。</p>
<p>URLCallbacks是一个以url作为key的字典，字典的value是一个数组，数组的元素是一个字典。可以看出<code>URLCallbacks</code>、<code>callbacksForURL</code>、<code>callbacks</code>之间的关系如下图：</p>
<p><img src="/assets/images/SDWebImage/03.png" alt="img01"></p>
<p>如果URLCallbacks以url对应的value是空，说明是第一次请求这个url，需要调用<code>createCallback</code>创建下载任务，即调用：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
        inSession:<span class="params">(<span class="variable">NSURLSession</span> *)</span>session
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>设置默认超时时间15s，然后使用此<code>request</code>创建一个<code>SDWebImageDownloaderOperation</code>,方便把这个下载任务添加到下载队列里：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>重点看下这个方法的三个block，第一个progress，取出存储在URLCallbacks中的progressBlock并调用：</p>
<pre><code><span class="comment">//只是读操作，dispatch_sync即可</span>
 <span class="built_in">dispatch_sync</span>(sself<span class="variable">.barrierQueue</span>, ^{
     callbacksForURL = [sself<span class="variable">.URLCallbacks</span>[url] <span class="keyword">copy</span>];
 });
 <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) {
     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
         SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
         <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);
     });
 }
</code></pre><p>同理，<code>completed</code>也是从URLCallbacks中的completedBlock并调用：</p>
<pre><code><span class="comment">//这里有写操作，须用dispatch_barrier_sync</span>
dispatch_barrier_sync(sself.barrierQueue, ^{
    callbacksForURL = [sself.URLCallbacks[url] copy];
    <span class="keyword">if</span> (finished) {
        [sself.URLCallbacks removeObjectForKey:url];
    }
});
<span class="keyword">for</span> (NSDictionary *callbacks <span class="keyword">in</span> callbacksForURL) {
    <span class="comment">//这里为什么不像progressBlock一样使用dispatch_async(dispatch_get_main_queue()？</span>
    SDWebImageDownloaderCompletedBlock <span class="keyword">callback</span> = callbacks[kCompletedCallbackKey];
    <span class="keyword">if</span> (<span class="keyword">callback</span>) <span class="keyword">callback</span>(image, data, error, finished);
}
</code></pre><p>不同图片的下载任务会异步完成，所以要等待其他图片下载完成，并执行完<code>completedBlock</code>中对<code>URLCallbacks</code>的操作，才能继续之后的操作。</p>
<pre><code>cancelled:^{
    SDWebImageDownloader *sself = wself<span class="comment">;</span>
    if (!sself) return<span class="comment">;</span>
    dispatch_barrier_async(sself.barrierQueue, ^{
        [sself.URLCallbacks removeObjectForKey:url]<span class="comment">;</span>
    })<span class="comment">;</span>
}
</code></pre><p>取消时用的<code>dispatch_barrier_async</code>,dispatch_barrier_async表示的是先等之前的执行完成，然后把该barrier放入queue中，而不等待barrier中代码执行结束，而dispat_barrier_sync表示需要等待barrier中代码执行结束。</p>
<p>然后设置operation</p>
<pre><code><span class="comment">//是否解压下载的图片</span>
operation.shouldDecompressImages = wself.shouldDecompressImages;
<span class="comment">//有证书设置证书</span>
<span class="keyword">if</span> (wself.urlCredential) {
    operation.credential = wself.urlCredential;
} <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) {
    operation.credential = [NSURLCredential <span class="string">credentialWithUser:</span>wself.username <span class="string">password:</span>wself.password <span class="string">persistence:</span>NSURLCredentialPersistenceForSession];
}
<span class="comment">//设置优先级</span>
<span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) {
    operation.queuePriority = NSOperationQueuePriorityHigh;
} <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) {
    operation.queuePriority = NSOperationQueuePriorityLow;
}

[wself.downloadQueue <span class="string">addOperation:</span>operation];
<span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
    <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span>
    [wself.lastAddedOperation <span class="string">addDependency:</span>operation];
    wself.lastAddedOperation = operation;
}
</code></pre><p>最后将这个下载的操作加入到下载队列里。下载方式有两种，FIFO和LIFO。最后根据下载的方式调增任务的依赖。</p>
<h4 id="具体的下载操作SDWebImageDownloaderOperation"><strong>具体的下载操作SDWebImageDownloaderOperation</strong></h4><p>上面的<code>SDWebImageDownloader</code>主要操作就是创建<code>SDWebImageDownloaderOperation</code>添加到下载队列里，可知具体的操作是在<code>SDWebImageDownloaderOperation</code>，我们研究下具体是如何下载的。首先这个类是继承于<code>NSOperation</code>，并重写了<code>start</code>方法。我们首先看看它的<code>start</code>方法的实现：</p>
<p>检测下载状态</p>
<pre><code><span class="comment">//管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span>
<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) {
    <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    [<span class="keyword">self</span> reset];
    <span class="keyword">return</span>;
}
</code></pre><p>如果是iOS4.0以上的版本，需要设置后台执行的操作：</p>
<pre><code><span class="comment">//作为具体的下载操作，尽量不依赖其他类，所以这里使用字符串创建</span>
Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);
<span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];
<span class="comment">//如果用户设置了后台下载</span>
<span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) {
    <span class="comment">//如果设置了在后台执行，则进行后台执行</span>
     __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    <span class="comment">//向系统申请更长的时间执行下载操作</span>
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = [app beginBackgroundTaskWithExpirationHandler:^{
        <span class="comment">// 如果在系统规定时间内任务还没有完成（一般是10分钟），结束后台任务</span>
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;
        <span class="keyword">if</span> (sself) {
            [sself cancel];
            [app endBackgroundTask:sself<span class="variable">.backgroundTaskId</span>];
            sself<span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
        }
    }];
｝
</code></pre><p>这里注册的block会在APP进入后台时执行，block里调用<code>cancel</code>对应的<code>endBackgroundTask</code>,这个block的主要目的是持有<code>self</code>不要被系统销毁，只要<code>self</code>不被系统销毁，当前下载操作就可以继续执行。<code>self</code>被销毁后，我们看看<code>cancel</code>操作做了什么：</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.thread</span>) {
            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelInternalAndStop) onThread:<span class="keyword">self</span><span class="variable">.thread</span> withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];
        }
        <span class="keyword">else</span> {
            [<span class="keyword">self</span> cancelInternal];
        }
    }
}

- (<span class="keyword">void</span>)cancelInternalAndStop {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">self</span> cancelInternal];
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
}

- (<span class="keyword">void</span>)cancelInternal {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">super</span> cancel];
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.connection</span>) {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
        });

        <span class="comment">// As we cancelled the connection, its callback won't be called and thus won't</span>
        <span class="comment">// maintain the isFinished and isExecuting flags.</span>
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isExecuting</span>) <span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">NO</span>;
        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    }

    [<span class="keyword">self</span> reset];
}
</code></pre><p>底下有三个和<code>cancel</code>相关的操作，如果当前线程存在，在当前线程调用<code>cancelInternalAndStop</code>，否者调用<code>cancelInternal</code>;这两者的区别是<code>cancelInternalAndStop</code>中多了一句<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>,在中止当前线程的时候，也要关闭对应的RunLoop。<code>cancelInternal</code>做了几件事：</p>
<ul>
<li>调用自定义的cancelBlock</li>
<li>调用NSURLConnection的cancel取消self.connection</li>
<li>回收资源</li>
<li>抛出通知</li>
</ul>
<p>注册的后台操作是在进入到后台如果<code>NSOperation</code>未执行完成才执行的，假如在进入到后台之前<code>NSOperation</code>已经完成了呢？</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.backgroundTaskId</span> != <span class="built_in">UIBackgroundTaskInvalid</span>) {
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    [app endBackgroundTask:<span class="keyword">self</span><span class="variable">.backgroundTaskId</span>];
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
}
</code></pre><p>如果下载任务完成，中止后台操作，将backgroundTaskId置为UIBackgroundTaskInvalid。</p>
<p>注册后台操作的准备工作完成之后，就该开始下载了：</p>
<pre><code><span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">YES</span>;
<span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span><span class="variable">.request</span> delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];
<span class="keyword">self</span><span class="variable">.thread</span> = [<span class="built_in">NSThread</span> currentThread];
</code></pre><p>初始化相关的数据，创建<code>NSURLConnection</code>,如果创建失败就调用<code>completedBlock</code>,成功就启动下载，关键代码如下：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
    <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);
}
....
<span class="built_in">CFRunLoopRun</span>();
....
<span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) {
    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    [<span class="keyword">self</span> connection:<span class="keyword">self</span><span class="variable">.connection</span> didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@{<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>}]];
}
</code></pre><p>使用<code>NSURLConnection</code>调用了<code>[self.connection start]</code>后，<code>NSURLConnection</code>的delegate就会不停收到事件回调。当这个connection完成或者终止，才会跳出CFRunLoopRun()(可以理解为CFRunLoopRun阻塞了当前线程)。当跳出Runloop后，就要判断NSURLConnection是不是正常完成任务了。如果没有，也就是说self.isFinished == NO。那么就取消该connection，并且调用</p>
<pre><code>(<span class="typename">void</span>)<span class="string">connection:</span>(NSURLConnection *)connection <span class="string">didFailWithError:</span>(NSError *)error;
</code></pre><p>返回错误信息。然后就是<code>NSURLConnection</code>几个delegate过程的处理：</p>
<pre><code><span class="comment">//如果是304代表服务端资源未改变，可直接使用客户端未过期的资源，此时需要取消operation并返回缓存中的image，code小于400说明请求成功</span>
<span class="comment">//如果响应成功，开始初始化数组，准备接收imageData</span>
<span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] != <span class="number">304</span>)) {
    <span class="built_in">NSInteger</span> expected = response<span class="variable">.expectedContentLength</span> &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response<span class="variable">.expectedContentLength</span> : <span class="number">0</span>;
    <span class="keyword">self</span><span class="variable">.expectedSize</span> = expected;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
        <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, expected);
    }

    <span class="keyword">self</span><span class="variable">.imageData</span> = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];
    <span class="keyword">self</span><span class="variable">.response</span> = response;
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];
    });
}
<span class="comment">//请求失败之后，抛通知并清理相关资源</span>
<span class="keyword">else</span> {
    <span class="built_in">NSUInteger</span> code = [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode];

    <span class="comment">//This is the case when server returns '304 Not Modified'. It means that remote image is not changed.</span>
    <span class="comment">//In case of 304 we need just cancel the operation and return cached image from the cache.</span>
    <span class="keyword">if</span> (code == <span class="number">304</span>) {
        [<span class="keyword">self</span> cancelInternal];
    } <span class="keyword">else</span> {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    }
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
    });

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="keyword">self</span><span class="variable">.completedBlock</span>(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:[((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] userInfo:<span class="literal">nil</span>], <span class="literal">YES</span>);
    }
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
    [<span class="keyword">self</span> done];
}
</code></pre><p>然后在下载过程中接收数据，以下是部分代码：</p>
<pre><code><span class="keyword">if</span> (partialImageRef) {
    <span class="comment">//把data转换成image</span>
    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:partialImageRef scale:<span class="number">1</span> orientation:orientation];
    <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>];
    <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];
    <span class="comment">//判断是否要解解码，默认是需要解码，解码的操作是在子线程里(delegate在子线程执行的),为什么要解码？我们之后解释</span>
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) {
        image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];
    }
    <span class="keyword">else</span> {
        image = scaledImage;
    }
    <span class="built_in">CGImageRelease</span>(partialImageRef);
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="comment">//显示在imageView上（不一定下载完，可以显示一部分）</span>
            <span class="keyword">self</span><span class="variable">.completedBlock</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
        }
    });
}
</code></pre><blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<h3 id="缓存层SDImageCache">缓存层SDImageCache</h3><p>我们看下<code>SDWebImage</code>的缓存<code>SDImageCache</code>，<code>SDImageCache</code>主要包含两部分，内存缓存<code>memCache</code>和磁盘缓存<code>fileManager</code>,磁盘缓存的写操作是异步的。</p>
<blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI. </p>
</blockquote>
<p>内存缓存是使用<code>NSCache</code>实现的，<code>NSCache</code>使用上类似字典，可以用key-Value的方式存取数据。但是NSCache底层实现和<code>NSDictionary</code>不同(NSCache是线程安全的)。<code>NSCache</code>的具体介绍可以看<a href="http://nshipster.cn/nscache/" target="_blank" rel="external">NSCache</a>。</p>
<p>先看看<code>SDImageCache</code>的属性：</p>
<pre><code><span class="comment">//是否解压下载的图片，默认是YES,但是会消耗掉很多内存，如果遇到内存不足的crash时，将值设为NO</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;
<span class="comment">//是否自动上传iCloud</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;
<span class="comment">//使用内存缓存</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;
<span class="comment">//内存缓存的代价（占用的内存大小）</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCost;
<span class="comment">//内存缓存的最大元素个数</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCountLimit;
<span class="comment">//元素在缓存中最大寿命</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;
<span class="comment">//最大缓存大小</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;
</code></pre><p>前面<code>SDWebImageManager</code>在下载图片成功时，会调用</p>
<pre><code>[self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk]
</code></pre><p>缓存到内存和磁盘，我们重点看下这个函数的实现:</p>
<pre><code><span class="comment">//错误处理</span>
<span class="keyword">if</span> (!image || !key) {
    <span class="keyword">return</span>;
}
<span class="comment">//需要内存缓存，计算内存占用，直接缓存</span>
<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldCacheImagesInMemory</span>) {
    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);
    [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:image forKey:key cost:cost];
}

<span class="comment">//需要磁盘异步缓存</span>
<span class="keyword">if</span> (toDisk) {
    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^{
        <span class="built_in">NSData</span> *data = imageData;

        <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) {
<span class="preprocessor">#if TARGET_OS_IPHONE</span>
            <span class="comment">//确定图片是png还是jpeg. imageData为nil而且有alapha通道，当作png处理</span>
            <span class="keyword">int</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(image<span class="variable">.CGImage</span>);
            <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == k<span class="built_in">CGImageAlphaNone</span> ||
                              alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||
                              alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);
            <span class="built_in">BOOL</span> imageIsPng = hasAlpha;

            <span class="comment">// But if we have an image data, we will look at the preffix</span>
            <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) {
                imageIsPng = ImageDataHasPNGPreffix(imageData);
            }
            <span class="comment">//根据类型返回image的data</span>
            <span class="keyword">if</span> (imageIsPng) {
                data = <span class="built_in">UIImagePNGRepresentation</span>(image);
            }
            <span class="keyword">else</span> {
                data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);
            }
<span class="preprocessor">#else</span>
            data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image<span class="variable">.representations</span> usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];
<span class="preprocessor">#endif</span>
        }
        <span class="comment">//磁盘存储</span>
        <span class="keyword">if</span> (data) {
            <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) {
                [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];
            }

            <span class="comment">// 获取缓存路径</span>
            <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];
            <span class="comment">// transform to NSUrl</span>
            <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];
            <span class="comment">//存储到disk里</span>
            [_fileManager createFileAtPath:cachePathForKey contents:data attributes:<span class="literal">nil</span>];

            <span class="comment">// disable iCloud backup</span>
            <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDisableiCloud</span>) {
                [fileURL setResourceValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];
            }
        }
    });
}
</code></pre><p>同样的。<code>SDWebImageManager</code>在下载之前会检查缓存是否有此图片：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSOperation</span> *)</span>queryDiskCacheForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key done:<span class="params">(<span class="variable">SDWebImageQueryCompletedBlock</span>)</span>doneBlock</span>
</code></pre><p>关键代码如下：</p>
<pre><code><span class="comment">//从内存缓存里查找</span>
<span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];
<span class="keyword">if</span> (image) {
    doneBlock(image, SDImageCacheTypeMemory);
    <span class="keyword">return</span> <span class="literal">nil</span>;
}

<span class="comment">//NSOperation的特殊用法，用于取消一个异步操作</span>
<span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];
<span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^{
    <span class="keyword">if</span> (operation<span class="variable">.isCancelled</span>) {
        <span class="keyword">return</span>;
    }

    <span class="comment">//disk查找图片成功之后需要解码，所以放在`autoreleasepool`里</span>
    <span class="keyword">@autoreleasepool</span> {
        <span class="comment">//从磁盘查找，解码</span>
        <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];
        <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span><span class="variable">.shouldCacheImagesInMemory</span>) {
            <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);
            [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:diskImage forKey:key cost:cost];
        }
        <span class="comment">//查找完成</span>
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            doneBlock(diskImage, SDImageCacheTypeDisk);
        });
    }
});
</code></pre><p>最后还有一个Cache清除的方式，对于memory cache来说是完全清空的，对于disk cache，根据设置参数的不同，有两种清除方式：</p>
<ul>
<li>文件的缓存有效期：默认是一周。如果文件的缓存时间超过这个时间值，则将其移除。</li>
<li>最大缓存空间大小：如果所有缓存文件的总大小超过最大缓存空间，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
</ul>
<h2 id="底层支持(工具类)">底层支持(工具类)</h2><h3 id="SDWebImageDecoder和SDWebImageCompat">SDWebImageDecoder和SDWebImageCompat</h3><p><code>SDWebImageDecoder</code>是用来图片解码的，在上面下载的时候和磁盘读取图片数据时，都调用了解码操作，图片为什么需要解码，可以参考如下解释:</p>
<blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<p><code>SDWebImageCompat</code>是根据屏幕大小设置图片的<code>scale</code>，实现比较简单，这里不再解释。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS开发/" rel="tag">#iOS开发</a>
          
            <a href="/tags/源码阅读/" rel="tag">#源码阅读</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/13/大并发服务器/四、epoll函数/" rel="next" title="四、epoll函数">
                <i class="fa fa-chevron-left"></i> 四、epoll函数
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/10/Autorelease的原理与实现/" rel="prev" title="Autorelease的原理与实现">
                Autorelease的原理与实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


        </div>

        


        
  <div class="comments" id="comments">
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xorsh.com1.z0.glb.clouddn.com/headIcon.jpg" alt="刘得胜" itemprop="image"/>
          <p class="site-author-name" itemprop="name">刘得胜</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImage结构"><span class="nav-number">2.</span> <span class="nav-text">SDWebImage结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口层的实现"><span class="nav-number">3.</span> <span class="nav-text">接口层的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UIImageView+WebCache"><span class="nav-number">3.1.</span> <span class="nav-text">UIImageView+WebCache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度层的实现"><span class="nav-number">4.</span> <span class="nav-text">调度层的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下载和缓存层"><span class="nav-number">5.</span> <span class="nav-text">下载和缓存层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载层SDWebImageDownloader"><span class="nav-number">5.1.</span> <span class="nav-text">下载层SDWebImageDownloader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#具体的下载操作SDWebImageDownloaderOperation"><span class="nav-number">5.1.1.</span> <span class="nav-text">具体的下载操作SDWebImageDownloaderOperation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存层SDImageCache"><span class="nav-number">5.2.</span> <span class="nav-text">缓存层SDImageCache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#底层支持(工具类)"><span class="nav-number">6.</span> <span class="nav-text">底层支持(工具类)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDWebImageDecoder和SDWebImageCompat"><span class="nav-number">6.1.</span> <span class="nav-text">SDWebImageDecoder和SDWebImageCompat</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘得胜</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
