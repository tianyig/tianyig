<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SDWebImage源码阅读笔记 | 得胜的技术博客，谢谢关注</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。
SDWebImage结构首先我们看看SDWebImage的项目组织结构：


Downloader负责图片的异步下载；
Cache负责图片的缓存；
SDWebImageManager是">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage源码阅读笔记">
<meta property="og:url" content="http://yoursite.com/2017/02/27/SDWebImage源码阅读-一/index.html">
<meta property="og:site_name" content="得胜的技术博客，谢谢关注">
<meta property="og:description" content="前言SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。
SDWebImage结构首先我们看看SDWebImage的项目组织结构：


Downloader负责图片的异步下载；
Cache负责图片的缓存；
SDWebImageManager是">
<meta property="og:image" content="http://yoursite.com/assets/images/SDWebImage/01.png">
<meta property="og:image" content="http://yoursite.com/assets/images/SDWebImage/02.png">
<meta property="og:image" content="http://yoursite.com/assets/images/SDWebImage/03.png">
<meta property="og:updated_time" content="2017-03-01T09:40:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDWebImage源码阅读笔记">
<meta name="twitter:description" content="前言SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。
SDWebImage结构首先我们看看SDWebImage的项目组织结构：


Downloader负责图片的异步下载；
Cache负责图片的缓存；
SDWebImageManager是">
  
    <link rel="alternative" href="/atom.xml" title="得胜的技术博客，谢谢关注" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xorsh.com1.z0.glb.clouddn.com/headIcon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">刘得胜</a></h1>
		</hgroup>

		
		<p class="header-subtitle">这城市华灯初上，多两个人悲剧散场</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/iOS开发/" style="font-size: 20px;">iOS开发</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/大并发服务器/" style="font-size: 15px;">大并发服务器</a> <a href="/tags/学术/" style="font-size: 10px;">学术</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/标签/" style="font-size: 10px;">标签</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/源码阅读/" style="font-size: 10px;">源码阅读</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">刘得胜</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xorsh.com1.z0.glb.clouddn.com/headIcon.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">刘得胜</h1>
			</hgroup>
			
			<p class="header-subtitle">这城市华灯初上，多两个人悲剧散场</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-SDWebImage源码阅读-一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/27/SDWebImage源码阅读-一/" class="article-date">
  	<time datetime="2017-02-27T02:55:02.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SDWebImage源码阅读笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><strong>前言</strong></h2><p>SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。</p>
<h2 id="SDWebImage结构"><strong>SDWebImage结构</strong></h2><p>首先我们看看SDWebImage的项目组织结构：</p>
<p><img src="/assets/images/SDWebImage/01.png" alt="img01"></p>
<blockquote>
<p>Downloader负责图片的异步下载；</p>
<p>Cache负责图片的缓存；</p>
<p>SDWebImageManager是总的管理类，维护了一个SDWebImageDownloader实例和一个SDImageCache实例，是下载与缓存的桥梁;SDWebImageDecoder负责图片的解压缩;SDWebImagePrefetcher负责图片的预取;</p>
<p>UIImageView+WebCache和其他的扩展负责给用户提供接口;</p>
</blockquote>
<p>其中，最重要的就是SDWebImageDownloader、SDImageCache、SDWebImageManager三个类，接下来我们就一步步详细分析一下这些类具体如何实现的。</p>
<p>为了便于大家从宏观上有个把握，我这里先给出项目的框架结构:</p>
<p><img src="/assets/images/SDWebImage/02.png" alt="img01"></p>
<p>从这个图我们明显可以看出来，UIImageView+WebCache和UIButton+WebCache负责为用户提供接口；SDWebImageManger负责协调Downloader和Cache，并且为UIKit层提供支持；最底层的两个类为高层抽象提供支持；我们将采用至顶向下分析的方法，一层层分析。</p>
<h2 id="接口层的实现"><strong>接口层的实现</strong></h2><h3 id="UIImageView+WebCache"><strong>UIImageView+WebCache</strong></h3><p>这里我们拿UIImageView+WebCache举例，UIButton+WebCache与此类似。UIImageView+WebCache提供的接口如下：</p>
<pre><code><span class="pp">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这些接口都调用了</p>
<pre><code><span class="pp">- <span class="params">(void)</span>sd_setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageCompletionBlock</span>)</span>completedBlock；</span>
</code></pre><p>这是一种常用的封装的方法，一个函数提供最复杂的实现，其他函数给这个函数在此基础上通过调用的时候提供默认参数，浅浅的封装一层方便用户使用。因为OC函数不支持默认参数(C++支持)，所以需要在提供几个函数包装一下。</p>
<p>这个函数的上半部分实现如下：</p>
<pre><code><span class="list">[<span class="keyword">self</span> sd_cancelCurrentImageLoad]<span class="comment">;</span>
objc_setAssociatedObject<span class="list">(<span class="keyword">self</span>, &amp;imageURLKey, url,     OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><span class="comment">;</span>

if <span class="list">(<span class="keyword">!</span><span class="list">(<span class="keyword">options</span> &amp; SDWebImageDelayPlaceholder)</span>)</span> {
    dispatch_main_async_safe<span class="list">(<span class="keyword">^</span>{
        self.image = placeholder<span class="comment">;</span>
    })</span><span class="comment">;</span>
}</span>
</code></pre><p>在加载一张图片的时候首先取消当前正在加载图片的操作，然后给当前的UIImageView关联一个对应图片的URL，关联的这个url库里本身没有用到，只是暴露出<code>- (NSURL *)sd_imageURL;</code>接口提供给用户使用；if里判断用户是否使用了<code>SDWebImageDelayPlaceholder</code>，如果没有使用就设置<code>placeholder</code>,默认情况没有设置选项，图片在加载完成之前会显示占位图，如果设置了这个选项，会在图片加载完成之后在显示占位图，关于其它选项的具体含义，可以看叶孤城的解析<a href="http://www.jianshu.com/p/6ae6f99b6c4c" title="链接" target="_blank" rel="external">这里</a>。<code>dispatch_main_async_safe</code>是SDWebImage封装的一个保证参数block在主线程执行的宏，宏的实现比较简单，这里不在解释。</p>
<p>我们具体分析一下取消操作是如何实现的，<code>[self sd_cancelCurrentImageLoad]</code>调用了父类<code>UIView+EMWebCacheOperation</code>的函数：</p>
<pre><code><span class="collection">[self sd_cancelImageLoadOperationWithKey:@<span class="string">"UIImageViewImageLoad"</span>]</span><span class="comment">;</span>
</code></pre><p>我们可以看到，这里的key是写死的，因为一个UIImageView在任何时候至多只能对应一种类型的下载操作(可以同时下载image和highlightedImage，两者的key是不一样的)。网络下载以及缓存都是比较耗费系统资源的操作，这么做可以尽量避免资源浪费。例如UITableView在滑动到需要复用UITableViewCell时，如果此时滑出屏幕之前的图片还未加载完成，就没必要在下载了。我们继续深入看父类<code>UIView+EMWebCacheOperation</code>的实现，<code>sd_cancelImageLoadOperationWithKey</code>的全部实现如下：</p>
<pre><code><span class="comment">//这里通过给Category关联属性的方式给每个UIView添加了一个NSMutableDictionary属性，保存了operation或者operation数组;operation从下面可以看出是id &lt;EMSDWebImageOperation&gt;类型,之所以用这样的类型是为了通用性，不局限于使用系统的NSOperation，用户也可以自定义自己的Operation(如SDWebImage里的用到的SDWebImageCombinedOperation)。</span>
<span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];
    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];
    <span class="keyword">if</span> (operations) {
    <span class="comment">//gif图有多张图片，多张图片对应多个operation</span>
        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> class]]) {
            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) {
                <span class="keyword">if</span> (operation) {
                    [operation cancel];
                }
            }
        } <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>{
            <span class="comment">//单个图片，直接调用cancle</span>
            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];
        }
        [operationDictionary removeObjectForKey:key];
    }
</code></pre><p>然后我们接着看sd_setImageWithURL的下半部分的实现，截取部分关键的代码：</p>
<pre><code>__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;
<span class="comment">//创建一个id &lt;SDWebImageOperation&gt;(于UIView+EMWebCacheOperation对应)类型的下载task,</span>
<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) {
          [wself removeActivityIndicator];
        <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
            <span class="comment">//如果用户不希望下载完成直接设置image，就只调用completedBlock</span>
            <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
            {
                completedBlock(image, error, cacheType, url);
                <span class="keyword">return</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (image) {
                wself<span class="variable">.image</span> = image;
                [wself setNeedsLayout];
            } <span class="keyword">else</span> {
                <span class="comment">//下载完成设置placeholder</span>
                <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) {
                    wself<span class="variable">.image</span> = placeholder;
                    [wself setNeedsLayout];
                }
            }
            <span class="keyword">if</span> (completedBlock &amp;&amp; finished) {
                completedBlock(image, error, cacheType, url);
            }
        });
    }];
<span class="comment">//将这个Operation添加到此UIImageView的字典里</span>
[<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];
</code></pre><p>接口层的实现到这里就结束了。这里有几个小问题:</p>
<ul>
<li><strong><font color="red">iOS底层如何实现Category关联属性的？</font></strong></li>
<li><strong><font color="red">iOS的Category如何关联weak属性？</font></strong></li>
</ul>
<h2 id="调度层的实现">调度层的实现</h2><p> 调度层就一个类SDWebImageManager，在头文件中描述如下：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes.<br> It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache).<br> You can use this class directly to benefit from web image downloading with caching in another context than<br> a UIView.</p>
</blockquote>
<p>意思就是SDWebImageManager是位于UIImageView+WebCache之下的用于图片异步下载和缓存的类，你也可以直接使用SDWebImageManager的函数直接下载图片。</p>
<p>SDWebImageManager是一个用dispatch_once实现的单例(关于<font color="red"><strong>dispatch_once底层如何实现的？</strong></font>也是一个有趣的话题，我们以后在讨论它),维护了一个SDImageCache实例和SDWebImageDownloader实例。提供的函数如下：</p>
<p>//初始化SDWebImageManager单例，在init方法中已经初始化了cache单例和downloader单例。</p>
<pre><code>- (instancetype)initWithCache:(SDImageCache *)cache downloader:(SDWebImageDownloader *)downloader;
<span class="comment">//下载图片</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;
<span class="comment">//缓存给定URL的图片</span>
- (<span class="keyword">void</span>)saveImageToCache:(<span class="built_in">UIImage</span> *)image forURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//取消当前所有的操作</span>
- (<span class="keyword">void</span>)cancelAll;
<span class="comment">//监测当前是否有进行中的操作</span>
- (<span class="built_in">BOOL</span>)isRunning;
<span class="comment">//监测图片是否在缓存中， 先在memory cache里面找  再到disk cache里面找</span>
- (<span class="built_in">BOOL</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否缓存在disk里</span>
- (<span class="built_in">BOOL</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否在缓存中,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                     completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//监测图片是否缓存在disk里,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                   completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//返回给定URL的cache key，默认是图片的url</span>
- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url;
</code></pre><p>定义了SDWebImageManagerDelegate协议：</p>
<pre><code><span class="comment">@protocol SDWebImageManagerDelegate </span>

<span class="comment">@optional</span>

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Controls which image should be downloaded when the image is not found in the cache.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to be downloaded</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span>
 <span class="keyword">*</span> 控制在cache中没有找到image时 是否应该去下载。默认是YES。
 <span class="keyword">*</span>/
- (BOOL)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager shouldDownloadImageForURL:(NSURL <span class="keyword">*</span>)imageURL;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.
 <span class="keyword">*</span> NOTE: This method is called from a global queue in order to not to block the main thread.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param image        The image to transform</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to transform</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return The transformed image object.</span>
 <span class="keyword">*</span> 在下载之后，缓存之前转换图片。在全局队列中操作，不阻塞主线程
 <span class="keyword">*</span>/
- (UIImage <span class="keyword">*</span>)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager transformDownloadedImage:(UIImage <span class="keyword">*</span>)image withURL:(NSURL <span class="keyword">*</span>)imageURL;

<span class="comment">@end</span>
</code></pre><p> 我们主要看下</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                        options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options
                                       progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                      completed:<span class="params">(<span class="variable">SDWebImageCompletionWithFinishedBlock</span>)</span>completedBlock</span>
</code></pre><p>这个函数返回<code>id &lt;SDWebImageOperation&gt;</code>类型保存当前UIImageView的下载操作；</p>
<p>首先检查URL是否合法：</p>
<pre><code><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) {
    url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];
}

<span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span>
<span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) {
    url = nil;
}
</code></pre><p>这两个判断都是检查用户传递参数类型是否正确；</p>
<pre><code><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;
<span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) {
    isFailedUrl = [<span class="keyword">self</span><span class="variable">.failedURLs</span> containsObject:url];
}

<span class="keyword">if</span> (url<span class="variable">.absoluteString</span><span class="variable">.length</span> == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
    dispatch_main_sync_safe(^{
        <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];
        completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
    });
    <span class="keyword">return</span> operation;
}
</code></pre><p>若URL对应的image之前下载失败过并且用户没有设置错误重试，直接调用completedBlock；</p>
<pre><code><span class="variable">@synchronized</span> (self.runningOperations) {
    <span class="attr_selector">[self.runningOperations addObject:operation]</span>;
}
</code></pre><p>把当前下载操作加入到runningOperations中，因为runningOperations是多线程共享的，所以要加synchronized控制并发；<strong>synchronized底层是如何实现的呢？</strong>我们在以后的文章里去探究。</p>
<p>SDWebImageManager首先去检查cache(memeory &amp;&amp; disk)中是否缓存过要下载的图片，调用imageCache的</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSOperation</span> *)</span>queryDiskCacheForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key done:<span class="params">(<span class="variable">SDWebImageQueryCompletedBlock</span>)</span>doneBlock</span>
</code></pre><p>函数里首先判断当前操作是否被取消，如果取消从runningOperations中移除，并直接返回：</p>
<pre><code><span class="tag">if</span> (operation.isCancelled) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="attr_selector">[self.runningOperations removeObject:operation]</span>;
    }

    return;
}
</code></pre><p>接下来需要讨论二种情况情况：1.（缓存未找到图片）或（缓存找到了图片但是用户设置了刷新缓存） 2. （用户没有实现shouldDownloadImageForURL协议）或（用户实现了shouldDownloadImageForURL协议并且返回值是YES）</p>
<pre><code>if <span class="list">(<span class="list">(!image || options &amp; SDWebImageRefreshCached)</span> <span class="keyword">&amp;&amp;</span> <span class="list">(![self.delegate respondsToSelector:@selector<span class="list">(<span class="keyword">imageManager</span><span class="keyword">:shouldDownloadImageForURL</span>:)</span>] || [self.delegate imageManager<span class="keyword">:self</span> shouldDownloadImageForURL<span class="keyword">:url</span>])</span>)</span>
</code></pre><p>这两种情况下需要下载图片，上面这一坨就是判断上面的二种情况。</p>
<p>除了上面二种情况还有不需要下载图片的二种情况：1.缓存找到图片 2.缓存未找到图片并且用户禁止下载：</p>
<pre><code><span class="comment">//第一种情况，缓存找到图片(用户未设置刷新缓存并且用户未禁止下载)</span>
<span class="keyword">else</span> <span class="keyword">if</span> (image) {
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) {
            completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
<span class="comment">//第二种情况(缓存未找到且用户通过delegate设置在缓存未找到时禁止下载图片)</span>
<span class="keyword">else</span> {
    <span class="comment">// Image not in cache and download disallowed by delegate</span>
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation<span class="variable">.isCancelled</span>) {
            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
</code></pre><p>如果需要下载图片，就调用</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock</span>
</code></pre><p>下载图片，如果下载失败。直接调用completedBlock返回错误，并根据错误类型将URL添加到failedURLs里。</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">error</span>) {
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(nil, <span class="built_in">error</span>, SDImageCacheTypeNone, finished, url);
        }
    });

    <span class="keyword">if</span> (   <span class="built_in">error</span>.code != NSURLErrorNotConnectedToInternet
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCancelled
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorTimedOut
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorInternationalRoamingOff
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorDataNotAllowed
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotFindHost
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotConnectToHost) {
        @synchronized (<span class="variable">self</span>.failedURLs) {
            [<span class="variable">self</span>.failedURLs addObject:url];
        }
    }
}
</code></pre><p>若图片下载成功，将url从failURLs里删除：</p>
<pre><code><span class="tag">if</span> ((options &amp; SDWebImageRetryFailed)) {
    <span class="variable">@synchronized</span> (self.failedURLs) {
        <span class="attr_selector">[self.failedURLs removeObject:url]</span>;
    }
}
</code></pre><p>这个地方需要解释下，因为<code>[self.failedURLs addObject:url]</code>是<strong>只在下载失败时添加</strong>的，而下载成功和下载失败是互斥的，也就是说，下载成功时failedURLs数组里就不应该有这个url，为什么要这么写呢，这是为了解决竞态条件下的问题，若两个线程下载同一个url的图片，若第一个线程下载失败，第二个下载成功。如果不从failedURLs移除这个url的话，以后下载此url的图片都会失败。</p>
<p>然后处理下载完成的图片：</p>
<pre><code><span class="comment">//是否设置了只缓存内存</span>
BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

<span class="comment">//设置刷新缓存且cache找到图片且NSURLCache找到图片，不处理</span>
<span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) {
    <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span>
}
<span class="comment">//若delegate实现imageManager:transformDownloadedImage:withURL:方法，在缓存之前，需要做调用此delegate方法转换</span>
<span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="annotation">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) {
    <span class="comment">//在全局队列中转换，不阻塞主线程dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{</span>
        UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];
        <span class="comment">//转换成功后，存入缓存</span>
        <span class="keyword">if</span> (transformedImage &amp;&amp; finished) {
            BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];
            [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">recalculateFromImage:</span>imageWasTransformed <span class="string">imageData:</span>(imageWasTransformed ? nil : data) <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
        }
        <span class="comment">//缓存成功之后，调用completedBlock</span>
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
                completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);
            }
        });
    });
}
<span class="keyword">else</span> {
    <span class="comment">//没有实现转换的delegate，就不做转换直接缓存</span>
    <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) {
        [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
    }
    <span class="comment">//缓存成功之后，调用completedBlock</span>
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);
        }
    });
}
</code></pre><p>}</p>
<p>下载完成之后，从队列里移除：</p>
<pre><code><span class="tag">if</span> (finished) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="tag">if</span> (strongOperation) {
            <span class="attr_selector">[self.runningOperations removeObject:strongOperation]</span>;
        }
    }
}
</code></pre><p>最后说下返回的<code>SDWebImageCombinedOperation</code>类型，这个类型包含<code>NSOperation *cacheOperation</code>的一个子类型，其中<code>cacheOperation</code>中又存在<code>id &lt;SDWebImageOperation&gt;</code>的下载图片的<code>subOperation</code>。在<code>cancel</code>的时候也应该把这两个操作都<code>cancle</code>。</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">self</span><span class="variable">.cancelled</span> = <span class="literal">YES</span>;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cacheOperation</span>) {
        [<span class="keyword">self</span><span class="variable">.cacheOperation</span> cancel];
        <span class="keyword">self</span><span class="variable">.cacheOperation</span> = <span class="literal">nil</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) {
        <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

        <span class="comment">// <span class="doctag">TODO:</span> this is a temporary fix to #809.</span>
        <span class="comment">// Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span>
<span class="comment">//        self.cancelBlock = nil;</span>
        _cancelBlock = <span class="literal">nil</span>;
    }
}
</code></pre><p>所以<code>CombinedOperation</code>在<code>cancel</code>的时候会先cancel掉自己的<code>cacheOperation</code>,在调用自己的<code>cancelBlock</code>。</p>
<pre><code><span class="label">operation.cancelBlock</span> = ^{
    [<span class="keyword">subOperation </span>cancel]<span class="comment">;</span>


    <span class="comment">@synchronized (self.runningOperations) {</span>
        __strong __typeof(weakOperation) <span class="keyword">strongOperation </span>= weakOperation<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">strongOperation) </span>{
            [<span class="keyword">self.runningOperations </span>removeObject:<span class="keyword">strongOperation];
</span>        }
    }
}<span class="comment">;</span>
</code></pre><p>在自己的<code>cancelBlock</code>把下载操作<code>subOperation</code>取消掉。由此可见封装的<code>CombinedOperation</code>包含了下载和缓存的操作，使代码变得更简洁。</p>
<h2 id="下载和缓存层"><strong>下载和缓存层</strong></h2><h3 id="下载层"><strong>下载层</strong></h3><p>SDWebImageDownloader提供的方法有以下几个：</p>
<pre><code><span class="comment">//给每个HTTP下载请求头的指定field设置值。</span>
- (<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//返回HTTP特定field的值</span>
- (<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//设置一个SDWebImageDownloaderOperation的子类作为下载请求的默认NSOperation</span>
- (<span class="keyword">void</span>)setOperationClass:(Class)operationClass;
<span class="comment">//创建一个SDWebImageDownloader异步下载实例，图片下载完成或错误时，通知delegate回调。方法返回一个 SDWebImageOperation</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                     options:(SDWebImageDownloaderOptions)options
                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
<span class="comment">// 设置下载队列为挂起状态</span>
- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended;
<span class="comment">//取消队列中的所有操作。</span>
- (<span class="keyword">void</span>)cancelAllDownloads;
</code></pre><p>我们重点研究下载方法：</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                     options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
                                    progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                   completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这几个参数的含义代码注释里都有，这里就不再一一解释。</p>
<pre><code>__block SDWebImageDownloaderOperation *operation;
__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;

[<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
    <span class="comment">//block实现</span>
    ...
    operation = [[wself<span class="variable">.operationClass</span> alloc] initWithRequest:request
                                                      options:options
                                                     progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize)
    ...
}];

<span class="keyword">return</span> operation;
</code></pre><p>上面是这个方法的框架，可以看出主要调用了<code>addProgressCallback</code>方法，方法的内部创建了下载的<code>operation</code>。我们首先看看<code>addProgressCallback</code>方法的实现:</p>
<pre><code><span class="comment">//如果url为nil，调用completedBlock后return</span>
<span class="keyword">if</span> (url == <span class="literal">nil</span>) {
    <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) {
        completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
    }
    <span class="keyword">return</span>;
}

<span class="comment">//允许多线程下载，使用了并发控制，避免同时修改URLCallbacks</span>
dispatch_barrier_sync(<span class="keyword">self</span><span class="variable">.barrierQueue</span>, ^{
    <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;
    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url]) {
        <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = [<span class="built_in">NSMutableArray</span> new];
        first = <span class="literal">YES</span>;
    }

    <span class="comment">// Handle single download of simultaneous download request for the same URL</span>
    <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url];
    <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];
    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];
    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];
    [callbacksForURL addObject:callbacks];
    <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = callbacksForURL;

    <span class="keyword">if</span> (first) {
        createCallback();
    }
});
</code></pre><p>这里的并发控制的地方为什么要使用<code>dispatch_barrier_sync</code>，是因为<code>dispatch_barrier_sync</code>这个函数可以设置一个同步执行block，它会等到在这个block加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。。这里的<code>dispatch_barrier_sync</code>实际上相当于一个写锁，任何写操作(删除，添加)，都要在之前的写操作完成后执行，而之后的写操作，也要在之前的的写操作完成之后执行。</p>
<p>URLCallbacks是一个以url作为key的字典，字典的value是一个数组，数组的元素是一个字典。可以看出<code>URLCallbacks</code>、<code>callbacksForURL</code>、<code>callbacks</code>之间的关系如下图：</p>
<p><img src="/assets/images/SDWebImage/03.png" alt="img01"></p>
<p>如果URLCallbacks以url对应的value是空，说明是第一次请求这个url，需要调用<code>createCallback</code>创建下载任务，即调用：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
        inSession:<span class="params">(<span class="variable">NSURLSession</span> *)</span>session
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>设置默认超时时间15s，然后使用此<code>request</code>创建一个<code>SDWebImageDownloaderOperation</code>,方便把这个下载任务添加到下载队列里：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>重点看下这个方法的三个block，第一个progress，取出存储在URLCallbacks中的progressBlock并调用：</p>
<pre><code><span class="comment">//只是读操作，dispatch_sync即可</span>
 <span class="built_in">dispatch_sync</span>(sself<span class="variable">.barrierQueue</span>, ^{
     callbacksForURL = [sself<span class="variable">.URLCallbacks</span>[url] <span class="keyword">copy</span>];
 });
 <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) {
     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
         SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
         <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);
     });
 }
</code></pre><p>同理，<code>completed</code>也是从URLCallbacks中的completedBlock并调用：</p>
<pre><code><span class="comment">//这里有写操作，须用dispatch_barrier_sync</span>
dispatch_barrier_sync(sself.barrierQueue, ^{
    callbacksForURL = [sself.URLCallbacks[url] copy];
    <span class="keyword">if</span> (finished) {
        [sself.URLCallbacks removeObjectForKey:url];
    }
});
<span class="keyword">for</span> (NSDictionary *callbacks <span class="keyword">in</span> callbacksForURL) {
    <span class="comment">//这里为什么不像progressBlock一样使用dispatch_async(dispatch_get_main_queue()？</span>
    SDWebImageDownloaderCompletedBlock <span class="keyword">callback</span> = callbacks[kCompletedCallbackKey];
    <span class="keyword">if</span> (<span class="keyword">callback</span>) <span class="keyword">callback</span>(image, data, error, finished);
}
</code></pre><p>不同图片的下载任务会异步完成，所以要等待其他图片下载完成，并执行完<code>completedBlock</code>中对<code>URLCallbacks</code>的操作，才能继续之后的操作。</p>
<pre><code>cancelled:^{
    SDWebImageDownloader *sself = wself<span class="comment">;</span>
    if (!sself) return<span class="comment">;</span>
    dispatch_barrier_async(sself.barrierQueue, ^{
        [sself.URLCallbacks removeObjectForKey:url]<span class="comment">;</span>
    })<span class="comment">;</span>
}
</code></pre><p>取消时用的<code>dispatch_barrier_async</code>,dispatch_barrier_async表示的是先等之前的执行完成，然后把该barrier放入queue中，而不等待barrier中代码执行结束，而dispat_barrier_sync表示需要等待barrier中代码执行结束。</p>
<p>然后设置operation</p>
<pre><code><span class="comment">//是否解压下载的图片</span>
operation.shouldDecompressImages = wself.shouldDecompressImages;
<span class="comment">//有证书设置证书</span>
<span class="keyword">if</span> (wself.urlCredential) {
    operation.credential = wself.urlCredential;
} <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) {
    operation.credential = [NSURLCredential <span class="string">credentialWithUser:</span>wself.username <span class="string">password:</span>wself.password <span class="string">persistence:</span>NSURLCredentialPersistenceForSession];
}
<span class="comment">//设置优先级</span>
<span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) {
    operation.queuePriority = NSOperationQueuePriorityHigh;
} <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) {
    operation.queuePriority = NSOperationQueuePriorityLow;
}

[wself.downloadQueue <span class="string">addOperation:</span>operation];
<span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
    <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span>
    [wself.lastAddedOperation <span class="string">addDependency:</span>operation];
    wself.lastAddedOperation = operation;
}
</code></pre><p>最后将这个下载的操作加入到下载队列里。下载方式有两种，FIFO和LIFO。最后根据下载的方式调增任务的依赖。</p>
<h3 id="SDWebImageDownloaderOperation"><strong>SDWebImageDownloaderOperation</strong></h3><p>上面的<code>SDWebImageDownloader</code>主要操作就是创建<code>SDWebImageDownloaderOperation</code>添加到下载队列里，可知具体的操作是在<code>SDWebImageDownloaderOperation</code>，我们研究下具体是如何下载的。首先这个类是继承于<code>NSOperation</code>，并重写了<code>start</code>方法。我们首先看看它的<code>start</code>方法的实现：</p>
<p>检测下载状态</p>
<pre><code><span class="comment">//管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span>
<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) {
    <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    [<span class="keyword">self</span> reset];
    <span class="keyword">return</span>;
}
</code></pre><p>如果是iOS4.0以上的版本，需要设置后台执行的操作：</p>
<pre><code><span class="comment">//作为具体的下载操作，尽量不依赖其他类，所以这里使用字符串创建</span>
Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);
<span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];
<span class="comment">//如果用户设置了后台下载</span>
<span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) {
    <span class="comment">//如果设置了在后台执行，则进行后台执行</span>
     __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    <span class="comment">//向系统申请更长的时间执行下载操作</span>
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = [app beginBackgroundTaskWithExpirationHandler:^{
        <span class="comment">// 如果在系统规定时间内任务还没有完成（一般是10分钟），结束后台任务</span>
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;
        <span class="keyword">if</span> (sself) {
            [sself cancel];
            [app endBackgroundTask:sself<span class="variable">.backgroundTaskId</span>];
            sself<span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
        }
    }];
｝
</code></pre><p>这里注册的block会在APP进入后台时执行，block里调用<code>cancel</code>对应的<code>endBackgroundTask</code>,这个block的主要目的是持有<code>self</code>不要被系统销毁，只要<code>self</code>不被系统销毁，当前下载操作就可以继续执行。<code>self</code>被销毁后，我们看看<code>cancel</code>操作做了什么：</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.thread</span>) {
            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelInternalAndStop) onThread:<span class="keyword">self</span><span class="variable">.thread</span> withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];
        }
        <span class="keyword">else</span> {
            [<span class="keyword">self</span> cancelInternal];
        }
    }
}

- (<span class="keyword">void</span>)cancelInternalAndStop {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">self</span> cancelInternal];
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
}

- (<span class="keyword">void</span>)cancelInternal {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">super</span> cancel];
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.connection</span>) {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
        });

        <span class="comment">// As we cancelled the connection, its callback won't be called and thus won't</span>
        <span class="comment">// maintain the isFinished and isExecuting flags.</span>
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isExecuting</span>) <span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">NO</span>;
        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    }

    [<span class="keyword">self</span> reset];
}
</code></pre><p>底下有三个和<code>cancel</code>相关的操作，如果当前线程存在，在当前线程调用<code>cancelInternalAndStop</code>，否者调用<code>cancelInternal</code>;这两者的区别是<code>cancelInternalAndStop</code>中多了一句<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>,在中止当前线程的时候，也要关闭对应的RunLoop。<code>cancelInternal</code>做了几件事：</p>
<ul>
<li>调用自定义的cancelBlock</li>
<li>调用NSURLConnection的cancel取消self.connection</li>
<li>回收资源</li>
<li>抛出通知</li>
</ul>
<p>注册的后台操作是在进入到后台如果<code>NSOperation</code>未执行完成才执行的，假如在进入到后台之前<code>NSOperation</code>已经完成了呢？</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.backgroundTaskId</span> != <span class="built_in">UIBackgroundTaskInvalid</span>) {
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    [app endBackgroundTask:<span class="keyword">self</span><span class="variable">.backgroundTaskId</span>];
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
}
</code></pre><p>如果下载任务完成，中止后台操作，将backgroundTaskId置为UIBackgroundTaskInvalid。</p>
<p>注册后台操作的准备工作完成之后，就该开始下载了：</p>
<pre><code><span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">YES</span>;
<span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span><span class="variable">.request</span> delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];
<span class="keyword">self</span><span class="variable">.thread</span> = [<span class="built_in">NSThread</span> currentThread];
</code></pre><p>初始化相关的数据，创建<code>NSURLConnection</code>,如果创建失败就调用<code>completedBlock</code>,成功就启动下载，关键代码如下：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
    <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);
}
....
<span class="built_in">CFRunLoopRun</span>();
....
<span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) {
    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    [<span class="keyword">self</span> connection:<span class="keyword">self</span><span class="variable">.connection</span> didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@{<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>}]];
}
</code></pre><p>使用<code>NSURLConnection</code>调用了<code>[self.connection start]</code>后，<code>NSURLConnection</code>的delegate就会不停收到事件回调。当这个connection完成或者终止，才会跳出CFRunLoopRun()(可以理解为CFRunLoopRun阻塞了当前线程)。当跳出Runloop后，就要判断NSURLConnection是不是正常完成任务了。如果没有，也就是说self.isFinished == NO。那么就取消该connection，并且调用</p>
<pre><code>(<span class="typename">void</span>)<span class="string">connection:</span>(NSURLConnection *)connection <span class="string">didFailWithError:</span>(NSError *)error;
</code></pre><p>返回错误信息。然后就是<code>NSURLConnection</code>几个delegate过程的处理：</p>
<pre><code><span class="comment">//如果是304代表服务端资源未改变，可直接使用客户端未过期的资源，此时需要取消operation并返回缓存中的image，code小于400说明请求成功</span>
<span class="comment">//如果响应成功，开始初始化数组，准备接收imageData</span>
<span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] != <span class="number">304</span>)) {
    <span class="built_in">NSInteger</span> expected = response<span class="variable">.expectedContentLength</span> &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response<span class="variable">.expectedContentLength</span> : <span class="number">0</span>;
    <span class="keyword">self</span><span class="variable">.expectedSize</span> = expected;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
        <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, expected);
    }

    <span class="keyword">self</span><span class="variable">.imageData</span> = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];
    <span class="keyword">self</span><span class="variable">.response</span> = response;
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];
    });
}
<span class="comment">//请求失败之后，抛通知并清理相关资源</span>
<span class="keyword">else</span> {
    <span class="built_in">NSUInteger</span> code = [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode];

    <span class="comment">//This is the case when server returns '304 Not Modified'. It means that remote image is not changed.</span>
    <span class="comment">//In case of 304 we need just cancel the operation and return cached image from the cache.</span>
    <span class="keyword">if</span> (code == <span class="number">304</span>) {
        [<span class="keyword">self</span> cancelInternal];
    } <span class="keyword">else</span> {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    }
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
    });

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="keyword">self</span><span class="variable">.completedBlock</span>(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:[((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] userInfo:<span class="literal">nil</span>], <span class="literal">YES</span>);
    }
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
    [<span class="keyword">self</span> done];
}
</code></pre><p>然后在下载过程中接收数据，以下是部分代码：</p>
<pre><code><span class="keyword">if</span> (partialImageRef) {
    <span class="comment">//把data转换成image</span>
    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:partialImageRef scale:<span class="number">1</span> orientation:orientation];
    <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>];
    <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];
    <span class="comment">//判断是否要解解码，默认是需要解码，解码的操作是在子线程里(delegate在子线程执行的)</span>
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) {
        image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];
    }
    <span class="keyword">else</span> {
        image = scaledImage;
    }
    <span class="built_in">CGImageRelease</span>(partialImageRef);
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="comment">//显示在imageView上（不一定下载完，可以显示一部分）</span>
            <span class="keyword">self</span><span class="variable">.completedBlock</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
        }
    });
}
</code></pre>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/12/13/大并发服务器/四、epoll函数/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">四、epoll函数</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="SDWebImage源码阅读-一" data-title="SDWebImage源码阅读笔记" data-url="http://yoursite.com/2017/02/27/SDWebImage源码阅读-一/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 刘得胜
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>