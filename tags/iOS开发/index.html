
<!DOCTYPE html>
<html lang="null">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="得胜的技术博客，谢谢关注">
    <title>標籤: iOS开发 - 得胜的技术博客，谢谢关注</title>
    <meta name="author" content="刘得胜">
    
    
    
    <meta name="description">
<meta property="og:type" content="blog">
<meta property="og:title" content="得胜的技术博客，谢谢关注">
<meta property="og:url" content="http://yoursite.com/tags/iOS开发/index.html">
<meta property="og:site_name" content="得胜的技术博客，谢谢关注">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="得胜的技术博客，谢谢关注">
<meta name="twitter:description">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css" type="text/css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">得胜的技术博客，谢谢关注</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="/#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="/#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/03/10/Autorelease的原理与实现/">
                            Autorelease的原理与实现
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-03-10T13:32:24+08:00">
	
		    Mar 10, 2017
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="前言"><strong>前言</strong></h2><p>众所周知，在C/C++中内存管理是非常重要的内容，内存管理是C／C++程序员的基本功，为了方便内存管理，C++的库(STL&amp;&amp;Boost)提供了各种智能指针的实现。同样在iOS MRC时代，iOS的开发也是需要手动内存管理，手动内存管理麻烦而且容易出错，严重影响程序健壮性和开发效率。为了改善这种情况，苹果在iOS5推出了新功能ARC(Automatic Reference Counting)。ARC是如何实现的？objc和编译器底层帮我们做了哪些事情，它们是如何管理内存的？</p>
<h2 id="Autorelease"><strong>Autorelease</strong></h2><p>在MRC时代，<code>alloc</code>创建的对象必须在对象生命周期结束时调用<code>release</code>或者在创建之初调用<code>autorelease</code>。如下：</p>
<pre><code>方式1
NSObject *testObj = <span class="comment">[<span class="comment">[NSObject alloc]</span>init]</span>;
//insert code
<span class="comment">[testObj release]</span>;

方式2
NSObject *testObj = <span class="comment">[<span class="comment">[<span class="comment">[NSObject alloc]</span>init]</span> autorelease]</span>;
</code></pre><p>内存管理的第一原则：谁创建，谁释放。所以方式1我们很容易理解；方式2是如何管理对象的生命周期的？其实调用<code>autorelease</code>方法其实是把当前对象添加到<code>autoreleasepool</code>中管理，我们就不需要手动释放了。</p>
<h2 id="@autoreleasepool"><strong>@autoreleasepool</strong></h2><p>iOS工程<code>main.m</code>中<code>main</code>函数的实现如下：</p>
<pre><code><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {  
    <span class="keyword">@autoreleasepool</span> {
        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));
    }
}
</code></pre><p>main函数的的业务实现我们不关心，我们只关心<code>@autoreleasepool</code>到底是什么，为了方便，我们改写main函数如下：</p>
<pre><code><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="built_in">NSObject</span> *objTest = [[<span class="built_in">NSObject</span> alloc]init];
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>在命令行中使用<code>clang -rewrite-objc main.m</code>让编译器用<code>C++</code>改写这个函数,改写后的代码简化如下：</p>
<pre><code><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {
    <span class="comment">/* @autoreleasepool */</span> { __AtAutoreleasePool __autoreleasepool; 
        <span class="built_in">NSObject</span> *objTest = ((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p><code>@autoreleasepool</code>在改写后被注释掉了，同时在作用域的第一行生成了一个<code>__AtAutoreleasePool</code>的C++对象，全局搜索可以看到<code>__AtAutoreleasePool</code>定义如下：</p>
<pre><code>struct __AtAutoreleasePool {
  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush()<span class="comment">;}</span>
  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj)<span class="comment">;}</span>
  void * atautoreleasepoolobj<span class="comment">;</span>
}<span class="comment">;</span>
</code></pre><p>这个结构体(和class的唯一区别是不能定义私有变量或私有函数)只有一个构造函数和析构函数，析构函数是在作用域结束时自动调用的，所以<code>main</code>函数代码等价如下：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{  
    {
        <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();
        <span class="comment">//other operator</span>
         objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>然后看下这两个函数的实现：</p>
<pre><code><span class="function"><span class="keyword">void</span> *
<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">return</span> AutoreleasePoolPage::push();
}

<span class="function"><span class="keyword">void</span>
<span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span>
</span>{
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre><p>可以看出只是简单的对<code>AutoreleasePoolPage</code>的封装。<code>AutoreleasePoolPage</code>又是什么？下面就从它的结构和实现上逐步剖析<code>AutoreleasePoolPage</code>。</p>
<h3 id="AutoreleasePoolPage的结构"><em>AutoreleasePoolPage的结构</em></h3><p>它的结构如下：</p>
<pre><code><span class="keyword">class</span> AutoreleasePoolPage {  
    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;
    id *next;
    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;
    AutoreleasePoolPage * <span class="keyword">const</span> parent;
    AutoreleasePoolPage *child;
    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;
    <span class="keyword">uint32_t</span> hiwat;
};
</code></pre><ol>
<li>magic 用来校验 AutoreleasePoolPage 的结构是否完整；</li>
<li>next 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；</li>
<li>thread 指向当前线程；</li>
<li>parent 指向父结点，第一个结点的 parent 值为 nil ；</li>
<li>child 指向子结点，最后一个结点的 child 值为 nil ；</li>
<li>depth 代表深度，从 0 开始，往后递增 1；</li>
<li>hiwat 代表 high water mark。</li>
</ol>
<h3 id="push操作"><em>push操作</em></h3><p><code>objc_autoreleasePoolPush()</code>函数实际上调用了<code>AutoreleasePoolPage::push()</code>函数。</p>
<pre><code><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> 
</span>{
    id *dest;
    dest = autoreleaseFast(POOL_BOUNDARY);
    <span class="keyword">return</span> dest;
}
</code></pre><p>其中<code>POOL_BOUNDARY</code>是<code>nil</code>的宏定义</p>
<pre><code><span class="preprocessor">#   <span class="keyword">define</span> POOL_BOUNDARY nil`</span>
</code></pre><p>在首次创建AutoRelease Pool的时候插入一个nil值表示嵌套的<code>AutoreleasePool</code>的边界。</p>
<p>push函数调又<code>autoreleaseFast</code>实现具体的插入：</p>
<pre><code>static <span class="keyword">inline</span> id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    <span class="keyword">if</span> (page <span class="subst">&amp;&amp;</span> <span class="subst">!</span>page<span class="subst">-&gt;</span><span class="literal">full</span>()) {
        <span class="keyword">return</span> page<span class="subst">-&gt;</span>add(obj);
    } <span class="keyword">else</span> <span class="keyword">if</span> (page) {
        <span class="keyword">return</span> autoreleaseFullPage(obj, page);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> autoreleaseNoPage(obj);
    }
}
</code></pre><p>插入新元素的时候分三种情况需要处理：</p>
<ol>
<li>当前page未满，直接插入到当前page</li>
<li>当前page已满，创建一个新page并插入</li>
<li>当前page不存在，创建一个新page并插入</li>
</ol>
<p>这三种情况最终都会调用<code>page-&gt;add(obj)</code>：</p>
<pre><code>id *add(id obj)
{
    assert(!full())<span class="comment">;</span>
    unprotect()<span class="comment">;</span>
    id *ret = next<span class="comment">;</span>
    *next++ = obj<span class="comment">;</span>
    protect()<span class="comment">;</span>
    return ret<span class="comment">;</span>
}
</code></pre><p>首先断言当前page非满(<code>next != end()</code>),然后解除当前页保护(因为要插入，要使当前页可读可写),更新<code>next</code>指针地址，返回插入的元素地址。第一次初始化<code>autoreleasepool</code>时,传的nil值，返回值是nil值所在的地址。</p>
<h3 id="Pop操作"><em>Pop操作</em></h3><p>同上，<code>objc_autoreleasePoolPop</code> 实际调用了<code>AutoreleasePoolPage::pop(ctxt)</code>,传入的参数是初始化是返回的<code>nil</code>值的地址:</p>
<pre><code>static <span class="keyword">inline</span> <span class="literal">void</span> pop(<span class="literal">void</span> *token) 
{
    AutoreleasePoolPage *page;
    id *stop;

    <span class="keyword">if</span> (token == (<span class="literal">void</span>*)EMPTY_POOL_PLACEHOLDER) {
        <span class="keyword">if</span> (hotPage()) {
            pop(coldPage()<span class="subst">-&gt;</span>begin());
        } <span class="keyword">else</span> {
            setHotPage(nil);
        }
        <span class="keyword">return</span>;
    }

    page = pageForPointer(token);
    stop = (id *)token;
    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) {
        <span class="keyword">if</span> (stop == page<span class="subst">-&gt;</span>begin()  <span class="subst">&amp;&amp;</span>  <span class="subst">!</span>page<span class="subst">-&gt;</span><span class="keyword">parent</span>) {
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> badPop(token);
        }
    }

    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();

    page<span class="subst">-&gt;</span>releaseUntil(stop);

    <span class="comment">// memory: delete empty children</span>
      <span class="keyword">if</span> (page<span class="subst">-&gt;</span>lessThanHalfFull()) {                page<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>kill();
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (page<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>child) {
        page<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>child<span class="subst">-&gt;</span>kill();
   }
}
</code></pre><p><code>pop</code>的参数的含义是需要<code>pop</code>到参数元素所在的地址，Pop的时候首先判断是不是<code>EMPTY_POOL_PLACEHOLDER</code>, <code>EMPTY_POOL_PLACEHOLDER</code>的解释如下：</p>
<blockquote>
<p>EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is pushed and it has never contained any objects. This saves memory when the top level (i.e. libdispatch) pushes and pops pools but never uses them.</p>
</blockquote>
<p><code>EMPTY_POOL_PLACEHOLDER</code>是存储在TLS中的用来表示链表最上层没有元素的<code>pool</code>,这样就不用创建<code>pool</code>可以节约内存。TLS是什么以及具体实现<a href="http://blog.csdn.net/cywosp/article/details/26469435" target="_blank" rel="external">这篇文章</a>介绍的比较详细，这里不在解释。如果<code>pool</code>里面有数据，就把里面的数据清空；否者就把<code>hotPage</code>设置为<code>nil</code>。接着调用<code>page-&gt;releaseUntil(stop)</code>给此参数之前的所有对象发送<code>release</code>释放内存，对象内存释放之后，<code>终点page</code>之前的<code>page</code>都会变成空的，最后调用<code>page-&gt;child-&gt;kill()</code>回收这些<code>空page</code>资源。</p>
<p>假设某个线程的autoreleasepool的结构如下图所示，这个autoreleasepool的堆栈里有两个<code>POOL_SENTINEL</code>，说明代码里嵌套了两个autoreleasepool，在整个双向链表里，起始的第一个page为<code>coldPage</code>，最新的最后一个是<code>hotpage</code>。<code>hotPage</code>里保存了最新添加的对象:</p>
<p><img src="/assets/images/autorelease/AutoreleasePoolPage1.png" alt="img01"></p>
<p>此时，如果执行<code>pop(POOL_BOUNDARY)</code>操作，那么<code>autoreleasepool</code>的堆栈结构会变成下图：</p>
<p><img src="/assets/images/autorelease/AutoreleasePoolPage2.png" alt="img01"></p>
<p>所以处理嵌套的<code>autoreleasepool</code>就很简单了，因为<code>autoreleasepool</code>与<code>autoreleasepool</code>之间用特殊的标记分割了，每个<code>autoreleasepool</code>的释放只需要释放到指定位置(初始化时push的nil指针的地址)即可,内层与外层互相不影响。</p>
<h2 id="autorelease操作"><strong>autorelease操作</strong></h2><p>我们已经清楚了<code>autoreleasepool</code>的结构以及<code>autoreleasepool</code>对对象的管理方式，那么我们自己创建的对象是怎么和<code>autoreleasepool</code>关联的？在MRC中,<code>autorelease</code>的调用例如<code>[[[NSObject alloc]init] autorelease]</code>调用堆栈如下：</p>
<p><img src="/assets/images/autorelease/page3.jpeg" alt="img01"></p>
<p><code>autorelease</code>转发给了<code>rootAutorelease</code>调用:</p>
<pre><code>- (<span class="keyword">id</span>)autorelease {
    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();
}

<span class="keyword">inline</span> <span class="keyword">id</span> 
objc_object::rootAutorelease()
{
    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;
    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;

    <span class="keyword">return</span> rootAutorelease2();
}
</code></pre><p><code>rootAutorelease</code>首先判断是不是<code>Tagged Pointer</code>,是的话直接返回，因为<code>Tagged Pointer</code>是栈上的对象，不需要内存管理(文末有解释)。接着用<code>__builtin_return_address</code>判断外部是不是ARC环境。最终调用<code>autoreleaseFast</code>将对象插入到<code>autoreleasepool</code>中。</p>
<pre><code>static <span class="keyword">inline</span> id *autoreleaseFast(id obj)
{
    AutoreleasePoolPage *page = hotPage();
    <span class="keyword">if</span> (page <span class="subst">&amp;&amp;</span> <span class="subst">!</span>page<span class="subst">-&gt;</span><span class="literal">full</span>()) {
        <span class="keyword">return</span> page<span class="subst">-&gt;</span>add(obj);
    } <span class="keyword">else</span> <span class="keyword">if</span> (page) {
        <span class="keyword">return</span> autoreleaseFullPage(obj, page);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> autoreleaseNoPage(obj);
    }
}
</code></pre><p>可以看出，在MRC中，通过对象主动调用<code>autorelease</code>的方式将对象加入到<code>autoreleasepool</code>的管理。那么在ARC中是怎么处理的呢？</p>
<p>在ARC环境下，我们改写main函数如下：<br>    int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        NSString </em>testObj = [[NSObject alloc]init];<br>        @autoreleasepool {<br>            NSObject *objTest2 = [[NSObject alloc]init];<br>            objTest2 = testObj;<br>        }<br>    }<br>    return 0;<br>}</p>
<p>然后使用<code>clang -S -fobjc-arc -emit-llvm main.m -o main.cc</code>生成IR中间代码，截取关键部分如下：</p>
<pre><code><span class="xml">define i32 @main(i32, i8**) #0 {
</span><span class="perl">  <span class="variable">%3</span> = alloca i32, align <span class="number">4</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%4</span> = alloca i32, align <span class="number">4</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%5</span> = alloca i8**, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%6</span> = alloca <span class="variable">%0</span>*, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%7</span> = alloca <span class="variable">%1</span>*, align <span class="number">8</span></span><span class="xml">
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
</span><span class="perl">  <span class="variable">%8</span> = call i8* <span class="variable">@objc_autoreleasePoolPush</span>() <span class="comment">#2</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%9</span> = load <span class="variable">%struct</span>._class_t*, <span class="variable">%struct</span>._class_t** <span class="variable">@"</span>OBJC_CLASSLIST_REFERENCES<span class="number">_</span><span class="variable">$_</span><span class="string">", align 8</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%10</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>, align 8, !invariant.load !7</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%11</span> = bitcast <span class="variable">%struct</span>._class_t* <span class="variable">%9</span> to i8*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%12</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%11</span>, i8* <span class="variable">%10</span>)</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%13</span> = bitcast i8* <span class="variable">%12</span> to <span class="variable">%1</span>*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%14</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>.2, align 8, !invariant.load !7</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%15</span> = bitcast <span class="variable">%1</span>* <span class="variable">%13</span> to i8*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%16</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%15</span>, i8* <span class="variable">%14</span>)</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%17</span> = bitcast i8* <span class="variable">%16</span> to <span class="variable">%1</span>*</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%18</span> = bitcast <span class="variable">%1</span>* <span class="variable">%17</span> to <span class="variable">%0</span>*</span></span><span class="xml">
  store %0* %18, %0** %6, align 8
</span><span class="perl"><span class="string">  <span class="variable">%19</span> = call i8* <span class="variable">@objc_autoreleasePoolPush</span>() #2</span></span><span class="xml">
</span><span class="perl"><span class="string">  <span class="variable">%20</span> = load <span class="variable">%struct</span>._class_t*, <span class="variable">%struct</span>._class_t** <span class="variable">@"</span>OBJC_CLASSLIST_REFERENCES_<span class="variable">$_</span>"</span>, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%21</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>, align <span class="number">8</span>, !invariant.load !<span class="number">7</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%22</span> = bitcast <span class="variable">%struct</span>._class_t* <span class="variable">%20</span> to i8*</span><span class="xml">
</span><span class="perl">  <span class="variable">%23</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%22</span>, i8* <span class="variable">%21</span>)</span><span class="xml">
</span><span class="perl">  <span class="variable">%24</span> = bitcast i8* <span class="variable">%23</span> to <span class="variable">%1</span>*</span><span class="xml">
</span><span class="perl">  <span class="variable">%25</span> = load i8*, i8** <span class="variable">@OBJC_SELECTOR_REFERENCES_</span>.<span class="number">2</span>, align <span class="number">8</span>, !invariant.load !<span class="number">7</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%26</span> = bitcast <span class="variable">%1</span>* <span class="variable">%24</span> to i8*</span><span class="xml">
</span><span class="perl">  <span class="variable">%27</span> = call i8* bitcast (i8* (i8*, i8*, ...)* <span class="variable">@objc_msgSend</span> to i8* (i8*, i8*)*)(i8* <span class="variable">%26</span>, i8* <span class="variable">%25</span>)</span><span class="xml">
</span><span class="perl">  <span class="variable">%28</span> = bitcast i8* <span class="variable">%27</span> to <span class="variable">%1</span>*</span><span class="xml">
  store %1* %28, %1** %7, align 8
</span><span class="perl">  <span class="variable">%29</span> = load <span class="variable">%0</span>*, <span class="variable">%0</span>** <span class="variable">%6</span>, align <span class="number">8</span></span><span class="xml">
</span><span class="perl">  <span class="variable">%30</span> = bitcast <span class="variable">%0</span>* <span class="variable">%29</span> to <span class="variable">%1</span>*</span><span class="xml">
</span><span class="perl">  <span class="variable">%31</span> = bitcast <span class="variable">%1</span>** <span class="variable">%7</span> to i8**</span><span class="xml">
</span><span class="perl">  <span class="variable">%32</span> = bitcast <span class="variable">%1</span>* <span class="variable">%30</span> to i8*</span><span class="xml">
  call void @objc_storeStrong(i8** %31, i8* %32) #2
</span><span class="perl">  <span class="variable">%33</span> = bitcast <span class="variable">%1</span>** <span class="variable">%7</span> to i8**</span><span class="xml">
  call void @objc_storeStrong(i8** %33, i8* null) #2
  call void @objc_autoreleasePoolPop(i8* %19)
</span><span class="perl">  <span class="variable">%34</span> = bitcast <span class="variable">%0</span>** <span class="variable">%6</span> to i8**</span><span class="xml">
  call void @objc_storeStrong(i8** %34, i8* null) #2
  call void @objc_autoreleasePoolPop(i8* %8)
  ret i32 0
}</span>
</code></pre><p>可以看出在ARC环境下，在<code>autoreleasePoolPop</code>之前会自动为我们生成<code>objc_storeStrong</code>,第一个参数是当前对象，第二个是赋值的对象(=右边的)。对象在外部被引用时，就retain:</p>
<p><img src="/assets/images/autorelease/page4.jpeg" alt="img01"></p>
<p>当对象没有被引用时，直接释放资源:</p>
<p><img src="/assets/images/autorelease/page5.jpeg" alt="img01"></p>
<p>这里比较奇怪的是对象并没有被加入到<code>autoreleasepool</code>中，应该是编译器对简单的情况作了优化，毕竟<code>autoreleasepool</code>的管理也是一个不小的开销。</p>
<h2 id="@autoreleasepool使用场景"><strong>@autoreleasepool使用场景</strong></h2><p>什么情况下我们需要显示使用<code>Autorelease Pool</code>？可以参考下苹果文档<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>Each thread in a Cocoa application maintains its own stack of autorelease pool blocks. If you are writing a Foundation-only program or if you detach a thread, you need to create your own autorelease pool block.</p>
<p>If your application or thread is long-lived and potentially generates a lot of autoreleased objects, you should use autorelease pool blocks (like AppKit and UIKit do on the main thread); otherwise, autoreleased objects accumulate and your memory footprint grows. If your detached thread does not make Cocoa calls, you do not need to use an autorelease pool block.</p>
</blockquote>
<p>需要程序员自己使用<code>@autoreleasepool</code></p>
<ol>
<li>If you are writing a program that is not based on a<br>UI framework, such as a command-line tool.</li>
<li><p>If you write a loop that creates many temporary objects.<br>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</p>
</li>
<li><p>If you spawn a secondary thread.<br>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.)</p>
</li>
</ol>
<p>大致意思就是大部分时候都不需要程序员关心，但是以下情况需要注意</p>
<ol>
<li>代码不是基于UI framework;比如基于命令行</li>
<li>创建大量的临时对象或者大对象需要立即释放的时候</li>
<li>创建了子线程时，子线程里应该使用<code>@autoreleasepool</code>；如从<code>NSThread</code>中<code>detach</code>出的线程用了<code>Cocoa calls</code><br>以上两种情况需要使用。</li>
</ol>
<p>以下是几种使用的例子：</p>
<pre><code><span class="comment">//情景1 SDWebImage源码</span>
<span class="annotation">@autoreleasepool</span> {
        UIImage *diskImage = [self <span class="string">diskImageForKey:</span>key];
        <span class="comment">//other code</span>
    }

<span class="comment">//情景2 (MBProgressHUD源码)</span>
[NSThread <span class="string">detachNewThreadSelector:</span><span class="annotation">@selector</span>(launchExecution) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];

- (<span class="typename">void</span>)launchExecution {
    <span class="annotation">@autoreleasepool</span> {
    <span class="comment">//代码实现</span>
    }
}

<span class="comment">//情景3 (Realm源码)</span>
RLMSchema *cachedRealmSchema;
<span class="annotation">@autoreleasepool</span> {
    <span class="comment">// ensure that cachedRealm doesn't end up in this thread's autorelease pool</span>
    <span class="comment">//确保cachedRealm在当前线程的autorelease pool没有被释放</span>
    cachedRealmSchema = RLMGetAnyCachedRealmForPath(config.path).schema;
}

<span class="comment">// if we have a cached realm on another thread, copy without a transaction</span>
<span class="keyword">if</span> (cachedRealmSchema) {
    RLMRealmSetSchemaAndAlign(realm, cachedRealmSchema);
}
<span class="keyword">else</span> <span class="keyword">if</span> (dynamic) {
    RLMRealmSetSchemaAndAlign(realm, [RLMSchema <span class="string">dynamicSchemaFromObjectStoreSchema:</span>realm-&gt;_realm-&gt;schema()]
</code></pre><h2 id="自己实现一个autoreleasepool">自己实现一个autoreleasepool</h2><p>根据以上原理，我们可以实现一个和系统功能差不多类似的<code>autoreleasepool</code>,源代码在GitHub<a href="https://github.com/tianyig/iOSAdvance.git" target="_blank" rel="external">autoreleasepool</a>.</p>
<h2 id="相关知识点"><strong>相关知识点</strong></h2><h3 id="Tagged_Pointer"><strong>Tagged Pointer</strong></h3><p>苹果对于Tagged Pointer特点的介绍：</p>
<ol>
<li>Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate</li>
<li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ol>
<p>为什么要用<code>Tagged Pointer</code>?因为数据类型的长度是和CPU长度有关的，这样就导致了在64位CPU上一些对象占用的内存会翻倍。同时维护程序中的对象需要 分配内存，维护引用计数，管理生命周期，使用对象给程序的运行增加了负担。我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。因为<code>Tagged pointer</code>不是一个真正的对象，如果使用isa指针在编译时会报错。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://draveness.me/autoreleasepool/" target="_blank" rel="external">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></li>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></li>
<li></li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/03/10/Autorelease的原理与实现/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/27/SDWebImage源码阅读-一/">
                            SDWebImage源码阅读笔记
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-27T10:55:02+08:00">
	
		    Feb 27, 2017
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="前言"><strong>前言</strong></h2><p>SDWebImage是一个非常好用的图片异步加载的库，在GitHub上目前已经有16984个star。这么优秀的库，我们当然要好好学习一下它的设计和实现，接下来我们就看看SDWebImage的源码是如何实现的。</p>
<h2 id="SDWebImage结构"><strong>SDWebImage结构</strong></h2><p>首先我们看看SDWebImage的项目组织结构：</p>
<p><img src="/assets/images/SDWebImage/01.png" alt="img01"></p>
<blockquote>
<p>Downloader负责图片的异步下载；</p>
<p>Cache负责图片的缓存；</p>
<p>SDWebImageManager是总的管理类，维护了一个SDWebImageDownloader实例和一个SDImageCache实例，是下载与缓存的桥梁;SDWebImageDecoder负责图片的解压缩;SDWebImagePrefetcher负责图片的预取;</p>
<p>UIImageView+WebCache和其他的扩展负责给用户提供接口;</p>
</blockquote>
<p>其中，最重要的就是SDWebImageDownloader、SDImageCache、SDWebImageManager三个类，接下来我们就一步步详细分析一下这些类具体如何实现的。</p>
<p>为了便于大家从宏观上有个把握，我这里先给出项目的框架结构:</p>
<p><img src="/assets/images/SDWebImage/02.png" alt="img01"></p>
<p>从这个图我们明显可以看出来，UIImageView+WebCache和UIButton+WebCache负责为用户提供接口；SDWebImageManger负责协调Downloader和Cache，并且为UIKit层提供支持；最底层的两个类为高层抽象提供支持；我们将采用至顶向下分析的方法，一层层分析。</p>
<h2 id="接口层的实现"><strong>接口层的实现</strong></h2><h3 id="UIImageView+WebCache"><strong>UIImageView+WebCache</strong></h3><p>这里我们拿UIImageView+WebCache举例，UIButton+WebCache与此类似。UIImageView+WebCache提供的接口如下：</p>
<pre><code><span class="pp">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;
- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这些接口都调用了</p>
<pre><code><span class="pp">- <span class="params">(void)</span>sd_setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageCompletionBlock</span>)</span>completedBlock；</span>
</code></pre><p>这是一种常用的封装的方法，一个函数提供最复杂的实现，其他函数给这个函数在此基础上通过调用的时候提供默认参数，浅浅的封装一层方便用户使用。因为OC函数不支持默认参数(C++支持)，所以需要在提供几个函数包装一下。</p>
<p>这个函数的上半部分实现如下：</p>
<pre><code><span class="list">[<span class="keyword">self</span> sd_cancelCurrentImageLoad]<span class="comment">;</span>
objc_setAssociatedObject<span class="list">(<span class="keyword">self</span>, &amp;imageURLKey, url,     OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><span class="comment">;</span>

if <span class="list">(<span class="keyword">!</span><span class="list">(<span class="keyword">options</span> &amp; SDWebImageDelayPlaceholder)</span>)</span> {
    dispatch_main_async_safe<span class="list">(<span class="keyword">^</span>{
        self.image = placeholder<span class="comment">;</span>
    })</span><span class="comment">;</span>
}</span>
</code></pre><p>在加载一张图片的时候首先取消当前正在加载图片的操作，然后给当前的UIImageView关联一个对应图片的URL，关联的这个url库里本身没有用到，只是暴露出<code>- (NSURL *)sd_imageURL;</code>接口提供给用户使用；if里判断用户是否使用了<code>SDWebImageDelayPlaceholder</code>，如果没有使用就设置<code>placeholder</code>,默认情况没有设置选项，图片在加载完成之前会显示占位图，如果设置了这个选项，会在图片加载完成之后在显示占位图，关于其它选项的具体含义，可以看叶孤城的解析<a href="http://www.jianshu.com/p/6ae6f99b6c4c" title="链接" target="_blank" rel="external">这里</a>。<code>dispatch_main_async_safe</code>是SDWebImage封装的一个保证参数block在主线程执行的宏，宏的实现比较简单，这里不在解释。</p>
<p>我们具体分析一下取消操作是如何实现的，<code>[self sd_cancelCurrentImageLoad]</code>调用了父类<code>UIView+EMWebCacheOperation</code>的函数：</p>
<pre><code><span class="collection">[self sd_cancelImageLoadOperationWithKey:@<span class="string">"UIImageViewImageLoad"</span>]</span><span class="comment">;</span>
</code></pre><p>我们可以看到，这里的key是写死的，因为一个UIImageView在任何时候至多只能对应一种类型的下载操作(可以同时下载image和highlightedImage，两者的key是不一样的)。网络下载以及缓存都是比较耗费系统资源的操作，这么做可以尽量避免资源浪费。例如UITableView在滑动到需要复用UITableViewCell时，如果此时滑出屏幕之前的图片还未加载完成，就没必要在下载了。我们继续深入看父类<code>UIView+EMWebCacheOperation</code>的实现，<code>sd_cancelImageLoadOperationWithKey</code>的全部实现如下：</p>
<pre><code><span class="comment">//这里通过给Category关联属性的方式给每个UIView添加了一个NSMutableDictionary属性，保存了operation或者operation数组;operation从下面可以看出是id &lt;EMSDWebImageOperation&gt;类型,之所以用这样的类型是为了通用性，不局限于使用系统的NSOperation，用户也可以自定义自己的Operation(如SDWebImage里的用到的SDWebImageCombinedOperation)。</span>
<span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];
    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];
    <span class="keyword">if</span> (operations) {
    <span class="comment">//gif图有多张图片，多张图片对应多个operation</span>
        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> class]]) {
            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) {
                <span class="keyword">if</span> (operation) {
                    [operation cancel];
                }
            }
        } <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>{
            <span class="comment">//单个图片，直接调用cancle</span>
            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];
        }
        [operationDictionary removeObjectForKey:key];
    }
</code></pre><p>然后我们接着看sd_setImageWithURL的下半部分的实现，截取部分关键的代码：</p>
<pre><code>__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;
<span class="comment">//创建一个id &lt;SDWebImageOperation&gt;(于UIView+EMWebCacheOperation对应)类型的下载task,</span>
<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) {
          [wself removeActivityIndicator];
        <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;
            <span class="comment">//如果用户不希望下载完成直接设置image，就只调用completedBlock</span>
            <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
            {
                completedBlock(image, error, cacheType, url);
                <span class="keyword">return</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (image) {
                wself<span class="variable">.image</span> = image;
                [wself setNeedsLayout];
            } <span class="keyword">else</span> {
                <span class="comment">//下载完成设置placeholder</span>
                <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) {
                    wself<span class="variable">.image</span> = placeholder;
                    [wself setNeedsLayout];
                }
            }
            <span class="keyword">if</span> (completedBlock &amp;&amp; finished) {
                completedBlock(image, error, cacheType, url);
            }
        });
    }];
<span class="comment">//将这个Operation添加到此UIImageView的字典里</span>
[<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];
</code></pre><p>接口层的实现到这里就结束了。这里有几个小问题:</p>
<ul>
<li><strong><font color="red">iOS底层如何实现Category关联属性的？</font></strong></li>
<li><strong><font color="red">iOS的Category如何关联weak属性？</font></strong></li>
</ul>
<h2 id="调度层的实现">调度层的实现</h2><p> 调度层就一个类SDWebImageManager，在头文件中描述如下：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes.<br> It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache).<br> You can use this class directly to benefit from web image downloading with caching in another context than<br> a UIView.</p>
</blockquote>
<p>意思就是SDWebImageManager是位于UIImageView+WebCache之下的用于图片异步下载和缓存的类，你也可以直接使用SDWebImageManager的函数直接下载图片。</p>
<p>SDWebImageManager是一个用dispatch_once实现的单例(关于<font color="red"><strong>dispatch_once底层如何实现的？</strong></font>也是一个有趣的话题，我们以后在讨论它),维护了一个SDImageCache实例和SDWebImageDownloader实例。提供的函数如下：</p>
<p>//初始化SDWebImageManager单例，在init方法中已经初始化了cache单例和downloader单例。</p>
<pre><code>- (instancetype)initWithCache:(SDImageCache *)cache downloader:(SDWebImageDownloader *)downloader;
<span class="comment">//下载图片</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;
<span class="comment">//缓存给定URL的图片</span>
- (<span class="keyword">void</span>)saveImageToCache:(<span class="built_in">UIImage</span> *)image forURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//取消当前所有的操作</span>
- (<span class="keyword">void</span>)cancelAll;
<span class="comment">//监测当前是否有进行中的操作</span>
- (<span class="built_in">BOOL</span>)isRunning;
<span class="comment">//监测图片是否在缓存中， 先在memory cache里面找  再到disk cache里面找</span>
- (<span class="built_in">BOOL</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否缓存在disk里</span>
- (<span class="built_in">BOOL</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url;
<span class="comment">//监测图片是否在缓存中,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                     completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//监测图片是否缓存在disk里,监测结束后调用completionBlock</span>
- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url
                   completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
<span class="comment">//返回给定URL的cache key，默认是图片的url</span>
- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url;
</code></pre><p>定义了SDWebImageManagerDelegate协议：</p>
<pre><code><span class="comment">@protocol SDWebImageManagerDelegate </span>

<span class="comment">@optional</span>

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Controls which image should be downloaded when the image is not found in the cache.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to be downloaded</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span>
 <span class="keyword">*</span> 控制在cache中没有找到image时 是否应该去下载。默认是YES。
 <span class="keyword">*</span>/
- (BOOL)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager shouldDownloadImageForURL:(NSURL <span class="keyword">*</span>)imageURL;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.
 <span class="keyword">*</span> NOTE: This method is called from a global queue in order to not to block the main thread.
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param imageManager The current `SDWebImageManager`</span>
 <span class="keyword">*</span> <span class="comment">@param image        The image to transform</span>
 <span class="keyword">*</span> <span class="comment">@param imageURL     The url of the image to transform</span>
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@return The transformed image object.</span>
 <span class="keyword">*</span> 在下载之后，缓存之前转换图片。在全局队列中操作，不阻塞主线程
 <span class="keyword">*</span>/
- (UIImage <span class="keyword">*</span>)imageManager:(SDWebImageManager <span class="keyword">*</span>)imageManager transformDownloadedImage:(UIImage <span class="keyword">*</span>)image withURL:(NSURL <span class="keyword">*</span>)imageURL;

<span class="comment">@end</span>
</code></pre><p> 我们主要看下</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                        options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options
                                       progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                      completed:<span class="params">(<span class="variable">SDWebImageCompletionWithFinishedBlock</span>)</span>completedBlock</span>
</code></pre><p>这个函数返回<code>id &lt;SDWebImageOperation&gt;</code>类型保存当前UIImageView的下载操作；</p>
<p>首先检查URL是否合法：</p>
<pre><code><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) {
    url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];
}

<span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span>
<span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) {
    url = nil;
}
</code></pre><p>这两个判断都是检查用户传递参数类型是否正确；</p>
<pre><code><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;
<span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) {
    isFailedUrl = [<span class="keyword">self</span><span class="variable">.failedURLs</span> containsObject:url];
}

<span class="keyword">if</span> (url<span class="variable">.absoluteString</span><span class="variable">.length</span> == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
    dispatch_main_sync_safe(^{
        <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];
        completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
    });
    <span class="keyword">return</span> operation;
}
</code></pre><p>若URL对应的image之前下载失败过并且用户没有设置错误重试，直接调用completedBlock；</p>
<pre><code><span class="variable">@synchronized</span> (self.runningOperations) {
    <span class="attr_selector">[self.runningOperations addObject:operation]</span>;
}
</code></pre><p>把当前下载操作加入到runningOperations中，因为runningOperations是多线程共享的，所以要加synchronized控制并发；<strong>synchronized底层是如何实现的呢？</strong>我们在以后的文章里去探究。</p>
<p>SDWebImageManager首先去检查cache(memeory &amp;&amp; disk)中是否缓存过要下载的图片，调用imageCache的</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSOperation</span> *)</span>queryDiskCacheForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key done:<span class="params">(<span class="variable">SDWebImageQueryCompletedBlock</span>)</span>doneBlock</span>
</code></pre><p>函数里首先判断当前操作是否被取消，如果取消从runningOperations中移除，并直接返回：</p>
<pre><code><span class="tag">if</span> (operation.isCancelled) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="attr_selector">[self.runningOperations removeObject:operation]</span>;
    }

    return;
}
</code></pre><p>接下来需要讨论二种情况情况：1.（缓存未找到图片）或（缓存找到了图片但是用户设置了刷新缓存） 2. （用户没有实现shouldDownloadImageForURL协议）或（用户实现了shouldDownloadImageForURL协议并且返回值是YES）</p>
<pre><code>if <span class="list">(<span class="list">(!image || options &amp; SDWebImageRefreshCached)</span> <span class="keyword">&amp;&amp;</span> <span class="list">(![self.delegate respondsToSelector:@selector<span class="list">(<span class="keyword">imageManager</span><span class="keyword">:shouldDownloadImageForURL</span>:)</span>] || [self.delegate imageManager<span class="keyword">:self</span> shouldDownloadImageForURL<span class="keyword">:url</span>])</span>)</span>
</code></pre><p>这两种情况下需要下载图片，上面这一坨就是判断上面的二种情况。</p>
<p>除了上面二种情况还有不需要下载图片的二种情况：1.缓存找到图片 2.缓存未找到图片并且用户禁止下载：</p>
<pre><code><span class="comment">//第一种情况，缓存找到图片(用户未设置刷新缓存并且用户未禁止下载)</span>
<span class="keyword">else</span> <span class="keyword">if</span> (image) {
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation<span class="variable">.isCancelled</span>) {
            completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
<span class="comment">//第二种情况(缓存未找到且用户通过delegate设置在缓存未找到时禁止下载图片)</span>
<span class="keyword">else</span> {
    <span class="comment">// Image not in cache and download disallowed by delegate</span>
    dispatch_main_sync_safe(^{
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;
        <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation<span class="variable">.isCancelled</span>) {
            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);
        }
    });
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) {
        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];
    }
}
</code></pre><p>如果需要下载图片，就调用</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock</span>
</code></pre><p>下载图片，如果下载失败。直接调用completedBlock返回错误，并根据错误类型将URL添加到failedURLs里。</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">error</span>) {
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(nil, <span class="built_in">error</span>, SDImageCacheTypeNone, finished, url);
        }
    });

    <span class="keyword">if</span> (   <span class="built_in">error</span>.code != NSURLErrorNotConnectedToInternet
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCancelled
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorTimedOut
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorInternationalRoamingOff
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorDataNotAllowed
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotFindHost
        &amp;&amp; <span class="built_in">error</span>.code != NSURLErrorCannotConnectToHost) {
        @synchronized (<span class="variable">self</span>.failedURLs) {
            [<span class="variable">self</span>.failedURLs addObject:url];
        }
    }
}
</code></pre><p>若图片下载成功，将url从failURLs里删除：</p>
<pre><code><span class="tag">if</span> ((options &amp; SDWebImageRetryFailed)) {
    <span class="variable">@synchronized</span> (self.failedURLs) {
        <span class="attr_selector">[self.failedURLs removeObject:url]</span>;
    }
}
</code></pre><p>这个地方需要解释下，因为<code>[self.failedURLs addObject:url]</code>是<strong>只在下载失败时添加</strong>的，而下载成功和下载失败是互斥的，也就是说，下载成功时failedURLs数组里就不应该有这个url，为什么要这么写呢，这是为了解决竞态条件下的问题，若两个线程下载同一个url的图片，若第一个线程下载失败，第二个下载成功。如果不从failedURLs移除这个url的话，以后下载此url的图片都会失败。</p>
<p>然后处理下载完成的图片：</p>
<pre><code><span class="comment">//是否设置了只缓存内存</span>
BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

<span class="comment">//设置刷新缓存且cache找到图片且NSURLCache找到图片，不处理</span>
<span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) {
    <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span>
}
<span class="comment">//若delegate实现imageManager:transformDownloadedImage:withURL:方法，在缓存之前，需要做调用此delegate方法转换</span>
<span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="annotation">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) {
    <span class="comment">//在全局队列中转换，不阻塞主线程dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{</span>
        UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];
        <span class="comment">//转换成功后，存入缓存</span>
        <span class="keyword">if</span> (transformedImage &amp;&amp; finished) {
            BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];
            [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">recalculateFromImage:</span>imageWasTransformed <span class="string">imageData:</span>(imageWasTransformed ? nil : data) <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
        }
        <span class="comment">//缓存成功之后，调用completedBlock</span>
        dispatch_main_sync_safe(^{
            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
                completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);
            }
        });
    });
}
<span class="keyword">else</span> {
    <span class="comment">//没有实现转换的delegate，就不做转换直接缓存</span>
    <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) {
        [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];
    }
    <span class="comment">//缓存成功之后，调用completedBlock</span>
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) {
            completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);
        }
    });
}
</code></pre><p>}</p>
<p>下载完成之后，从队列里移除：</p>
<pre><code><span class="tag">if</span> (finished) {
    <span class="variable">@synchronized</span> (self.runningOperations) {
        <span class="tag">if</span> (strongOperation) {
            <span class="attr_selector">[self.runningOperations removeObject:strongOperation]</span>;
        }
    }
}
</code></pre><p>最后说下返回的<code>SDWebImageCombinedOperation</code>类型，这个类型包含<code>NSOperation *cacheOperation</code>的一个子类型，其中<code>cacheOperation</code>中又存在<code>id &lt;SDWebImageOperation&gt;</code>的下载图片的<code>subOperation</code>。在<code>cancel</code>的时候也应该把这两个操作都<code>cancle</code>。</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">self</span><span class="variable">.cancelled</span> = <span class="literal">YES</span>;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cacheOperation</span>) {
        [<span class="keyword">self</span><span class="variable">.cacheOperation</span> cancel];
        <span class="keyword">self</span><span class="variable">.cacheOperation</span> = <span class="literal">nil</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) {
        <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

        <span class="comment">// <span class="doctag">TODO:</span> this is a temporary fix to #809.</span>
        <span class="comment">// Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span>
<span class="comment">//        self.cancelBlock = nil;</span>
        _cancelBlock = <span class="literal">nil</span>;
    }
}
</code></pre><p>所以<code>CombinedOperation</code>在<code>cancel</code>的时候会先cancel掉自己的<code>cacheOperation</code>,在调用自己的<code>cancelBlock</code>。</p>
<pre><code><span class="label">operation.cancelBlock</span> = ^{
    [<span class="keyword">subOperation </span>cancel]<span class="comment">;</span>


    <span class="comment">@synchronized (self.runningOperations) {</span>
        __strong __typeof(weakOperation) <span class="keyword">strongOperation </span>= weakOperation<span class="comment">;</span>
        <span class="preprocessor">if</span> (<span class="keyword">strongOperation) </span>{
            [<span class="keyword">self.runningOperations </span>removeObject:<span class="keyword">strongOperation];
</span>        }
    }
}<span class="comment">;</span>
</code></pre><p>在自己的<code>cancelBlock</code>把下载操作<code>subOperation</code>取消掉。由此可见封装的<code>CombinedOperation</code>包含了下载和缓存的操作，使代码变得更简洁。</p>
<h2 id="下载和缓存层"><strong>下载和缓存层</strong></h2><h3 id="下载层SDWebImageDownloader"><strong>下载层SDWebImageDownloader</strong></h3><p>SDWebImageDownloader提供的方法有以下几个：</p>
<pre><code><span class="comment">//给每个HTTP下载请求头的指定field设置值。</span>
- (<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value forHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//返回HTTP特定field的值</span>
- (<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field;
<span class="comment">//设置一个SDWebImageDownloaderOperation的子类作为下载请求的默认NSOperation</span>
- (<span class="keyword">void</span>)setOperationClass:(Class)operationClass;
<span class="comment">//创建一个SDWebImageDownloader异步下载实例，图片下载完成或错误时，通知delegate回调。方法返回一个 SDWebImageOperation</span>
- (<span class="keyword">id</span> )downloadImageWithURL:(<span class="built_in">NSURL</span> *)url
                                     options:(SDWebImageDownloaderOptions)options
                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
<span class="comment">// 设置下载队列为挂起状态</span>
- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)suspended;
<span class="comment">//取消队列中的所有操作。</span>
- (<span class="keyword">void</span>)cancelAllDownloads;
</code></pre><p>我们重点研究下载方法：</p>
<pre><code><span class="pp">- <span class="params">(id )</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url
                                     options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
                                    progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
                                   completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock;</span>
</code></pre><p>这几个参数的含义代码注释里都有，这里就不再一一解释。</p>
<pre><code>__block SDWebImageDownloaderOperation *operation;
__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;

[<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
    <span class="comment">//block实现</span>
    ...
    operation = [[wself<span class="variable">.operationClass</span> alloc] initWithRequest:request
                                                      options:options
                                                     progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize)
    ...
}];

<span class="keyword">return</span> operation;
</code></pre><p>上面是这个方法的框架，可以看出主要调用了<code>addProgressCallback</code>方法，方法的内部创建了下载的<code>operation</code>。我们首先看看<code>addProgressCallback</code>方法的实现:</p>
<pre><code><span class="comment">//如果url为nil，调用completedBlock后return</span>
<span class="keyword">if</span> (url == <span class="literal">nil</span>) {
    <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) {
        completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
    }
    <span class="keyword">return</span>;
}

<span class="comment">//允许多线程下载，使用了并发控制，避免同时修改URLCallbacks</span>
dispatch_barrier_sync(<span class="keyword">self</span><span class="variable">.barrierQueue</span>, ^{
    <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;
    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url]) {
        <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = [<span class="built_in">NSMutableArray</span> new];
        first = <span class="literal">YES</span>;
    }

    <span class="comment">// Handle single download of simultaneous download request for the same URL</span>
    <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url];
    <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];
    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];
    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];
    [callbacksForURL addObject:callbacks];
    <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = callbacksForURL;

    <span class="keyword">if</span> (first) {
        createCallback();
    }
});
</code></pre><p>这里的并发控制的地方为什么要使用<code>dispatch_barrier_sync</code>，是因为<code>dispatch_barrier_sync</code>这个函数可以设置一个同步执行block，它会等到在这个block加入队列之前的block执行完毕后，才开始执行。在它之后加入队列的block，则等到这个block执行完毕后才开始执行。。这里的<code>dispatch_barrier_sync</code>实际上相当于一个写锁，任何写操作(删除，添加)，都要在之前的写操作完成后执行，而之后的写操作，也要在之前的的写操作完成之后执行。</p>
<p>URLCallbacks是一个以url作为key的字典，字典的value是一个数组，数组的元素是一个字典。可以看出<code>URLCallbacks</code>、<code>callbacksForURL</code>、<code>callbacks</code>之间的关系如下图：</p>
<p><img src="/assets/images/SDWebImage/03.png" alt="img01"></p>
<p>如果URLCallbacks以url对应的value是空，说明是第一次请求这个url，需要调用<code>createCallback</code>创建下载任务，即调用：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
        inSession:<span class="params">(<span class="variable">NSURLSession</span> *)</span>session
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>设置默认超时时间15s，然后使用此<code>request</code>创建一个<code>SDWebImageDownloaderOperation</code>,方便把这个下载任务添加到下载队列里：</p>
<pre><code><span class="pp">- <span class="params">(id)</span>initWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request
          options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options
         progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock
        completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock
        cancelled:<span class="params">(<span class="variable">SDWebImageNoParamsBlock</span>)</span>cancelBlock</span>
</code></pre><p>重点看下这个方法的三个block，第一个progress，取出存储在URLCallbacks中的progressBlock并调用：</p>
<pre><code><span class="comment">//只是读操作，dispatch_sync即可</span>
 <span class="built_in">dispatch_sync</span>(sself<span class="variable">.barrierQueue</span>, ^{
     callbacksForURL = [sself<span class="variable">.URLCallbacks</span>[url] <span class="keyword">copy</span>];
 });
 <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) {
     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
         SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
         <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);
     });
 }
</code></pre><p>同理，<code>completed</code>也是从URLCallbacks中的completedBlock并调用：</p>
<pre><code><span class="comment">//这里有写操作，须用dispatch_barrier_sync</span>
dispatch_barrier_sync(sself.barrierQueue, ^{
    callbacksForURL = [sself.URLCallbacks[url] copy];
    <span class="keyword">if</span> (finished) {
        [sself.URLCallbacks removeObjectForKey:url];
    }
});
<span class="keyword">for</span> (NSDictionary *callbacks <span class="keyword">in</span> callbacksForURL) {
    <span class="comment">//这里为什么不像progressBlock一样使用dispatch_async(dispatch_get_main_queue()？</span>
    SDWebImageDownloaderCompletedBlock <span class="keyword">callback</span> = callbacks[kCompletedCallbackKey];
    <span class="keyword">if</span> (<span class="keyword">callback</span>) <span class="keyword">callback</span>(image, data, error, finished);
}
</code></pre><p>不同图片的下载任务会异步完成，所以要等待其他图片下载完成，并执行完<code>completedBlock</code>中对<code>URLCallbacks</code>的操作，才能继续之后的操作。</p>
<pre><code>cancelled:^{
    SDWebImageDownloader *sself = wself<span class="comment">;</span>
    if (!sself) return<span class="comment">;</span>
    dispatch_barrier_async(sself.barrierQueue, ^{
        [sself.URLCallbacks removeObjectForKey:url]<span class="comment">;</span>
    })<span class="comment">;</span>
}
</code></pre><p>取消时用的<code>dispatch_barrier_async</code>,dispatch_barrier_async表示的是先等之前的执行完成，然后把该barrier放入queue中，而不等待barrier中代码执行结束，而dispat_barrier_sync表示需要等待barrier中代码执行结束。</p>
<p>然后设置operation</p>
<pre><code><span class="comment">//是否解压下载的图片</span>
operation.shouldDecompressImages = wself.shouldDecompressImages;
<span class="comment">//有证书设置证书</span>
<span class="keyword">if</span> (wself.urlCredential) {
    operation.credential = wself.urlCredential;
} <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) {
    operation.credential = [NSURLCredential <span class="string">credentialWithUser:</span>wself.username <span class="string">password:</span>wself.password <span class="string">persistence:</span>NSURLCredentialPersistenceForSession];
}
<span class="comment">//设置优先级</span>
<span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) {
    operation.queuePriority = NSOperationQueuePriorityHigh;
} <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) {
    operation.queuePriority = NSOperationQueuePriorityLow;
}

[wself.downloadQueue <span class="string">addOperation:</span>operation];
<span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
    <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span>
    [wself.lastAddedOperation <span class="string">addDependency:</span>operation];
    wself.lastAddedOperation = operation;
}
</code></pre><p>最后将这个下载的操作加入到下载队列里。下载方式有两种，FIFO和LIFO。最后根据下载的方式调增任务的依赖。</p>
<h4 id="具体的下载操作SDWebImageDownloaderOperation"><strong>具体的下载操作SDWebImageDownloaderOperation</strong></h4><p>上面的<code>SDWebImageDownloader</code>主要操作就是创建<code>SDWebImageDownloaderOperation</code>添加到下载队列里，可知具体的操作是在<code>SDWebImageDownloaderOperation</code>，我们研究下具体是如何下载的。首先这个类是继承于<code>NSOperation</code>，并重写了<code>start</code>方法。我们首先看看它的<code>start</code>方法的实现：</p>
<p>检测下载状态</p>
<pre><code><span class="comment">//管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span>
<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) {
    <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    [<span class="keyword">self</span> reset];
    <span class="keyword">return</span>;
}
</code></pre><p>如果是iOS4.0以上的版本，需要设置后台执行的操作：</p>
<pre><code><span class="comment">//作为具体的下载操作，尽量不依赖其他类，所以这里使用字符串创建</span>
Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);
<span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];
<span class="comment">//如果用户设置了后台下载</span>
<span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) {
    <span class="comment">//如果设置了在后台执行，则进行后台执行</span>
     __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    <span class="comment">//向系统申请更长的时间执行下载操作</span>
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = [app beginBackgroundTaskWithExpirationHandler:^{
        <span class="comment">// 如果在系统规定时间内任务还没有完成（一般是10分钟），结束后台任务</span>
        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;
        <span class="keyword">if</span> (sself) {
            [sself cancel];
            [app endBackgroundTask:sself<span class="variable">.backgroundTaskId</span>];
            sself<span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
        }
    }];
｝
</code></pre><p>这里注册的block会在APP进入后台时执行，block里调用<code>cancel</code>对应的<code>endBackgroundTask</code>,这个block的主要目的是持有<code>self</code>不要被系统销毁，只要<code>self</code>不被系统销毁，当前下载操作就可以继续执行。<code>self</code>被销毁后，我们看看<code>cancel</code>操作做了什么：</p>
<pre><code>- (<span class="keyword">void</span>)cancel {
    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.thread</span>) {
            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelInternalAndStop) onThread:<span class="keyword">self</span><span class="variable">.thread</span> withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];
        }
        <span class="keyword">else</span> {
            [<span class="keyword">self</span> cancelInternal];
        }
    }
}

- (<span class="keyword">void</span>)cancelInternalAndStop {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">self</span> cancelInternal];
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
}

- (<span class="keyword">void</span>)cancelInternal {
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">return</span>;
    [<span class="keyword">super</span> cancel];
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cancelBlock</span>) <span class="keyword">self</span><span class="variable">.cancelBlock</span>();

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.connection</span>) {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
        });

        <span class="comment">// As we cancelled the connection, its callback won't be called and thus won't</span>
        <span class="comment">// maintain the isFinished and isExecuting flags.</span>
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isExecuting</span>) <span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">NO</span>;
        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;
    }

    [<span class="keyword">self</span> reset];
}
</code></pre><p>底下有三个和<code>cancel</code>相关的操作，如果当前线程存在，在当前线程调用<code>cancelInternalAndStop</code>，否者调用<code>cancelInternal</code>;这两者的区别是<code>cancelInternalAndStop</code>中多了一句<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>,在中止当前线程的时候，也要关闭对应的RunLoop。<code>cancelInternal</code>做了几件事：</p>
<ul>
<li>调用自定义的cancelBlock</li>
<li>调用NSURLConnection的cancel取消self.connection</li>
<li>回收资源</li>
<li>抛出通知</li>
</ul>
<p>注册的后台操作是在进入到后台如果<code>NSOperation</code>未执行完成才执行的，假如在进入到后台之前<code>NSOperation</code>已经完成了呢？</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.backgroundTaskId</span> != <span class="built_in">UIBackgroundTaskInvalid</span>) {
    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];
    [app endBackgroundTask:<span class="keyword">self</span><span class="variable">.backgroundTaskId</span>];
    <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;
}
</code></pre><p>如果下载任务完成，中止后台操作，将backgroundTaskId置为UIBackgroundTaskInvalid。</p>
<p>注册后台操作的准备工作完成之后，就该开始下载了：</p>
<pre><code><span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">YES</span>;
<span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span><span class="variable">.request</span> delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];
<span class="keyword">self</span><span class="variable">.thread</span> = [<span class="built_in">NSThread</span> currentThread];
</code></pre><p>初始化相关的数据，创建<code>NSURLConnection</code>,如果创建失败就调用<code>completedBlock</code>,成功就启动下载，关键代码如下：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
    <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);
}
....
<span class="built_in">CFRunLoopRun</span>();
....
<span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) {
    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    [<span class="keyword">self</span> connection:<span class="keyword">self</span><span class="variable">.connection</span> didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@{<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>}]];
}
</code></pre><p>使用<code>NSURLConnection</code>调用了<code>[self.connection start]</code>后，<code>NSURLConnection</code>的delegate就会不停收到事件回调。当这个connection完成或者终止，才会跳出CFRunLoopRun()(可以理解为CFRunLoopRun阻塞了当前线程)。当跳出Runloop后，就要判断NSURLConnection是不是正常完成任务了。如果没有，也就是说self.isFinished == NO。那么就取消该connection，并且调用</p>
<pre><code>(<span class="typename">void</span>)<span class="string">connection:</span>(NSURLConnection *)connection <span class="string">didFailWithError:</span>(NSError *)error;
</code></pre><p>返回错误信息。然后就是<code>NSURLConnection</code>几个delegate过程的处理：</p>
<pre><code><span class="comment">//如果是304代表服务端资源未改变，可直接使用客户端未过期的资源，此时需要取消operation并返回缓存中的image，code小于400说明请求成功</span>
<span class="comment">//如果响应成功，开始初始化数组，准备接收imageData</span>
<span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] != <span class="number">304</span>)) {
    <span class="built_in">NSInteger</span> expected = response<span class="variable">.expectedContentLength</span> &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response<span class="variable">.expectedContentLength</span> : <span class="number">0</span>;
    <span class="keyword">self</span><span class="variable">.expectedSize</span> = expected;
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) {
        <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, expected);
    }

    <span class="keyword">self</span><span class="variable">.imageData</span> = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];
    <span class="keyword">self</span><span class="variable">.response</span> = response;
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];
    });
}
<span class="comment">//请求失败之后，抛通知并清理相关资源</span>
<span class="keyword">else</span> {
    <span class="built_in">NSUInteger</span> code = [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode];

    <span class="comment">//This is the case when server returns '304 Not Modified'. It means that remote image is not changed.</span>
    <span class="comment">//In case of 304 we need just cancel the operation and return cached image from the cache.</span>
    <span class="keyword">if</span> (code == <span class="number">304</span>) {
        [<span class="keyword">self</span> cancelInternal];
    } <span class="keyword">else</span> {
        [<span class="keyword">self</span><span class="variable">.connection</span> cancel];
    }
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];
    });

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="keyword">self</span><span class="variable">.completedBlock</span>(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:[((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] userInfo:<span class="literal">nil</span>], <span class="literal">YES</span>);
    }
    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());
    [<span class="keyword">self</span> done];
}
</code></pre><p>然后在下载过程中接收数据，以下是部分代码：</p>
<pre><code><span class="keyword">if</span> (partialImageRef) {
    <span class="comment">//把data转换成image</span>
    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:partialImageRef scale:<span class="number">1</span> orientation:orientation];
    <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>];
    <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];
    <span class="comment">//判断是否要解解码，默认是需要解码，解码的操作是在子线程里(delegate在子线程执行的),为什么要解码？我们之后解释</span>
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) {
        image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];
    }
    <span class="keyword">else</span> {
        image = scaledImage;
    }
    <span class="built_in">CGImageRelease</span>(partialImageRef);
    dispatch_main_sync_safe(^{
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) {
        <span class="comment">//显示在imageView上（不一定下载完，可以显示一部分）</span>
            <span class="keyword">self</span><span class="variable">.completedBlock</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);
        }
    });
}
</code></pre><blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<h3 id="缓存层SDImageCache">缓存层SDImageCache</h3><p>我们看下<code>SDWebImage</code>的缓存<code>SDImageCache</code>，<code>SDImageCache</code>主要包含两部分，内存缓存<code>memCache</code>和磁盘缓存<code>fileManager</code>,磁盘缓存的写操作是异步的。</p>
<blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI. </p>
</blockquote>
<p>内存缓存是使用<code>NSCache</code>实现的，<code>NSCache</code>使用上类似字典，可以用key-Value的方式存取数据。但是NSCache底层实现和<code>NSDictionary</code>不同(NSCache是线程安全的)。<code>NSCache</code>的具体介绍可以看<a href="http://nshipster.cn/nscache/" target="_blank" rel="external">NSCache</a>。</p>
<p>先看看<code>SDImageCache</code>的属性：</p>
<pre><code><span class="comment">//是否解压下载的图片，默认是YES,但是会消耗掉很多内存，如果遇到内存不足的crash时，将值设为NO</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;
<span class="comment">//是否自动上传iCloud</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;
<span class="comment">//使用内存缓存</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;
<span class="comment">//内存缓存的代价（占用的内存大小）</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCost;
<span class="comment">//内存缓存的最大元素个数</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCountLimit;
<span class="comment">//元素在缓存中最大寿命</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;
<span class="comment">//最大缓存大小</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;
</code></pre><p>前面<code>SDWebImageManager</code>在下载图片成功时，会调用</p>
<pre><code>[self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk]
</code></pre><p>缓存到内存和磁盘，我们重点看下这个函数的实现:</p>
<pre><code><span class="comment">//错误处理</span>
<span class="keyword">if</span> (!image || !key) {
    <span class="keyword">return</span>;
}
<span class="comment">//需要内存缓存，计算内存占用，直接缓存</span>
<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldCacheImagesInMemory</span>) {
    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);
    [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:image forKey:key cost:cost];
}

<span class="comment">//需要磁盘异步缓存</span>
<span class="keyword">if</span> (toDisk) {
    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^{
        <span class="built_in">NSData</span> *data = imageData;

        <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) {
<span class="preprocessor">#if TARGET_OS_IPHONE</span>
            <span class="comment">//确定图片是png还是jpeg. imageData为nil而且有alapha通道，当作png处理</span>
            <span class="keyword">int</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(image<span class="variable">.CGImage</span>);
            <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == k<span class="built_in">CGImageAlphaNone</span> ||
                              alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||
                              alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);
            <span class="built_in">BOOL</span> imageIsPng = hasAlpha;

            <span class="comment">// But if we have an image data, we will look at the preffix</span>
            <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) {
                imageIsPng = ImageDataHasPNGPreffix(imageData);
            }
            <span class="comment">//根据类型返回image的data</span>
            <span class="keyword">if</span> (imageIsPng) {
                data = <span class="built_in">UIImagePNGRepresentation</span>(image);
            }
            <span class="keyword">else</span> {
                data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);
            }
<span class="preprocessor">#else</span>
            data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image<span class="variable">.representations</span> usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];
<span class="preprocessor">#endif</span>
        }
        <span class="comment">//磁盘存储</span>
        <span class="keyword">if</span> (data) {
            <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) {
                [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];
            }

            <span class="comment">// 获取缓存路径</span>
            <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];
            <span class="comment">// transform to NSUrl</span>
            <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];
            <span class="comment">//存储到disk里</span>
            [_fileManager createFileAtPath:cachePathForKey contents:data attributes:<span class="literal">nil</span>];

            <span class="comment">// disable iCloud backup</span>
            <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDisableiCloud</span>) {
                [fileURL setResourceValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];
            }
        }
    });
}
</code></pre><p>同样的。<code>SDWebImageManager</code>在下载之前会检查缓存是否有此图片：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">NSOperation</span> *)</span>queryDiskCacheForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key done:<span class="params">(<span class="variable">SDWebImageQueryCompletedBlock</span>)</span>doneBlock</span>
</code></pre><p>关键代码如下：</p>
<pre><code><span class="comment">//从内存缓存里查找</span>
<span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];
<span class="keyword">if</span> (image) {
    doneBlock(image, SDImageCacheTypeMemory);
    <span class="keyword">return</span> <span class="literal">nil</span>;
}

<span class="comment">//NSOperation的特殊用法，用于取消一个异步操作</span>
<span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];
<span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^{
    <span class="keyword">if</span> (operation<span class="variable">.isCancelled</span>) {
        <span class="keyword">return</span>;
    }

    <span class="comment">//disk查找图片成功之后需要解码，所以放在`autoreleasepool`里</span>
    <span class="keyword">@autoreleasepool</span> {
        <span class="comment">//从磁盘查找，解码</span>
        <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];
        <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span><span class="variable">.shouldCacheImagesInMemory</span>) {
            <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);
            [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:diskImage forKey:key cost:cost];
        }
        <span class="comment">//查找完成</span>
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            doneBlock(diskImage, SDImageCacheTypeDisk);
        });
    }
});
</code></pre><p>最后还有一个Cache清除的方式，对于memory cache来说是完全清空的，对于disk cache，根据设置参数的不同，有两种清除方式：</p>
<ul>
<li>文件的缓存有效期：默认是一周。如果文件的缓存时间超过这个时间值，则将其移除。</li>
<li>最大缓存空间大小：如果所有缓存文件的总大小超过最大缓存空间，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
</ul>
<h2 id="底层支持(工具类)">底层支持(工具类)</h2><h3 id="SDWebImageDecoder和SDWebImageCompat">SDWebImageDecoder和SDWebImageCompat</h3><p><code>SDWebImageDecoder</code>是用来图片解码的，在上面下载的时候和磁盘读取图片数据时，都调用了解码操作，图片为什么需要解码，可以参考如下解释:</p>
<blockquote>
<p>因为通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。具体的说就是一个UIImage加载了jpeg或者png，当UIImageView将要显示这个UIImage的时候会先把png和jpeg解码成未压缩格式，所以SDWebImage有一个decodeImage方法，就是把这一步放在了异步线程做，防止tableViewCell中的imageView加载图片的时候在主线程解码图片，导致滑动卡顿。这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了,这种做法是典型的空间换时间的做法，如下从硬盘中去图片时，分别对图片进行了缩放和解压缩操作。</p>
</blockquote>
<p><code>SDWebImageCompat</code>是根据屏幕大小设置图片的<code>scale</code>，实现比较简单，这里不再解释。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/27/SDWebImage源码阅读-一/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/09/09/关于iOS组件化方案的思考/">
                            关于iOS组件化方案的思考
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-09-09T16:13:26+08:00">
	
		    Sep 09, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="什么是组件化？">什么是组件化？</h3><p>组件化其实是封装的一种，将功能模块</p>
<ul>
<li><a href="http://www.tuicool.com/articles/vyeUf2J" target="_blank" rel="external">蘑菇街 App 的组件化之路</a> 原博客已删</li>
<li><a href="http://www.tuicool.com/articles/QneYvmi" target="_blank" rel="external">蘑菇街 App 的组件化之路·续</a> 原博客已删</li>
<li><a href="http://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">iOS应用架构谈 组件化方案</a></li>
<li><a href="http://blog.cnbang.net/tech/3080/" target="_blank" rel="external">iOS 组件化方案探索</a></li>
<li><a href="http://reviewcode.cn/article.html?reviewId=20" target="_blank" rel="external">围观神仙打架，反革命工程师《iOS应用架构谈 组件化方案》和蘑菇街Limboy的《蘑菇街 App 的组件化之路》的阅读指导</a></li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/09/09/关于iOS组件化方案的思考/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/06/02/Swift-Name-Mangling/">
                            Name Mangling
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-06-02T15:35:37+08:00">
	
		    Jun 02, 2016
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="/categories/新测试/">新测试</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="前言">前言</h2><p>什么是Name Mangling？Name Mangling是一种通过在函数里添加附加信息，把函数名转换成链接器符号的一个步骤。具体解释可以参看wiki。<a href="https://en.wikipedia.org/wiki/Name_mangling" target="_blank" rel="external">Name Mangling</a></p>
<p>为什么需要Name Mangling?因为有些语言(如C++)在特定情况下允许函数重名，比如重载、继承等。这样在函数调用的时候仅仅根据函数名无法判断要调用哪个函数，这就需要对这些函数做一定的处理以便于区分重名函数调用。</p>
<p>在C语言里，虽然不存在命名冲突的问题，但是在C语言里还是做了命名处理，在函数名字前都加了下划线。例如：</p>
<p>新建一个文件test.c如下,</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{ <span class="keyword">return</span> <span class="number">0</span>; }
</code></pre><p>编译后查看二进制符号:</p>
<pre><code><span class="number">172</span>-<span class="number">0</span>-<span class="number">0</span>-<span class="number">136</span>:Desktop sheng$ gcc test.c | nm
<span class="number">0000000100000000</span> T __mh_execute_header
<span class="number">0000000100000f</span>a0 T _main
             U dyld_stub_binder
</code></pre><p>C语言的命名处理基本没什么用处，但是为了兼容性等其它原因，还是保留下来了。根据惯例，C语言中的符号默认都会加上下划线，但是汇编中的符号不会自动加上下划线。</p>
<p>Objective-C不会存在命名冲突，因为OC的方法调用是通过消息机制实现的，而且OC不支持函数重载。在支持函数重载的语言里，Name Mangling就变得有用处了。</p>
<h2 id="C++函数重载">C++函数重载</h2><p>新建一个文件test.cpp，如下,</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{<span class="keyword">return</span> a + <span class="number">1</span>;}
<span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> a)</span> </span>{<span class="keyword">return</span> a + <span class="number">2</span>; }
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{<span class="keyword">return</span> test(<span class="number">1</span>) - test(<span class="number">2.0</span>); }
</code></pre><p>编译查看二进制结构：</p>
<pre><code><span class="number">172</span>-<span class="number">0</span>-<span class="number">0</span>-<span class="number">136</span>:Desktop sheng$ g++ test.cpp | nm
<span class="number">0000000100000f</span>50 T __Z4testd
<span class="number">0000000100000f</span>30 T __Z4testi
<span class="number">0000000100000000</span> T __mh_execute_header
<span class="number">0000000100000f</span>70 T _main
             U dyld_stub_binder
</code></pre><p>C++支持函数重名，如果仅仅是按照C语言的方式简单生成两个_test符号的话，那么链接器就无法区分两者的区别，也不知道具体要链接到哪一个函数上去。</p>
<p>我们首先能想到的最简单的处理规则就是把函数名和函数需要的参数直接拼接作为最终的符号。（如上可以拼接成test(int)和test(double),因为函数重载不支持根据返回值重载，所以不需要添加返回值)。但是这样不仅会造成生成的目标符号冗余并且在类型相同但是类型名字不同的时候会有歧义(例如unsigned和unsigned int)。所以，C++使用了一套复杂的类型转换和编码规则来处理这些函数来保证链接器能简单的获取函数中的信息。</p>
<p>例如上面的test.cpp生成的符号含义如下：</p>
<ol>
<li>开头的__是为了兼容C，没有什么意义。</li>
<li>__后的Z代表这个符号是被处理过的全局C++函数。</li>
<li>Z后面的数字4代表后面的字符个数，这里代表test这个字符串。</li>
<li>最后的d和i代表内置的参数类型double和int。前面提到过返回值不是函数的一部分，所以这个符号已经能表示整个函数的信息了。</li>
</ol>
<p>关于C++编译器命名处理的细节，可以参看侯捷翻译的《深度探索C++对象模型》和<a href="http://mentorembedded.github.io/cxx-abi/abi.html#mangling" target="_blank" rel="external">C++ ABI Document</a>。</p>
<p>Swift Name Mangling</p>
<p>Swift采用的Name Mangling原理上和C++类似，但是作为新出的语言，Swift吸收了C++的优点，补充了C++的不足，所以Swift的处理比C++要成熟和完善。</p>
<p>新建Swift文件如下test.swift：</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">e</span> {</span>
            <span class="class"><span class="keyword">enum</span> <span class="title">f</span> {</span>
                    <span class="keyword">case</span> <span class="constant">G</span>, <span class="constant">H</span>, <span class="constant">I</span>
            }
    }
    <span class="class"><span class="keyword">class</span> <span class="title">a</span> {</span>
            <span class="class"><span class="keyword">class</span> <span class="title">b</span> {</span>
                    <span class="class"><span class="keyword">class</span> <span class="title">c</span> {</span>
                            func d(<span class="symbol">y:</span> a, x <span class="symbol">w:</span> b, v <span class="symbol">u:</span> (<span class="symbol">x:</span> <span class="constant">Int</span>) -&gt; <span class="constant">Int</span>) -&gt; e.f {
                                    <span class="keyword">return</span> e.f.<span class="constant">G</span>
                            }
                    }
            }
    }
</code></pre><p>编译查看二进制结构：</p>
<pre><code><span class="number">172</span>-<span class="number">0</span>-<span class="number">0</span>-<span class="number">136</span>:Desktop sheng$ xcrun swiftc -emit-library -o test test.swift | nm -g
...
<span class="number">0000000000003</span>c00 S __TWoFCCC1a1a1b1c1dfTS0_1xS1_1vFT1xSi_Si_OVS_1e1f
...
</code></pre><p>生成了很多符号，我们选择函数符号来分析:</p>
<ol>
<li>nm生成信息的含义可以查看man手册。第二列的S含义： S (symbol in a section other than those above)</li>
<li>开头的_代表这是一个Swift符号。</li>
<li>_T代表这是一个全局符号。（global text）</li>
<li>F说明这个符号是个函数。（Function）</li>
<li>大的 </li>
<li>大写的C代表”class Type”,因为这里class内嵌了3层，所以有3个大写的C。</li>
<li>第一个1a代表”module name”,第二个代表”class name”。</li>
<li>大的</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/06/02/Swift-Name-Mangling/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/04/28/JSPatch使用笔记/">
                            JSPatch使用笔记
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-04-28T09:41:38+08:00">
	
		    Apr 28, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="为什么需要Hotfix/Hotdeploy">为什么需要Hotfix/Hotdeploy</h3><p>在日常的开发过程中，随着项目规模逐渐变大，即使走完整的流程，也无法完全避免bug;出现非严重bug一般是等到下一版本改进，在未改进之前会影响用户体验； 出现严重bug之后，只能下架AppStore上的App在修改bug之后重新提审，AppStore审核周期又比较长，而且审核过程中有很多的不确定性。这些影响到我们开发人员对稳定性和可靠性的要求。</p>
<p>另外，我们在开发的过程中，产品经常会有动态更新某个模块或者页面的需求。</p>
<p>所以，我们需要一种更灵活，更方便的方式来修改线上Bug或者动态更改线上的App的行为。</p>
<h3 id="Hotfix/Hotdeploy方案">Hotfix/Hotdeploy方案</h3><h4 id="WebApp">WebApp</h4><p>这个没啥说的，如果使用WebApp的方式，随时可以动态更改想要的模块。但是关于WebApp的体验方面，</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/04/28/JSPatch使用笔记/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/04/17/iOS静态代码检查/">
                            iOS静态代码检查
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-04-17T15:52:46+08:00">
	
		    Apr 17, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="前言">前言</h3><p>代码审查是保证代码质量的重要环节，代码审查主要是针对编码规范、代码走查、代码评审、单元测试、集成测试、持续集成、执行流程等编程方面的增强。本章介绍一些关于编码规范、代码评审阶段的一些自动化工具的配置和使用。</p>
<h3 id="准备工作">准备工作</h3><p>我的操作系统为OS X EI Capitan 10.11.3，以下如果不作说明，默认在此环境下。以下工具安装的都是最新版本。</p>
<h4 id="所需工具">所需工具</h4><ol>
<li>SonarQube <a href="http://www.sonarqube.org/downloads/" target="_blank" rel="external">官网下载链接</a></li>
<li>Sonar Runner <a href="http://www.sonarqube.org/downloads/" target="_blank" rel="external">官网下载链接</a></li>
<li>MySQL <a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">官网下载链接</a></li>
<li>OClint <a href="http://oclint.org/downloads.html" target="_blank" rel="external">官网下载链接</a></li>
<li>xcodebuild (无需单独安装，Xcode自带,如果使用xctool，需要单独下载<a href="https://github.com/facebook/xctool" target="_blank" rel="external">Git链接</a>)</li>
<li>XCPretty (xcodebuild格式化程序)  <a href="https://github.com/mneorr/xcpretty" target="_blank" rel="external">git链接</a></li>
</ol>
<p>以上工具都可以使用brew安装。关于brew不是本文的重点，这里不作介绍。<a href="http://brew.sh/" target="_blank" rel="external">brew官网</a></p>
<h4 id="所需组件">所需组件</h4><p>Sonar Plugin for Objective C<br>可以直接下载Sonar官方提供的sonar-objective-c-plugin-x.x.x-SNAPSHOT.jar，不过这个是收费的。github上有提供的开源代码<a href="https://github.com/octo-technology/sonar-objective-c/tree/oclint" target="_blank" rel="external">sonar-plugin</a>,可以自己下载编译。也可以在网上搜编译安装好的jar文件。</p>
<h3 id="环境搭建">环境搭建</h3><ol>
<li><p>创建sonar用户和sonar数据库</p>
<p>第一次登陆mysql无需密码，直接执行<code>mysql -uroot</code>即可，在安装任何工具的时候都要注意console上的提示信息。</p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> sonar <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span>
 <span class="operator"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'sonar'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</span>
 <span class="operator"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sonar.* <span class="keyword">TO</span> <span class="string">'sonar'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</span>
 <span class="operator"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sonar.* <span class="keyword">TO</span> <span class="string">'sonar'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</span>
 <span class="operator"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span>
</code></pre></li>
<li><p>安装SonarQube</p>
<p>解压SonarQube到安装目录(如/usr/local/),将sonar- objective-c-plugin-x.x.x-SNAPSHOT.jar放入sonarqube/extensions/plugins下。编辑配置文件sonar.properties。<br>设置数据库为mysql:</p>
<pre><code>sonar<span class="class">.jdbc</span><span class="class">.url</span>=jdbc:mysql:<span class="comment">//localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</span>
</code></pre></li>
<li><p>启动SonarQube</p>
<p>终端执行<code>/etc/sonarqube/bin/macosx-universal-64/sonar.sh start</code>启动服务器。如果不想每次都写这么长的命令，可以把Sonar目录配置到环境变量里，或者直接给命令设置alias别名。启动成功会输出以下信息：</p>
<pre><code><span class="string">liudesheng:</span> sheng$ <span class="regexp">/usr/</span>local<span class="regexp">/sonarqube-4.5.6/</span>bin<span class="regexp">/macosx-universal-64/</span>sonar.sh start
  Starting SonarQube...
 Started SonarQube.
</code></pre></li>
<li><p>测试sonarQube</p>
<p> 浏览器输入<code>http://localhost:9000/</code>,出现以下界面:</p>
<p> <img src="http://7xorsh.com1.z0.glb.clouddn.com/indexPage.jpg" alt="Loading" title="http://localhost:9000/"></p>
</li>
<li><p>Sonar Runner安装配置</p>
<p>解压Sonar Runner到指定目录(如/usr/local)，配置Sonar Runner下的sonar-runner.properties。</p>
<pre><code>#----- Default SonarQube server
sonar<span class="class">.host</span><span class="class">.url</span>=http:<span class="comment">//localhost:9000</span>
   #----- MySQL
sonar<span class="class">.jdbc</span><span class="class">.url</span>=jdbc:mysql:<span class="comment">//localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8</span>
#----- Global database settings
sonar<span class="class">.jdbc</span><span class="class">.username</span>=sonar
sonar<span class="class">.jdbc</span><span class="class">.password</span>=sonar
</code></pre></li>
<li><p>oclint安装配置</p>
</li>
</ol>
<p>解压oclint到指定目录，并配置环境变量。终端输入<code>oclint</code>，有以下输出说明安装正确:</p>
<pre><code><span class="string">oclint:</span> Not enough positional command line arguments specified!
Must specify at least <span class="number">1</span> positional <span class="string">arguments:</span> <span class="string">See:</span> oclint -help
</code></pre><h3 id="代码扫描">代码扫描</h3><p>进入项目根目录，执行</p>
<pre><code>oclint-json-compilation-database -v -i scanPath/  -- -<span class="built_in">max</span>-<span class="built_in">priority</span>-<span class="number">1</span> <span class="number">10000</span> -<span class="built_in">max</span>-<span class="built_in">priority</span>-<span class="number">2</span> <span class="number">10000</span> -<span class="built_in">max</span>-<span class="built_in">priority</span>-<span class="number">3</span> <span class="number">10000</span> -report-<span class="built_in">type</span> pmd -o oclint.xml
</code></pre><p> 我在执行这个命令的时候，发现命令能执行完成，但是不能生成oclint.xml文件。查了下帮助文件发现有个debug模式：</p>
<pre><code>optional arguments:
  -<span class="ruby">h, --help            show this help message <span class="keyword">and</span> exit
</span>  -<span class="ruby">v                    show invocation command with arguments
</span>  -<span class="ruby">debug, --debug       invoke <span class="constant">OCLint</span> <span class="keyword">in</span> debug mode
</span>  -<span class="ruby">i <span class="constant">INCLUDES</span>, -<span class="keyword">include</span> <span class="constant">INCLUDES</span>, --<span class="keyword">include</span> <span class="constant">INCLUDES</span>
</span>                    extract files matching pattern
  -<span class="ruby">e <span class="constant">EXCLUDES</span>, -exclude <span class="constant">EXCLUDES</span>, --exclude <span class="constant">EXCLUDES</span>
</span>                    remove files matching pattern
</code></pre><p> 但是在执行的时候报错说oclint不支持debug模式。又搜索很久还是无果，无奈进入官方翻了半天在某一页最后一行发现一行小字：<code>debug mode need oclint compile by debug mode</code>，知道真相的我眼泪掉下来，查了文档和stackoverflow最后也没找到如何<code>compile by debug mode</code>。</p>
<p> 然后which到目录看了一下<code>oclint-json-compilation-database</code>是<code>oclint</code>的<code>Python</code>脚本,主要功能就是拼接oclint的参数并开启子进程执行命令：</p>
<pre><code>oclint_invocation = OCLINT_BIN + debug_argument + oclint_arguments + <span class="string">' '</span> + source_paths
<span class="keyword">if</span> args<span class="class">.invocation</span>:
print <span class="string">'------------------------------ OCLint ------------------------------'</span>
print oclint_invocation
print <span class="string">'--------------------------------------------------------------------'</span>
exit_code = subprocess.<span class="function"><span class="title">call</span><span class="params">(oclint_invocation, shell=True)</span></span>
sys.<span class="function"><span class="title">exit</span><span class="params">(exit_code)</span></span>
</code></pre><p>怪不得没有任何输出信息，原来是在子进程里执行的。开启-v模式把拼接的命令直接放入终端执行(因为文件太多，这个命令足足有3屏)，终于出现短短一行的出错信息：<br><code>Segmentation fault: 11</code>。</p>
<p>段错误是Linux系统编程中非常常见的错误，原因主要是非法的内存访问，但是这个段错误没有生成Core dump文件，所以没办法分析具体错误原因。这时我想起了Linux下非常强大的系统级调试工具<code>trace</code>和<code>truss</code>。查了一下在Mac下与之对应的是<code>dtrace</code>和<code>dtruss</code>工具。dtrace一般用于系统函数跟踪，它的优点在于：可以在不影响原有程序运行的情况下调试，跟踪系统调用并生成日志文件。详细用法及说明可以man查看。</p>
<p>执行<code>sudo dtruss -f oclint_invocation &amp;&gt;result.txt</code>分析命令执行情况并把所有输出重定向到result.txt中。打开文件并查找文件中的ERR或者ERROR字样，定位到很多这样的错误：</p>
<pre><code><span class="number">44317</span>/<span class="number">0x485ef</span>:  stat64(<span class="string">"/AppleInternal/XBS/.isChrooted\0"</span>, <span class="number">0x7FFF56824EE8</span>, <span class="number">0x1</span>)         = -<span class="number">1</span> Err<span class="preprocessor">#<span class="number">2</span></span>
<span class="number">44317</span>/<span class="number">0x485ef</span>:  stat64(<span class="string">"/AppleInternal\0"</span>, <span class="number">0x7FFF56824E58</span>, <span class="number">0x1</span>)         = -<span class="number">1</span> Err<span class="preprocessor">#<span class="number">2</span></span>
</code></pre><p>说明是在调用stat64这个函数出错的，出错的返回值是-1，用man查下这个函数的说明：</p>
<pre><code>The stat() <span class="function"><span class="keyword">function</span> <span class="title">obtains</span> <span class="title">information</span> <span class="title">about</span> <span class="title">the</span> <span class="title">file</span> <span class="title">pointed</span> <span class="title">to</span> <span class="title">by</span></span>
 path.  Read, <span class="built_in">write</span> <span class="operator">or</span> execute permission <span class="operator">of</span> <span class="operator">the</span> named <span class="built_in">file</span> is <span class="operator">not</span>
 required, but all <span class="built_in">directories</span> listed <span class="operator">in</span> <span class="operator">the</span> path name leading <span class="built_in">to</span> <span class="operator">the</span> <span class="built_in">file</span>
 must be searchable.

 <span class="constant">RETURN</span> VALUES
 Upon successful completion <span class="operator">a</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="number">0</span> is returned.  Otherwise, <span class="operator">a</span> <span class="built_in">value</span>
 <span class="operator">of</span> -<span class="number">1</span> is returned <span class="operator">and</span> errno is <span class="built_in">set</span> <span class="built_in">to</span> indicate <span class="operator">the</span> error.
</code></pre><p> 这个函数是获取文件信息的，成功返回0，失败返回-1并设置errno。到这里原因就大致清楚了，原因大概是同时分析的文件超过了oclint的上限。修改下参数重新执行就可以了。</p>
<h3 id="导出扫描结果到Sonar">导出扫描结果到Sonar</h3><p>将<code>sonar-project.properties</code>放入代码根目录，根据具体情况修改对应的项，注意必须修改设置<code>sonar.objectivec.project</code>和<code>sonar.objectivec.appScheme</code>。如果是workspace工程，需要设置<code>sonar.objectivec.workspace</code>项。</p>
<p>然后在SonarQube中执行Sonar Runner：<code>sonar-runer.sh</code> （前面已经配置好环境变量，所以这里可以直接执行）。</p>
<p>如果在执行的时候出现<code>java.database.connetion</code>字样的错误，请仔细检查数据库连接及配置信息。</p>
<p>我执行这一步的时候发现导出的结果除了文件信息外其他都是空，仔细的分析了下执行时的log，发现这是SonarQuebe有个bug，SonarQuebe代码分析时默认生成的文件oclint.xml在Sonar-reports目录，但是读取时它会到根目录读取，截止目前为止，SonarQuebe仍有这个bug。解决办法就是把生成的xml文件拷贝到根目录在重新执行<code>sonar-runer.sh</code>。</p>
<p>继续执行的时候出现了<code>Incorrect string value: &#39;\xF0\x90\x8D\x83\xF0\x90...&#39; for column &#39;data&#39; at row 1</code>的错误，开始我以为是编码错误，后来发现是因为是插入数据的大小超过的字段限制的大小,这个也算是SonarQube的bug吧。我试了下，修改对应数据库字段类型longtext为longblob即可。</p>
<p><img src="http://7xorsh.com1.z0.glb.clouddn.com/databaseAlert.jpg" alt="Loading"></p>
<p>执行成功后就可以看到扫描结果了:</p>
<p><img src="http://7xorsh.com1.z0.glb.clouddn.com/scan_result.jpg" alt="Loading"></p>
<p>配合Jira能够更方便的跟踪和分配问题，配合Jenkins能够进行自动化部署和自动化单元测试，我将在以后的文章里纪录Jenkins自动化部署和单元测试的方法。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/04/17/iOS静态代码检查/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/12/nil0Nil0NULL0null0nullptr0NSNull/">
                            nil/Nil/NULL/NUL/nullptr/NSNull
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-12T10:41:47+08:00">
	
		    Feb 12, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="如何表示“不存在”">如何表示“不存在”</h2><p>要理解不存在这个概念，首先需要理解存在。如何定义“存在”这个概念是一个哲学问题，海德格尔在《存在与时间》中提及了存在的不可定义性。原文如下：</p>
<blockquote>
<p>『存在』这个概念是不可定义的。这是从它的最高普遍性推论出来的。这话有道理——既然定义来自最近的种加属差。确实不能把『存在』理解为存在者，令存在者归属于存在并不能使『存在』得到规定。</p>
</blockquote>
<p>对于哲学来说，表示存在或者不存在这个概念是比较困难的问题。对于数学和计算机科学来说，表示不存在要简单的多，就是用存在的概念表示不存在概念。</p>
<h2 id="NULL">NULL</h2><p>NULL一般是这么定义的：</p>
<pre><code><span class="id">#ifdef</span> __cplusplus  
<span class="hexcolor">#def</span>ine NULL    <span class="number">0</span>  
<span class="id">#else</span>  
<span class="hexcolor">#def</span>ine NULL    ((void *)<span class="number">0</span>)  
<span class="id">#endif</span>  
</code></pre><p> 可以看出在C和C++中NULL的定义不同。在C语言中，不需要考虑函数重载等问题，所以直接简单定义为一个0地址的<code>void*</code>就行了。由于C++引入了更严格的类型检查，所以把直接<code>void*</code>类型的值赋给一个有类型指针是不行的，编译器会报错(eg:<code>malloc</code>)。但同时C++要保持和C的兼容性，所以在C++里，<code>NULL</code>直接定义为整型0。</p>
<h2 id="nullptr">nullptr</h2><p>将<code>NULL</code>直接定义成0一般是没问题的，但是假如遇到函数重载：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">void</span> *ptr)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;
</code></pre><p>如果这样调用<code>foo(1,NULL)</code>就会有歧义，因为NULL是指针类型，但是同时NULL也是整型。同样的，这样的问题在模版类型推导的时候也会出现：</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(T a)</span></span>;
</code></pre><p>如果调用<code>foo(NULL)</code>是应该推导出<code>int foo(int a)</code>呢还是<code>int foo(void *a)</code>呢。为了解决这个问题。C++11引入了一个新的概念：nullptr。nullptr的实现如下：</p>
<pre><code> <span class="keyword">const</span>
<span class="keyword">class</span> <span class="keyword">nullptr_t</span>
{
<span class="keyword">public</span>:
<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="keyword">const</span>
    { <span class="keyword">return</span> <span class="number">0</span>; }
<span class="keyword">template</span>&lt;<span class="keyword">class</span> C, <span class="keyword">class</span> T&gt;
<span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="keyword">const</span>
    { <span class="keyword">return</span> <span class="number">0</span>; }

<span class="keyword">private</span>:
    <span class="keyword">void</span> <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;
} <span class="literal">nullptr</span> = {};
</code></pre><p>其实<code>nullptr</code>和swift中的<code>Optional</code>的实现非常像了。看了nullptr的实现，可以自己写一个Optional的实现。我会在下一篇博客去介绍Optional。</p>
<h2 id="nil">nil</h2><p>nil和NULL语义不同，但是在底层实现上是等价的。需要注意的是，nil可以向对象发送消息，如果消息有返回值，会有以下几种情况：</p>
<ul>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。</li>
<li>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。</li>
<li>如果方法返回值为结构体，发送给nil的消息将返回0。结构体中各个字段的值将都是0。其他的结构体数据类型将不是用0填充的。</li>
<li>如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</li>
</ul>
<h2 id="Nil">Nil</h2><p>Nil是OC类类型的书面空值，对应<code>Class</code>类型对象。底层实现和nil是一样的。Nil的定义如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">ifndef</span> Nil</span>
<span class="preprocessor"># <span class="keyword">if</span> __has_feature(cxx_nullptr)</span>
<span class="preprocessor">#   <span class="keyword">define</span> Nil nullptr</span>
<span class="preprocessor"># <span class="keyword">else</span></span>
<span class="preprocessor">#   <span class="keyword">define</span> Nil __DARWIN_NULL</span>
<span class="preprocessor"># <span class="keyword">endif</span></span>
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="preprocessor">#<span class="keyword">ifndef</span> nil</span>
<span class="preprocessor"># <span class="keyword">if</span> __has_feature(cxx_nullptr)</span>
<span class="preprocessor">#   <span class="keyword">define</span> nil nullptr</span>
<span class="preprocessor"># <span class="keyword">else</span></span>
<span class="preprocessor">#   <span class="keyword">define</span> nil __DARWIN_NULL</span>
<span class="preprocessor"># <span class="keyword">endif</span></span>
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><h2 id="NSNull">NSNull</h2><p>在OC的集合中中nil代表集合的结束，所以不能在集合里存储nil。所以就有了NSNull用一个类来表示空值。一般用来表示集合中的空对象。</p>
<h2 id="NUL">NUL</h2><p>用来表示字符串的结束。注意：标准C中无定义。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/12/nil0Nil0NULL0null0nullptr0NSNull/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/30/Xcode升级之后Alcatraz和插件失效/">
                            Xcode升级之后Alcatraz和插件失效
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-30T13:31:11+08:00">
	
		    Jan 30, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><a href="http://alcatraz.io" target="_blank" rel="external">Alcatraz</a>是一个非常好用的插件管理器。前一段时间把Xcode升级到了7.2之后Alcatraz失效了，而且之前安装的所有插件也都消失了。查了资料才知道Apple为了避免插件造成新版本的Xcode启动时崩溃，所以只允许匹配<code>DVTPlugInCompatibilityUUIDs</code>的插件被加载。</p>
<p>可以通过下面的方法激活之前安装的插件：</p>
<blockquote>
<pre><code><span class="keyword">find</span> ~<span class="regexp">/Library/</span>Application\ Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins -name Info.plist -maxdepth <span class="number">3</span> | xargs -I{} defaults <span class="keyword">write</span> {} DVTPlugInCompatibilityUUIDs -array-add `defaults <span class="keyword">read</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/I</span>nfo DVTPlugInCompatibilityUUID`
</code></pre></blockquote>
<p>另外如果你不小心在Xcode启动的时候点击了 <strong>Skip Bundle</strong>,你可以通过下面的方式避免重新安装的悲剧。</p>
<blockquote>
<pre><code>defaults <span class="keyword">delete</span> com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-{your_xcode_version} 
</code></pre></blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/30/Xcode升级之后Alcatraz和插件失效/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 頁 共 1 頁</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 刘得胜. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">刘得胜</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2015/11/24/Hello-World-0/">
                            <h3 class="media-heading">Hello World</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Nov 24, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/01/30/Xcode升级之后Alcatraz和插件失效/">
                            <h3 class="media-heading">Xcode升级之后Alcatraz和插件失效</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 30, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/02/07/不经意间/">
                            <h3 class="media-heading">你在哪里</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Feb 7, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/02/12/nil0Nil0NULL0null0nullptr0NSNull/">
                            <h3 class="media-heading">nil/Nil/NULL/NUL/nullptr/NSNull</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Feb 12, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/03/12/hello-world/">
                            <h3 class="media-heading">MarkDown语法学习</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Mar 12, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/04/17/iOS静态代码检查/">
                            <h3 class="media-heading">iOS静态代码检查</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Apr 17, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/04/28/JSPatch使用笔记/">
                            <h3 class="media-heading">JSPatch使用笔记</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Apr 28, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/05/29/iOS数据结构-实现NSMutableArray/">
                            <h3 class="media-heading">iOS数据结构(一):实现NSMutableArray</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 29, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/06/02/Swift-Name-Mangling/">
                            <h3 class="media-heading">Name Mangling</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jun 2, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://yoursite.com/2016/09/09/关于iOS组件化方案的思考/">
                            <h3 class="media-heading">关于iOS组件化方案的思考</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Sep 9, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 16 篇文章
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js" type="text/javascript"></script>
<script src="/assets/js/tranquilpeak.js" type="text/javascript"></script>
<!--SCRIPTS END-->



    </body>
</html>
