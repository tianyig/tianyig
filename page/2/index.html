<!doctype html>
<html class="theme-next   use-motion ">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2">






<meta property="og:type" content="website">
<meta property="og:title" content="风过无痕">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="风过无痕">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风过无痕">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> 风过无痕 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">风过无痕</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">这城市华灯初上，多两个人悲剧散场</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            Tags
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/Swift-Name-Mangling/" itemprop="url">
                  Name Mangling
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2016-06-02T15:35:37+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; In
              
                <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing">
                  <a href="/categories/新测试/" itemprop="url" rel="index">
                    <span itemprop="name">新测试</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是Name Mangling？Name Mangling是一种通过在函数里添加附加信息，把函数名转换成链接器符号的一个步骤。具体解释可以参看wiki。<a href="https://en.wikipedia.org/wiki/Name_mangling" target="_blank" rel="noopener">Name Mangling</a></p>
<p>为什么需要Name Mangling?因为有些语言(如C++)在特定情况下允许函数重名，比如重载、继承等。这样在函数调用的时候仅仅根据函数名无法判断要调用哪个函数，这就需要对这些函数做一定的处理以便于区分重名函数调用。</p>
<p>在C语言里，虽然不存在命名冲突的问题，但是在C语言里还是做了命名处理，在函数名字前都加了下划线。例如：</p>
<p>新建一个文件test.c如下,</p>
<pre><code>#include &lt;stdio.h&gt;
int main(){ return 0; }
</code></pre><p>编译后查看二进制符号:</p>
<pre><code>172-0-0-136:Desktop sheng$ gcc test.c | nm
0000000100000000 T __mh_execute_header
0000000100000fa0 T _main
             U dyld_stub_binder
</code></pre><p>C语言的命名处理基本没什么用处，但是为了兼容性等其它原因，还是保留下来了。根据惯例，C语言中的符号默认都会加上下划线，但是汇编中的符号不会自动加上下划线。</p>
<p>Objective-C不会存在命名冲突，因为OC的方法调用是通过消息机制实现的，而且OC不支持函数重载。在支持函数重载的语言里，Name Mangling就变得有用处了。</p>
<h2 id="C-函数重载"><a href="#C-函数重载" class="headerlink" title="C++函数重载"></a>C++函数重载</h2><p>新建一个文件test.cpp，如下,</p>
<pre><code>int test(int a) {return a + 1;}
int test(double a) {return a + 2; }
int main() {return test(1) - test(2.0); }
</code></pre><p>编译查看二进制结构：</p>
<pre><code>172-0-0-136:Desktop sheng$ g++ test.cpp | nm
0000000100000f50 T __Z4testd
0000000100000f30 T __Z4testi
0000000100000000 T __mh_execute_header
0000000100000f70 T _main
             U dyld_stub_binder
</code></pre><p>C++支持函数重名，如果仅仅是按照C语言的方式简单生成两个_test符号的话，那么链接器就无法区分两者的区别，也不知道具体要链接到哪一个函数上去。</p>
<p>我们首先能想到的最简单的处理规则就是把函数名和函数需要的参数直接拼接作为最终的符号。（如上可以拼接成test(int)和test(double),因为函数重载不支持根据返回值重载，所以不需要添加返回值)。但是这样不仅会造成生成的目标符号冗余并且在类型相同但是类型名字不同的时候会有歧义(例如unsigned和unsigned int)。所以，C++使用了一套复杂的类型转换和编码规则来处理这些函数来保证链接器能简单的获取函数中的信息。</p>
<p>例如上面的test.cpp生成的符号含义如下：</p>
<ol>
<li>开头的__是为了兼容C，没有什么意义。</li>
<li>__后的Z代表这个符号是被处理过的全局C++函数。</li>
<li>Z后面的数字4代表后面的字符个数，这里代表test这个字符串。</li>
<li>最后的d和i代表内置的参数类型double和int。前面提到过返回值不是函数的一部分，所以这个符号已经能表示整个函数的信息了。</li>
</ol>
<p>关于C++编译器命名处理的细节，可以参看侯捷翻译的《深度探索C++对象模型》和<a href="http://mentorembedded.github.io/cxx-abi/abi.html#mangling" target="_blank" rel="noopener">C++ ABI Document</a>。</p>
<p>Swift Name Mangling</p>
<p>Swift采用的Name Mangling原理上和C++类似，但是作为新出的语言，Swift吸收了C++的优点，补充了C++的不足，所以Swift的处理比C++要成熟和完善。</p>
<p>新建Swift文件如下test.swift：</p>
<pre><code>struct e {
            enum f {
                    case G, H, I
            }
    }
    class a {
            class b {
                    class c {
                            func d(y: a, x w: b, v u: (x: Int) -&gt; Int) -&gt; e.f {
                                    return e.f.G
                            }
                    }
            }
    }
</code></pre><p>编译查看二进制结构：</p>
<pre><code>172-0-0-136:Desktop sheng$ xcrun swiftc -emit-library -o test test.swift | nm -g
...
0000000000003c00 S __TWoFCCC1a1a1b1c1dfTS0_1xS1_1vFT1xSi_Si_OVS_1e1f
...
</code></pre><p>生成了很多符号，我们选择函数符号来分析:</p>
<ol>
<li>nm生成信息的含义可以查看man手册。第二列的S含义： S (symbol in a section other than those above)</li>
<li>开头的_代表这是一个Swift符号。</li>
<li>_T代表这是一个全局符号。（global text）</li>
<li>F说明这个符号是个函数。（Function）</li>
<li>大的 </li>
<li>大写的C代表”class Type”,因为这里class内嵌了3层，所以有3个大写的C。</li>
<li>第一个1a代表”module name”,第二个代表”class name”。</li>
<li>大的</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/29/iOS数据结构-实现NSMutableArray/" itemprop="url">
                  iOS数据结构(一):实现NSMutableArray
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2016-05-29T20:11:59+08:00" content="2016-05-29">
              2016-05-29
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集合是Cocoa中常用的数据结构，但是对于程序员来说底层实现一般都是透明的。今天，我们根据使用场景自己实现一个<code>NSMutableArray</code>。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>因为<code>NSMutableArray</code>是一个<code>class cluster</code>,所以实现起来非常简单，只需要继承它然后实现它基本方法就能实现具有完整功能的<code>NSMutableArray</code>(上层方法是根据基本方法来实现的)。下面是<code>NSMutableArray</code>的基本方法：</p>
<pre><code>- (NSUInteger)count;
- (id)objectAtIndex:(NSUInteger)index;
- (void)addObject:(id)anObject;
- (void)insertObject:(id)anObject atIndex:(NSUInteger)index;
- (void)removeLastObject;
- (void)removeObjectAtIndex:(NSUInteger)index;
- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject;
</code></pre><p>实际上，上面的基本方法还是可以简化，比如<code>addObject:</code>可以用<code>insertObject:atIndex:,</code>实现，而<code>removeLastObject</code>可以用<code>removeObjectAtIndex:</code>来实现。</p>
<p>实现这些方法的大致思路是什么呢？首先，我们可以用C array作为底层的存储结构，但是C array是不可变的，不支持添加或者删除某个元素，所以，在涉及到添加或者删除元素的时候，我们可以通过copy数组的方式来处理。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>完整代码实现已经放在GitHub上。<a href="https://github.com/tianyig/minishell" target="_blank" rel="noopener">NSMutableArray源代码</a>。</p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><pre><code>@interface JJMutableArray : NSMutableArray
@end
</code></pre><p>我们的实现继承<code>NSMutableArray</code>,这样就可以不用关心初始化的内存分配，把精力放到这几个方法的实现上。</p>
<h3 id="定义私有变量"><a href="#定义私有变量" class="headerlink" title="定义私有变量"></a>定义私有变量</h3><pre><code>@implementation JJMutableArray {
    NSUInteger _count;
    NSUInteger _capacity;
    id *_objs;
}
</code></pre><p><code>_objs</code>是C array，<code>_capacity</code>用来储存数组内存空间的大小，数组里实际元素的个数用<code>_count</code>来表示。</p>
<p>使用<code>JJMutableArray</code>第一步是初始化，所以我们需要先实现<code>initWithCapacity:</code>,实际上已<code>+array</code>开头的方法基本上都是用这个方法实现的，这个方法的具体实现官方没有具体的文档，这里直接调用<code>[super init]</code>即可。</p>
<p>可能这里有同学比较好奇，这个实现应该非常简单啊，数组里存储的是固定大小的指针，根据参数分配固定大小的内存空间不就可以了吗？其实有以下几个需要考虑的问题：</p>
<ol>
<li>如果分配的空间远远大于实际需要的，是不是需要担心内存浪费？</li>
<li>如果分配的空间小于实际需要的，那么在增加大量新的元素的效率如何？(这个涉及到内存增长策略，下面会解释)</li>
<li>如果参数是0如何处理，是不是等同于调用<code>[[NSMutableArray alloc] init]</code>？</li>
</ol>
<p>这里先回答第三个问题，实际上它们是不等价的,至于两者有什么不同可以参考stackoverflow上的这个答案:<a href="http://stackoverflow.com/questions/6077422/objective-c-nsarray-init-versus-initwithcapacity0/6077543#6077543" target="_blank" rel="noopener">Objective-c NSArray init versus initWithCapacity:0</a>。</p>
<p><code>initWithCapacity:</code>的具体实现细节不是这篇文章的主题，这里不再讨论。</p>
<p>然后与之对应的我们实现<code>dealloc</code>函数，当一个数组被销毁的时候，需要释放它管理的所有对象的内存空间，简单起见，我们直接移除所有元素然后释放数组的内存空间。</p>
<pre><code>- (void)dealloc
{
    [self removeAllObjects];
    free(_objs);
    [super dealloc];
}
</code></pre><p>接下来可以开始实现一些具体的函数，首先实现<code>count</code>函数,因为<code>_count</code>保存了实际元素的个数，直接返回即可:</p>
<pre><code>- (NSUInteger)count
{
    return _count;
}
</code></pre><p>然后是<code>objectAtIndex:</code>,实现也很简单，直接返回对应位置元素即可:</p>
<pre><code>- (id)objectAtIndex: (NSUInteger)index
{
    return _objs[index];
}
</code></pre><p>这里没有做参数越界检查和错误处理，所以在使用这个函数的时候越界的时候会直接崩溃，和系统函数表现一致。</p>
<h3 id="插入的实现"><a href="#插入的实现" class="headerlink" title="插入的实现"></a>插入的实现</h3><p>之前提过，<code>addObject:</code>可以通过<code>insertObject:atIndex:</code>实现：</p>
<pre><code>- (void)addObject:(id)anObject
{
    [self insertObject: anObject atIndex: [self count]];
}
</code></pre><p>考虑内存空间已经满的时候，这个时候需要给新元素分配新的内存空间：</p>
<pre><code>- (void)insertObject: (id)anObject atIndex: (NSUInteger)index
{
    if(_count &gt;= _capacity)
    {
</code></pre><p>计算新元素需要需要的空间，在第一次分配的时候，我们最少分配16个元素的空间。之后每次分配当前空间2倍大小，是因为配置新空间,数据移动,释还旧空间是个大工程，时间成本很高，应该加入未雨绸缪的考虑，这样可以减少以后的内存分配和移动操作，提升数组效率。分配完空间之后，把原来的元素拷贝过来，下面是代码：</p>
<pre><code>NSUInteger newCapacity = MAX(_capacity * 2, 16);
id *newObjs = malloc(newCapacity * sizeof(*newObjs));
memcpy(newObjs, _objs, _count * sizeof(*_objs));
</code></pre><p> 关于内存空间的分配，我们这里采用的是最简单的策略，即每次分配原来空间的2倍大小，这里参考了SGI STL的实现策略。(最新的C++11对vector的增长策略做了调整)。</p>
<p>然后释放之前的内存空间：</p>
<pre><code>    free(_objs);
    _objs = newObjs;
    _capacity = newCapacity;
}
</code></pre><p>经过这样的操作之后，已经能保证有足够的空间存储新的元素。我们接着需要把要插入位置之后的元素向后挪动一个位置，给要插入的元素留出位置，这里可以使用<code>memmove</code>函数。</p>
<pre><code>memmove(_objs + index + 1, _objs + index, ([self count] - index) * sizeof(*_objs));
</code></pre><p>作为<code>memcpy</code>的变体，标准是允许<code>memmove</code>允许移动的区域是有重叠的，而且会覆盖重叠的部分，并且它会假设要移动的位置有足够的空间容纳要移动的元素，否则就会指针越界。(注意：<code>memmove</code>的实现有多种，且在debug和release下行为不一定一致)</p>
<p>移动完成之后，就需要在空出的位置放置我们的新元素，然后让元素个数加1：</p>
<pre><code>    _objs[index] = [anObject retain];

    _count++;
}
</code></pre><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>移除最后一个元素可以通过下面的方式实现：</p>
<pre><code>- (void)removeLastObject
{
    [self removeObjectAtIndex: [self count] - 1];
}
</code></pre><p>移除指针位置的元素也非常简单，将元素空间释放之后将后面的元素前移一个位置即可：</p>
<pre><code>- (void)removeObjectAtIndex: (NSUInteger)index
{
    _objs[index] ＝ nil;//ARC
    memmove(_objs + index, _objs + index + 1, ([self count] - index - 1) * sizeof(*_objs));
    _count--;
}
</code></pre><p>这里同样需要错误处理和参数合法性检查，为了方便，这里不在处理。</p>
<p>同样的原因，这里真正的实现应该尽量减少元素移动的次数。考虑一个极端情况，假设插入了几百万个元素，然后把它们全部移除。我们不希望每移除一个元素，就做一次内存调整。具体实现属于内存使用优化相关内容，这里采用最简单的实现。真正实现和<code>insertObject:atIndex:</code>类似。</p>
<h3 id="元素替换"><a href="#元素替换" class="headerlink" title="元素替换"></a>元素替换</h3><p>这个实现同样非常简单，直接替换即可:</p>
<pre><code>- (void)replaceObjectAtIndex: (NSUInteger)index withObject: (id)anObject
{
    _objs[index] = nil;
    _objs[index] = anObject;
}
</code></pre><p>好了，<code>NSMutableArray</code>的基础实现已经完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里简单实现了<code>NSMutableArray</code>，实际上<code>NSMutableArray</code>的底层实现采用的是非线性存储。很可能是用的是红黑树之类的平衡树来实现的。通过文档和官方开源<code>CFArray</code>源代码可以看出来(更底层的未来源，只能根据现象猜测):</p>
<blockquote>
<p>The access time for a value in the array is guaranteed to be at<br>    worst O(lg N) for any implementation, current and future, but will<br>    often be O(1) (constant time). Linear search operations similarly<br>    have a worst case complexity of O(N<em>lg N), though typically the<br>    bounds will be tighter, and so on. Insertion or deletion operations<br>    will typically be linear in the number of values in the array, but<br>    may be O(N</em>lg N) clearly in the worst case in some implementations.<br>    There are no favored positions within the array for performance;<br>    that is, it is not necessarily faster to access values with low<br>    indices, or to insert or delete values with high indices, or<br>    whatever.</p>
</blockquote>
<p>这个文档提到保证最低查询时间是对数级的，我们知道，如果是线性存储的只能是线性查找效率，是不可能达到对数查找的效率的。说明底层应该不是线性存储。</p>
<p>下面是CFArray判断两个数组是否等价的代码，从代码可以看出，数组元素是存在某个节点上的，从函数命名规范上来看，猜测哈希表作为底层数据结构存储的。</p>
<pre><code>static Boolean __CFArrayEqual(CFTypeRef cf1, CFTypeRef cf2) {
CFArrayRef array1 = (CFArrayRef)cf1;
CFArrayRef array2 = (CFArrayRef)cf2;
const CFArrayCallBacks *cb1, *cb2;
CFIndex idx, cnt;
if (array1 == array2) return true;
cnt = __CFArrayGetCount(array1);
if (cnt != __CFArrayGetCount(array2)) return false;
cb1 = __CFArrayGetCallBacks(array1);
cb2 = __CFArrayGetCallBacks(array2);
if (cb1-&gt;equal != cb2-&gt;equal) return false;
if (0 == cnt) return true;    /* after function comparison! */
for (idx = 0; idx &lt; cnt; idx++) {
const void *val1 = __CFArrayGetBucketAtIndex(array1, idx)-&gt;_item;
const void *val2 = __CFArrayGetBucketAtIndex(array2, idx)-&gt;_item;
if (val1 != val2) {
    if (NULL == cb1-&gt;equal) return false;
    if (!INVOKE_CALLBACK2(cb1-&gt;equal, val1, val2)) return false;
}
}
return true;
}
</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><p><a href="http://www.vellios.com/2010/08/22/why-game-devs-dont-use-objective-c/" target="_blank" rel="noopener">http://www.vellios.com/2010/08/22/why-game-devs-dont-use-objective-c/</a></p>
</li>
<li><p><a href="http://www.gnustep.org/resources/OpenStepSpec/FoundationKit/Classes/NSMutableArray.html" target="_blank" rel="noopener">http://www.gnustep.org/resources/OpenStepSpec/FoundationKit/Classes/NSMutableArray.html</a></p>
</li>
<li>STL源码剖析 侯捷</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/iOS静态代码检查/" itemprop="url">
                  iOS静态代码检查
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2016-04-17T15:52:46+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>代码审查是保证代码质量的重要环节，代码审查主要是针对编码规范、代码走查、代码评审、单元测试、集成测试、持续集成、执行流程等编程方面的增强。本章介绍一些关于编码规范、代码评审阶段的一些自动化工具的配置和使用。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我的操作系统为OS X EI Capitan 10.11.3，以下如果不作说明，默认在此环境下。以下工具安装的都是最新版本。</p>
<h4 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h4><ol>
<li>SonarQube <a href="http://www.sonarqube.org/downloads/" target="_blank" rel="noopener">官网下载链接</a></li>
<li>Sonar Runner <a href="http://www.sonarqube.org/downloads/" target="_blank" rel="noopener">官网下载链接</a></li>
<li>MySQL <a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">官网下载链接</a></li>
<li>OClint <a href="http://oclint.org/downloads.html" target="_blank" rel="noopener">官网下载链接</a></li>
<li>xcodebuild (无需单独安装，Xcode自带,如果使用xctool，需要单独下载<a href="https://github.com/facebook/xctool" target="_blank" rel="noopener">Git链接</a>)</li>
<li>XCPretty (xcodebuild格式化程序)  <a href="https://github.com/mneorr/xcpretty" target="_blank" rel="noopener">git链接</a></li>
</ol>
<p>以上工具都可以使用brew安装。关于brew不是本文的重点，这里不作介绍。<a href="http://brew.sh/" target="_blank" rel="noopener">brew官网</a></p>
<h4 id="所需组件"><a href="#所需组件" class="headerlink" title="所需组件"></a>所需组件</h4><p>Sonar Plugin for Objective C<br>可以直接下载Sonar官方提供的sonar-objective-c-plugin-x.x.x-SNAPSHOT.jar，不过这个是收费的。github上有提供的开源代码<a href="https://github.com/octo-technology/sonar-objective-c/tree/oclint" target="_blank" rel="noopener">sonar-plugin</a>,可以自己下载编译。也可以在网上搜编译安装好的jar文件。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>创建sonar用户和sonar数据库</p>
<p>第一次登陆mysql无需密码，直接执行<code>mysql -uroot</code>即可，在安装任何工具的时候都要注意console上的提示信息。</p>
<pre><code>CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;
 CREATE USER &apos;sonar&apos; IDENTIFIED BY &apos;sonar&apos;;
 GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;%&apos; IDENTIFIED BY &apos;sonar&apos;;
 GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;sonar&apos;;
 FLUSH PRIVILEGES;
</code></pre></li>
<li><p>安装SonarQube</p>
<p>解压SonarQube到安装目录(如/usr/local/),将sonar- objective-c-plugin-x.x.x-SNAPSHOT.jar放入sonarqube/extensions/plugins下。编辑配置文件sonar.properties。<br>设置数据库为mysql:</p>
<pre><code>sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance
</code></pre></li>
<li><p>启动SonarQube</p>
<p>终端执行<code>/etc/sonarqube/bin/macosx-universal-64/sonar.sh start</code>启动服务器。如果不想每次都写这么长的命令，可以把Sonar目录配置到环境变量里，或者直接给命令设置alias别名。启动成功会输出以下信息：</p>
<pre><code>liudesheng: sheng$ /usr/local/sonarqube-4.5.6/bin/macosx-universal-64/sonar.sh start
  Starting SonarQube...
 Started SonarQube.
</code></pre></li>
<li><p>测试sonarQube</p>
<p> 浏览器输入<code>http://localhost:9000/</code>,出现以下界面:</p>
<p> <img src="http://7xorsh.com1.z0.glb.clouddn.com/indexPage.jpg" alt="Loading" title="http://localhost:9000/"></p>
</li>
<li><p>Sonar Runner安装配置</p>
<p>解压Sonar Runner到指定目录(如/usr/local)，配置Sonar Runner下的sonar-runner.properties。</p>
<pre><code>#----- Default SonarQube server
sonar.host.url=http://localhost:9000
   #----- MySQL
sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8
#----- Global database settings
sonar.jdbc.username=sonar
sonar.jdbc.password=sonar
</code></pre></li>
<li><p>oclint安装配置</p>
</li>
</ol>
<p>解压oclint到指定目录，并配置环境变量。终端输入<code>oclint</code>，有以下输出说明安装正确:</p>
<pre><code>oclint: Not enough positional command line arguments specified!
Must specify at least 1 positional arguments: See: oclint -help
</code></pre><h3 id="代码扫描"><a href="#代码扫描" class="headerlink" title="代码扫描"></a>代码扫描</h3><p>进入项目根目录，执行</p>
<pre><code>oclint-json-compilation-database -v -i scanPath/  -- -max-priority-1 10000 -max-priority-2 10000 -max-priority-3 10000 -report-type pmd -o oclint.xml
</code></pre><p> 我在执行这个命令的时候，发现命令能执行完成，但是不能生成oclint.xml文件。查了下帮助文件发现有个debug模式：</p>
<pre><code>optional arguments:
  -h, --help            show this help message and exit
  -v                    show invocation command with arguments
  -debug, --debug       invoke OCLint in debug mode
  -i INCLUDES, -include INCLUDES, --include INCLUDES
                    extract files matching pattern
  -e EXCLUDES, -exclude EXCLUDES, --exclude EXCLUDES
                    remove files matching pattern
</code></pre><p> 但是在执行的时候报错说oclint不支持debug模式。又搜索很久还是无果，无奈进入官方翻了半天在某一页最后一行发现一行小字：<code>debug mode need oclint compile by debug mode</code>，知道真相的我眼泪掉下来，查了文档和stackoverflow最后也没找到如何<code>compile by debug mode</code>。</p>
<p> 然后which到目录看了一下<code>oclint-json-compilation-database</code>是<code>oclint</code>的<code>Python</code>脚本,主要功能就是拼接oclint的参数并开启子进程执行命令：</p>
<pre><code>oclint_invocation = OCLINT_BIN + debug_argument + oclint_arguments + &apos; &apos; + source_paths
if args.invocation:
print &apos;------------------------------ OCLint ------------------------------&apos;
print oclint_invocation
print &apos;--------------------------------------------------------------------&apos;
exit_code = subprocess.call(oclint_invocation, shell=True)
sys.exit(exit_code)
</code></pre><p>怪不得没有任何输出信息，原来是在子进程里执行的。开启-v模式把拼接的命令直接放入终端执行(因为文件太多，这个命令足足有3屏)，终于出现短短一行的出错信息：<br><code>Segmentation fault: 11</code>。</p>
<p>段错误是Linux系统编程中非常常见的错误，原因主要是非法的内存访问，但是这个段错误没有生成Core dump文件，所以没办法分析具体错误原因。这时我想起了Linux下非常强大的系统级调试工具<code>trace</code>和<code>truss</code>。查了一下在Mac下与之对应的是<code>dtrace</code>和<code>dtruss</code>工具。dtrace一般用于系统函数跟踪，它的优点在于：可以在不影响原有程序运行的情况下调试，跟踪系统调用并生成日志文件。详细用法及说明可以man查看。</p>
<p>执行<code>sudo dtruss -f oclint_invocation &amp;&gt;result.txt</code>分析命令执行情况并把所有输出重定向到result.txt中。打开文件并查找文件中的ERR或者ERROR字样，定位到很多这样的错误：</p>
<pre><code>44317/0x485ef:  stat64(&quot;/AppleInternal/XBS/.isChrooted\0&quot;, 0x7FFF56824EE8, 0x1)         = -1 Err#2
44317/0x485ef:  stat64(&quot;/AppleInternal\0&quot;, 0x7FFF56824E58, 0x1)         = -1 Err#2
</code></pre><p>说明是在调用stat64这个函数出错的，出错的返回值是-1，用man查下这个函数的说明：</p>
<pre><code>The stat() function obtains information about the file pointed to by
 path.  Read, write or execute permission of the named file is not
 required, but all directories listed in the path name leading to the file
 must be searchable.

 RETURN VALUES
 Upon successful completion a value of 0 is returned.  Otherwise, a value
 of -1 is returned and errno is set to indicate the error.
</code></pre><p> 这个函数是获取文件信息的，成功返回0，失败返回-1并设置errno。到这里原因就大致清楚了，原因大概是同时分析的文件超过了oclint的上限。修改下参数重新执行就可以了。</p>
<h3 id="导出扫描结果到Sonar"><a href="#导出扫描结果到Sonar" class="headerlink" title="导出扫描结果到Sonar"></a>导出扫描结果到Sonar</h3><p>将<code>sonar-project.properties</code>放入代码根目录，根据具体情况修改对应的项，注意必须修改设置<code>sonar.objectivec.project</code>和<code>sonar.objectivec.appScheme</code>。如果是workspace工程，需要设置<code>sonar.objectivec.workspace</code>项。</p>
<p>然后在SonarQube中执行Sonar Runner：<code>sonar-runer.sh</code> （前面已经配置好环境变量，所以这里可以直接执行）。</p>
<p>如果在执行的时候出现<code>java.database.connetion</code>字样的错误，请仔细检查数据库连接及配置信息。</p>
<p>我执行这一步的时候发现导出的结果除了文件信息外其他都是空，仔细的分析了下执行时的log，发现这是SonarQuebe有个bug，SonarQuebe代码分析时默认生成的文件oclint.xml在Sonar-reports目录，但是读取时它会到根目录读取，截止目前为止，SonarQuebe仍有这个bug。解决办法就是把生成的xml文件拷贝到根目录在重新执行<code>sonar-runer.sh</code>。</p>
<p>继续执行的时候出现了<code>Incorrect string value: &#39;\xF0\x90\x8D\x83\xF0\x90...&#39; for column &#39;data&#39; at row 1</code>的错误，开始我以为是编码错误，后来发现是因为是插入数据的大小超过的字段限制的大小,这个也算是SonarQube的bug吧。我试了下，修改对应数据库字段类型longtext为longblob即可。</p>
<p><img src="http://7xorsh.com1.z0.glb.clouddn.com/databaseAlert.jpg" alt="Loading"></p>
<p>执行成功后就可以看到扫描结果了:</p>
<p><img src="http://7xorsh.com1.z0.glb.clouddn.com/scan_result.jpg" alt="Loading"></p>
<p>配合Jira能够更方便的跟踪和分配问题，配合Jenkins能够进行自动化部署和自动化单元测试，我将在以后的文章里纪录Jenkins自动化部署和单元测试的方法。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/12/nil0Nil0NULL0null0nullptr0NSNull/" itemprop="url">
                  nil/Nil/NULL/NUL/nullptr/NSNull
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2016-02-12T10:41:47+08:00" content="2016-02-12">
              2016-02-12
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="如何表示“不存在”"><a href="#如何表示“不存在”" class="headerlink" title="如何表示“不存在”"></a>如何表示“不存在”</h2><p>要理解不存在这个概念，首先需要理解存在。如何定义“存在”这个概念是一个哲学问题，海德格尔在《存在与时间》中提及了存在的不可定义性。原文如下：</p>
<blockquote>
<p>『存在』这个概念是不可定义的。这是从它的最高普遍性推论出来的。这话有道理——既然定义来自最近的种加属差。确实不能把『存在』理解为存在者，令存在者归属于存在并不能使『存在』得到规定。</p>
</blockquote>
<p>对于哲学来说，表示存在或者不存在这个概念是比较困难的问题。对于数学和计算机科学来说，表示不存在要简单的多，就是用存在的概念表示不存在概念。</p>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>NULL一般是这么定义的：</p>
<pre><code>#ifdef __cplusplus  
#define NULL    0  
#else  
#define NULL    ((void *)0)  
#endif  
</code></pre><p> 可以看出在C和C++中NULL的定义不同。在C语言中，不需要考虑函数重载等问题，所以直接简单定义为一个0地址的<code>void*</code>就行了。由于C++引入了更严格的类型检查，所以把直接<code>void*</code>类型的值赋给一个有类型指针是不行的，编译器会报错(eg:<code>malloc</code>)。但同时C++要保持和C的兼容性，所以在C++里，<code>NULL</code>直接定义为整型0。</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>将<code>NULL</code>直接定义成0一般是没问题的，但是假如遇到函数重载：</p>
<pre><code>int foo(int a,void *ptr);
int foo(int a,int b);
</code></pre><p>如果这样调用<code>foo(1,NULL)</code>就会有歧义，因为NULL是指针类型，但是同时NULL也是整型。同样的，这样的问题在模版类型推导的时候也会出现：</p>
<pre><code>template&lt;class T&gt;
int foo(T a);
</code></pre><p>如果调用<code>foo(NULL)</code>是应该推导出<code>int foo(int a)</code>呢还是<code>int foo(void *a)</code>呢。为了解决这个问题。C++11引入了一个新的概念：nullptr。nullptr的实现如下：</p>
<pre><code> const
class nullptr_t
{
public:
template&lt;class T&gt;
inline operator T*() const
    { return 0; }
template&lt;class C, class T&gt;
inline operator T C::*() const
    { return 0; }

private:
    void operator&amp;() const;
} nullptr = {};
</code></pre><p>其实<code>nullptr</code>和swift中的<code>Optional</code>的实现非常像了。看了nullptr的实现，可以自己写一个Optional的实现。我会在下一篇博客去介绍Optional。</p>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil和NULL语义不同，但是在底层实现上是等价的。需要注意的是，nil可以向对象发送消息，如果消息有返回值，会有以下几种情况：</p>
<ul>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。</li>
<li>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。</li>
<li>如果方法返回值为结构体，发送给nil的消息将返回0。结构体中各个字段的值将都是0。其他的结构体数据类型将不是用0填充的。</li>
<li>如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</li>
</ul>
<h2 id="Nil"><a href="#Nil" class="headerlink" title="Nil"></a>Nil</h2><p>Nil是OC类类型的书面空值，对应<code>Class</code>类型对象。底层实现和nil是一样的。Nil的定义如下：</p>
<pre><code>#ifndef Nil
# if __has_feature(cxx_nullptr)
#   define Nil nullptr
# else
#   define Nil __DARWIN_NULL
# endif
#endif

#ifndef nil
# if __has_feature(cxx_nullptr)
#   define nil nullptr
# else
#   define nil __DARWIN_NULL
# endif
#endif
</code></pre><h2 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a>NSNull</h2><p>在OC的集合中中nil代表集合的结束，所以不能在集合里存储nil。所以就有了NSNull用一个类来表示空值。一般用来表示集合中的空对象。</p>
<h2 id="NUL"><a href="#NUL" class="headerlink" title="NUL"></a>NUL</h2><p>用来表示字符串的结束。注意：标准C中无定义。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/07/不经意间/" itemprop="url">
                  你在哪里
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2016-02-07T19:33:15+08:00" content="2016-02-07">
              2016-02-07
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>不经意抬眼看见逐渐黯淡的黄昏</p>
<p>难以言喻的风景浮现出你的身影</p>
<p>若一切终将如清风般虚妄的飘散</p>
<p>那让这思绪也随之散去又有何妨</p>
<hr>
<p>启程于春 从那天清晨起踏上旅途</p>
<p>时至盛夏 怀想你我曾共赏的夜幕</p>
<p>阴冷深秋 黑夜覆盖了傍晚的天际</p>
<p>唤来隆冬 转眼又是一轮四季交替</p>
<p>飞花乱舞 参杂在纷繁的夜景深处</p>
<p>星辰陨落 款款光芒道出你的踪迹</p>
<p>月光倾洒 刻画出两条长长的身影</p>
<p>雪花飘散 掩埋无休止一年又一年</p>
<p>而你的身影依然遥远……</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/30/Xcode升级之后Alcatraz和插件失效/" itemprop="url">
                  Xcode升级之后Alcatraz和插件失效
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2016-01-30T13:31:11+08:00" content="2016-01-30">
              2016-01-30
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><a href="http://alcatraz.io" target="_blank" rel="noopener">Alcatraz</a>是一个非常好用的插件管理器。前一段时间把Xcode升级到了7.2之后Alcatraz失效了，而且之前安装的所有插件也都消失了。查了资料才知道Apple为了避免插件造成新版本的Xcode启动时崩溃，所以只允许匹配<code>DVTPlugInCompatibilityUUIDs</code>的插件被加载。</p>
<p>可以通过下面的方法激活之前安装的插件：</p>
<blockquote>
<pre><code>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID`
</code></pre></blockquote>
<p>另外如果你不小心在Xcode启动的时候点击了 <strong>Skip Bundle</strong>,你可以通过下面的方式避免重新安装的悲剧。</p>
<blockquote>
<pre><code>defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-{your_xcode_version} 
</code></pre></blockquote>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/30/MarkDown语法学习/" itemprop="url">
                  MarkDown语法学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2016-01-30T12:30:35+08:00" content="2016-01-30">
              2016-01-30
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>欢迎来到我的<a href="www.liudesheng.com">博客</a>,第一篇我们会学习使用MarkDown语法来书写文章。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown语法中，标题是文本前面加上<code>#</code>来表示的，一个#代表一级标题，同里，还可以增加二级标题，三级标题，最大不能超过六级。例如:</p>
<blockquote>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre></blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表只需在文字前面加上 <code>-</code>。例如：</p>
<blockquote>
<pre><code>- 文本1
- 文本2
- 文本3
</code></pre></blockquote>
<p>如果需要创建有序列表，在文字前加上1.2.3.。注意：-、1.和文本之间要保留一个空格。例如:</p>
<blockquote>
<pre><code>1. 文本1
2. 文本2
3. 文本3
</code></pre></blockquote>
<h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2><p>在Markdown中，插入链接需要语法即可。例如:</p>
<blockquote>
<pre><code>[博客](www.liudesheng.com)
</code></pre></blockquote>
<p>插入图片使用以下的格式：</p>
<blockquote>
<pre><code>![]()(http://weibo.com/hnrain?s=6cm7D0)
</code></pre></blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果在写作的时候需要引用别人的文字，直接在需要引用的文字前面加<code>&gt;</code>就好。例如：</p>
<blockquote>
<pre><code>这是一段引用的文字。
</code></pre></blockquote>
<h2 id="粗体斜体"><a href="#粗体斜体" class="headerlink" title="粗体斜体"></a>粗体斜体</h2><p>用两个<code>*</code>包含的文本是粗体，用一个<code>*</code>包含的文本是斜体。例如:</p>
<blockquote>
<pre><code>**这是粗体**
*这是斜体*
</code></pre><p>生存还是<strong>毁灭</strong>,这是一个<em>问题</em>。</p>
</blockquote>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>在MarkDown中表格的表示方式非常形象。例子如下</p>
<blockquote>
<pre><code>| table            | row           | pes  |
| -------------     |:-------------:| -----:|
| col1              | right-aligned | data12345 |
| col2              | centered      | data2 |
| col3             | test      |    d3 |
</code></pre></blockquote>
<p>默认居左，横线两边加冒号的是居中，冒号在右边的是居右。效果如下：</p>
<table>
<thead>
<tr>
<th>table</th>
<th style="text-align:center">row</th>
<th style="text-align:right">pes</th>
</tr>
</thead>
<tbody>
<tr>
<td>col1</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">data12345</td>
</tr>
<tr>
<td>col2</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">data2</td>
</tr>
<tr>
<td>col3</td>
<td style="text-align:center">test</td>
<td style="text-align:right">d3</td>
</tr>
</tbody>
</table>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xorsh.com1.z0.glb.clouddn.com/headIcon.jpg" alt="天意" itemprop="image">
          <p class="site-author-name" itemprop="name">天意</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">categories</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">tags</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">天意</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
